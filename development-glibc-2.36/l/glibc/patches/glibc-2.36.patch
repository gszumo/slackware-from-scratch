diff -aurN glibc-2.36/assert/assert.c glibc-20220830_c7509d49c4/assert/assert.c
--- glibc-2.36/assert/assert.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/assert/assert.c	2022-08-31 07:16:41.000000000 +0200
@@ -101,4 +101,3 @@
   __assert_fail_base (_("%s%s%s:%u: %s%sAssertion `%s' failed.\n%n"),
 		      assertion, file, line, function);
 }
-hidden_def(__assert_fail)
diff -aurN glibc-2.36/assert/__libc_assert_fail.c glibc-20220830_c7509d49c4/assert/__libc_assert_fail.c
--- glibc-2.36/assert/__libc_assert_fail.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/assert/__libc_assert_fail.c	2022-08-31 07:16:41.000000000 +0200
@@ -0,0 +1,33 @@
+/* libc-internal assert that calls __libc_message.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <_itoa.h>
+#include <array_length.h>
+#include <intprops.h>
+#include <stdio.h>
+
+void
+__libc_assert_fail (const char *assertion, const char *file, unsigned int line,
+                    const char *function)
+{
+  char linebuf[INT_BUFSIZE_BOUND (unsigned int)];
+  array_end (linebuf)[-1] = '\0';
+  char *linestr = _itoa_word (line, array_end (linebuf) - 1, 10, 0);
+  __libc_message ("Fatal glibc error: %s:%s (%s): assertion failed: %s\n",
+                  file, linestr, function, assertion);
+}
diff -aurN glibc-2.36/assert/Makefile glibc-20220830_c7509d49c4/assert/Makefile
--- glibc-2.36/assert/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/assert/Makefile	2022-08-31 07:16:41.000000000 +0200
@@ -24,7 +24,12 @@
 
 headers	:= assert.h
 
-routines := assert assert-perr __assert
+routines := \
+  __assert \
+  __libc_assert_fail \
+  assert \
+  assert-perr \
+  # routines
 tests := test-assert test-assert-perr tst-assert-c++ tst-assert-g++
 
 ifeq ($(have-cxx-thread_local),yes)
diff -aurN glibc-2.36/bits/in.h glibc-20220830_c7509d49c4/bits/in.h
--- glibc-2.36/bits/in.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/bits/in.h	2022-08-31 07:16:41.000000000 +0200
@@ -104,6 +104,16 @@
 #define IPV6_PATHMTU		61
 #define IPV6_DONTFRAG		62
 
+/* Advanced API (RFC3542) (2).  */
+#define IPV6_RECVTCLASS		66
+#define IPV6_TCLASS		67
+
+/* RFC5014.  */
+#define IPV6_ADDR_PREFERENCES	72
+
+/* RFC5082.  */
+#define IPV6_MINHOPCOUNT	73
+
 /* Obsolete synonyms for the above.  */
 #define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
 #define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
diff -aurN glibc-2.36/bits/socket.h glibc-20220830_c7509d49c4/bits/socket.h
--- glibc-2.36/bits/socket.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/bits/socket.h	2022-08-31 07:16:41.000000000 +0200
@@ -245,6 +245,12 @@
 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
 #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
 
+/* Given a length, return the additional padding necessary such that
+   len + __CMSG_PADDING(len) == CMSG_ALIGN (len).  */
+#define __CMSG_PADDING(len) ((sizeof (size_t) \
+                              - ((len) & (sizeof (size_t) - 1))) \
+                             & (sizeof (size_t) - 1))
+
 extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
 				      struct cmsghdr *__cmsg) __THROW;
 #ifdef __USE_EXTERN_INLINES
@@ -254,18 +260,38 @@
 _EXTERN_INLINE struct cmsghdr *
 __NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
+  /* We may safely assume that __cmsg lies between __mhdr->msg_control and
+     __mhdr->msg_controllen because the user is required to obtain the first
+     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs
+     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet
+     trust the value of __cmsg->cmsg_len and therefore do not use it in any
+     pointer arithmetic until we check its value.  */
+
+  unsigned char * __msg_control_ptr = (unsigned char *) __mhdr->msg_control;
+  unsigned char * __cmsg_ptr = (unsigned char *) __cmsg;
+
+  size_t __size_needed = sizeof (struct cmsghdr)
+                         + __CMSG_PADDING (__cmsg->cmsg_len);
+
+  /* The current header is malformed, too small to be a full header.  */
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
     return (struct cmsghdr *) 0;
 
+  /* There isn't enough space between __cmsg and the end of the buffer to
+  hold the current cmsg *and* the next one.  */
+  if (((size_t)
+         (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr)
+       < __size_needed)
+      || ((size_t)
+            (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr
+             - __size_needed)
+          < __cmsg->cmsg_len))
+
+    return (struct cmsghdr *) 0;
+
+  /* Now, we trust cmsg_len and can use it to find the next header.  */
   __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
 			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
-					+ __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return (struct cmsghdr *) 0;
   return __cmsg;
 }
 #endif	/* Use `extern inline'.  */
diff -aurN glibc-2.36/debug/fortify_fail.c glibc-20220830_c7509d49c4/debug/fortify_fail.c
--- glibc-2.36/debug/fortify_fail.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/debug/fortify_fail.c	2022-08-31 07:16:41.000000000 +0200
@@ -21,8 +21,6 @@
 __attribute__ ((noreturn))
 __fortify_fail (const char *msg)
 {
-  /* The loop is added only to keep gcc happy.  */
-  while (1)
-    __libc_message (do_abort, "*** %s ***: terminated\n", msg);
+  __libc_message ("*** %s ***: terminated\n", msg);
 }
 libc_hidden_def (__fortify_fail)
diff -aurN glibc-2.36/dlfcn/dlopen.c glibc-20220830_c7509d49c4/dlfcn/dlopen.c
--- glibc-2.36/dlfcn/dlopen.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/dlfcn/dlopen.c	2022-08-31 07:16:41.000000000 +0200
@@ -90,7 +90,7 @@
 void *
 __dlopen (const char *file, int mode, void *dl_caller)
 {
-  return dlopen_implementation (file, mode, RETURN_ADDRESS (0));
+  return dlopen_implementation (file, mode, dl_caller);
 }
 
 void *
diff -aurN glibc-2.36/elf/cache.c glibc-20220830_c7509d49c4/elf/cache.c
--- glibc-2.36/elf/cache.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/cache.c	2022-08-31 07:16:41.000000000 +0200
@@ -157,6 +157,7 @@
 /* List of all cache entries.  */
 static struct cache_entry *entries;
 
+/* libc4, ELF and libc5 are unsupported.  */
 static const char *flag_descr[] =
 { "libc4", "ELF", "libc5", "libc6"};
 
@@ -168,14 +169,11 @@
   printf ("\t%s (", lib);
   switch (flag & FLAG_TYPE_MASK)
     {
-    case FLAG_LIBC4:
-    case FLAG_ELF:
-    case FLAG_ELF_LIBC5:
     case FLAG_ELF_LIBC6:
       fputs (flag_descr[flag & FLAG_TYPE_MASK], stdout);
       break;
     default:
-      fputs (_("unknown"), stdout);
+      fputs (_("unknown or unsupported flag"), stdout);
       break;
     }
   switch (flag & FLAG_REQUIRED_MASK)
diff -aurN glibc-2.36/elf/dl-cache.c glibc-20220830_c7509d49c4/elf/dl-cache.c
--- glibc-2.36/elf/dl-cache.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/dl-cache.c	2022-08-31 07:16:41.000000000 +0200
@@ -509,8 +509,9 @@
      we are accessing. Therefore we must make the copy of the
      mapping data without using malloc.  */
   char *temp;
-  temp = alloca (strlen (best) + 1);
-  strcpy (temp, best);
+  size_t best_len = strlen (best) + 1;
+  temp = alloca (best_len);
+  memcpy (temp, best, best_len);
   return __strdup (temp);
 }
 
diff -aurN glibc-2.36/elf/dl-diagnostics.c glibc-20220830_c7509d49c4/elf/dl-diagnostics.c
--- glibc-2.36/elf/dl-diagnostics.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/dl-diagnostics.c	2022-08-31 07:16:41.000000000 +0200
@@ -108,7 +108,7 @@
       if (high == 0)
         _dl_printf ("%s=0x%x\n", label, low);
       else
-        _dl_printf ("%s=0x%x%08x\n", label, high, low);
+        _dl_printf ("%s=0x%x%0*x\n", label, high, 8, low);
     }
 }
 
diff -aurN glibc-2.36/elf/dl-open.c glibc-20220830_c7509d49c4/elf/dl-open.c
--- glibc-2.36/elf/dl-open.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/dl-open.c	2022-08-31 07:16:41.000000000 +0200
@@ -844,11 +844,14 @@
 	  _dl_signal_error (EINVAL, file, NULL, N_("\
 no more namespaces available for dlmopen()"));
 	}
-      else if (nsid == GL(dl_nns))
-	{
-	  __rtld_lock_initialize (GL(dl_ns)[nsid]._ns_unique_sym_table.lock);
-	  ++GL(dl_nns);
-	}
+
+      if (nsid == GL(dl_nns))
+	++GL(dl_nns);
+
+      /* Initialize the new namespace.  Most members are
+	 zero-initialized, only the lock needs special treatment.  */
+      memset (&GL(dl_ns)[nsid], 0, sizeof (GL(dl_ns)[nsid]));
+      __rtld_lock_initialize (GL(dl_ns)[nsid]._ns_unique_sym_table.lock);
 
       _dl_debug_update (nsid)->r_state = RT_CONSISTENT;
     }
diff -aurN glibc-2.36/elf/dl-tunables.list glibc-20220830_c7509d49c4/elf/dl-tunables.list
--- glibc-2.36/elf/dl-tunables.list	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/dl-tunables.list	2022-08-31 07:16:41.000000000 +0200
@@ -42,6 +42,7 @@
       type: SIZE_T
       env_alias: MALLOC_TOP_PAD_
       security_level: SXID_IGNORE
+      default: 131072
     }
     perturb {
       type: INT_32
diff -aurN glibc-2.36/elf/elf.h glibc-20220830_c7509d49c4/elf/elf.h
--- glibc-2.36/elf/elf.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/elf.h	2022-08-31 07:16:41.000000000 +0200
@@ -506,6 +506,7 @@
 
 /* Legal values for ch_type (compression algorithm).  */
 #define ELFCOMPRESS_ZLIB	1	   /* ZLIB/DEFLATE algorithm.  */
+#define ELFCOMPRESS_ZSTD	2	   /* Zstandard algorithm.  */
 #define ELFCOMPRESS_LOOS	0x60000000 /* Start of OS-specific.  */
 #define ELFCOMPRESS_HIOS	0x6fffffff /* End of OS-specific.  */
 #define ELFCOMPRESS_LOPROC	0x70000000 /* Start of processor-specific.  */
@@ -829,6 +830,15 @@
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers.  */
 #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode.  */
 #define NT_MIPS_MSA	0x802		/* MIPS SIMD registers.  */
+#define NT_LOONGARCH_CPUCFG	0xa00	/* LoongArch CPU config registers.  */
+#define NT_LOONGARCH_CSR	0xa01	/* LoongArch control and
+					   status registers.  */
+#define NT_LOONGARCH_LSX	0xa02	/* LoongArch Loongson SIMD
+					   Extension registers.  */
+#define NT_LOONGARCH_LASX	0xa03	/* LoongArch Loongson Advanced
+					   SIMD Extension registers.  */
+#define NT_LOONGARCH_LBT	0xa04	/* LoongArch Loongson Binary
+					   Translation registers.  */
 
 /* Legal values for the note segment descriptor types for object files.  */
 
diff -aurN glibc-2.36/elf/ldconfig.c glibc-20220830_c7509d49c4/elf/ldconfig.c
--- glibc-2.36/elf/ldconfig.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/ldconfig.c	2022-08-31 07:16:41.000000000 +0200
@@ -65,19 +65,6 @@
 
 #define PACKAGE _libc_intl_domainname
 
-static const struct
-{
-  const char *name;
-  int flag;
-} lib_types[] =
-{
-  {"libc4", FLAG_LIBC4},
-  {"libc5", FLAG_ELF_LIBC5},
-  {"libc6", FLAG_ELF_LIBC6},
-  {"glibc2", FLAG_ELF_LIBC6}
-};
-
-
 /* List of directories to handle.  */
 struct dir_entry
 {
@@ -469,27 +456,8 @@
   entry->from_file = strdup (from_file);
   entry->from_line = from_line;
 
-  /* Search for an '=' sign.  */
   entry->path = xstrdup (line);
-  char *equal_sign = strchr (entry->path, '=');
-  if (equal_sign)
-    {
-      *equal_sign = '\0';
-      ++equal_sign;
-      entry->flag = FLAG_ANY;
-      for (i = 0; i < sizeof (lib_types) / sizeof (lib_types[0]); ++i)
-	if (strcmp (equal_sign, lib_types[i].name) == 0)
-	  {
-	    entry->flag = lib_types[i].flag;
-	    break;
-	  }
-      if (entry->flag == FLAG_ANY)
-	error (0, 0, _("%s is not a known library type"), equal_sign);
-    }
-  else
-    {
-      entry->flag = FLAG_ANY;
-    }
+  entry->flag = FLAG_ELF_LIBC6;
 
   /* Canonify path: for now only remove leading and trailing
      whitespace and the trailing slashes.  */
@@ -1054,23 +1022,11 @@
 	  soname = xstrdup (direntry->d_name);
 	}
 
-      if (flag == FLAG_ELF
-	  && (entry->flag == FLAG_ELF_LIBC5
-	      || entry->flag == FLAG_ELF_LIBC6))
-	flag = entry->flag;
-
       /* Some sanity checks to print warnings.  */
       if (opt_verbose)
 	{
-	  if (flag == FLAG_ELF_LIBC5 && entry->flag != FLAG_ELF_LIBC5
-	      && entry->flag != FLAG_ANY)
-	    error (0, 0, _("libc5 library %s in wrong directory"), file_name);
-	  if (flag == FLAG_ELF_LIBC6 && entry->flag != FLAG_ELF_LIBC6
-	      && entry->flag != FLAG_ANY)
+	  if (flag == FLAG_ELF_LIBC6 && entry->flag != FLAG_ELF_LIBC6)
 	    error (0, 0, _("libc6 library %s in wrong directory"), file_name);
-	  if (flag == FLAG_LIBC4 && entry->flag != FLAG_LIBC4
-	      && entry->flag != FLAG_ANY)
-	    error (0, 0, _("libc4 library %s in wrong directory"), file_name);
 	}
 
       /* Add library to list.  */
@@ -1089,19 +1045,8 @@
 		  /* It's newer - add it.  */
 		  /* Flag should be the same - sanity check.  */
 		  if (dlib_ptr->flag != flag)
-		    {
-		      if (dlib_ptr->flag == FLAG_ELF
-			  && (flag == FLAG_ELF_LIBC5 || flag == FLAG_ELF_LIBC6))
-			dlib_ptr->flag = flag;
-		      else if ((dlib_ptr->flag == FLAG_ELF_LIBC5
-				|| dlib_ptr->flag == FLAG_ELF_LIBC6)
-			       && flag == FLAG_ELF)
-			dlib_ptr->flag = flag;
-		      else
-			error (0, 0, _("libraries %s and %s in directory %s have same soname but different type."),
-			       dlib_ptr->name, direntry->d_name,
-			       entry->path);
-		    }
+		    error (0, 0, _("libraries %s and %s in directory %s have same soname but different type."),
+			   dlib_ptr->name, direntry->d_name, entry->path);
 		  free (dlib_ptr->name);
 		  dlib_ptr->name = xstrdup (direntry->d_name);
 		  dlib_ptr->is_link = is_link;
diff -aurN glibc-2.36/elf/Makefile glibc-20220830_c7509d49c4/elf/Makefile
--- glibc-2.36/elf/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/Makefile	2022-08-31 07:16:41.000000000 +0200
@@ -374,6 +374,8 @@
   tst-align \
   tst-align2 \
   tst-align3 \
+  tst-audit-tlsdesc \
+  tst-audit-tlsdesc-dlopen \
   tst-audit1 \
   tst-audit2 \
   tst-audit8 \
@@ -408,6 +410,7 @@
   tst-dlmopen4 \
   tst-dlmopen-dlerror \
   tst-dlmopen-gethostbyname \
+  tst-dlmopen-twice \
   tst-dlopenfail \
   tst-dlopenfail-2 \
   tst-dlopenrpath \
@@ -765,6 +768,8 @@
   tst-alignmod3 \
   tst-array2dep \
   tst-array5dep \
+  tst-audit-tlsdesc-mod1 \
+  tst-audit-tlsdesc-mod2 \
   tst-audit11mod1 \
   tst-audit11mod2 \
   tst-audit12mod1 \
@@ -798,6 +803,7 @@
   tst-auditmanymod7 \
   tst-auditmanymod8 \
   tst-auditmanymod9 \
+  tst-auditmod-tlsdesc  \
   tst-auditmod1 \
   tst-auditmod9a \
   tst-auditmod9b \
@@ -834,6 +840,8 @@
   tst-dlmopen1mod \
   tst-dlmopen-dlerror-mod \
   tst-dlmopen-gethostbyname-mod \
+  tst-dlmopen-twice-mod1 \
+  tst-dlmopen-twice-mod2 \
   tst-dlopenfaillinkmod \
   tst-dlopenfailmod1 \
   tst-dlopenfailmod2 \
@@ -990,23 +998,8 @@
 $(objpfx)tst-gnu2-tls1: $(objpfx)tst-gnu2-tls1mod.so
 tst-gnu2-tls1mod.so-no-z-defs = yes
 CFLAGS-tst-gnu2-tls1mod.c += -mtls-dialect=gnu2
+endif # $(have-mtls-dialect-gnu2)
 
-tests += tst-audit-tlsdesc tst-audit-tlsdesc-dlopen
-modules-names += tst-audit-tlsdesc-mod1 tst-audit-tlsdesc-mod2 tst-auditmod-tlsdesc
-$(objpfx)tst-audit-tlsdesc: $(objpfx)tst-audit-tlsdesc-mod1.so \
-			    $(objpfx)tst-audit-tlsdesc-mod2.so \
-			    $(shared-thread-library)
-CFLAGS-tst-audit-tlsdesc-mod1.c += -mtls-dialect=gnu2
-CFLAGS-tst-audit-tlsdesc-mod2.c += -mtls-dialect=gnu2
-$(objpfx)tst-audit-tlsdesc-dlopen: $(shared-thread-library)
-$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-audit-tlsdesc-mod1.so \
-				       $(objpfx)tst-audit-tlsdesc-mod2.so
-$(objpfx)tst-audit-tlsdesc-mod1.so: $(objpfx)tst-audit-tlsdesc-mod2.so
-$(objpfx)tst-audit-tlsdesc.out: $(objpfx)tst-auditmod-tlsdesc.so
-tst-audit-tlsdesc-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
-$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-auditmod-tlsdesc.so
-tst-audit-tlsdesc-dlopen-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
-endif
 ifeq (yes,$(have-protected-data))
 modules-names += tst-protected1moda tst-protected1modb
 tests += tst-protected1a tst-protected1b
@@ -1283,6 +1276,7 @@
 rtld-stubbed-symbols = \
   __GI___pthread_disable_asynccancel \
   __GI___pthread_enable_asynccancel \
+  __libc_assert_fail \
   __pthread_disable_asynccancel \
   __pthread_enable_asynccancel \
   calloc \
@@ -2967,3 +2961,25 @@
 	grep -q '^Fatal glibc error: Cannot allocate TLS block$$' $@ \
 	  && grep -q '^status: 127$$' $@; \
 	  $(evaluate-test)
+
+$(objpfx)tst-audit-tlsdesc: $(objpfx)tst-audit-tlsdesc-mod1.so \
+			    $(objpfx)tst-audit-tlsdesc-mod2.so \
+			    $(shared-thread-library)
+ifeq (yes,$(have-mtls-dialect-gnu2))
+# The test is valid for all TLS types, but we want to exercise GNU2
+# TLS if possible.
+CFLAGS-tst-audit-tlsdesc-mod1.c += -mtls-dialect=gnu2
+CFLAGS-tst-audit-tlsdesc-mod2.c += -mtls-dialect=gnu2
+endif
+$(objpfx)tst-audit-tlsdesc-dlopen: $(shared-thread-library)
+$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-audit-tlsdesc-mod1.so \
+				       $(objpfx)tst-audit-tlsdesc-mod2.so
+$(objpfx)tst-audit-tlsdesc-mod1.so: $(objpfx)tst-audit-tlsdesc-mod2.so
+$(objpfx)tst-audit-tlsdesc.out: $(objpfx)tst-auditmod-tlsdesc.so
+tst-audit-tlsdesc-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
+$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-auditmod-tlsdesc.so
+tst-audit-tlsdesc-dlopen-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
+
+$(objpfx)tst-dlmopen-twice.out: \
+  $(objpfx)tst-dlmopen-twice-mod1.so \
+  $(objpfx)tst-dlmopen-twice-mod2.so
diff -aurN glibc-2.36/elf/readelflib.c glibc-20220830_c7509d49c4/elf/readelflib.c
--- glibc-2.36/elf/readelflib.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/readelflib.c	2022-08-31 07:16:41.000000000 +0200
@@ -44,7 +44,6 @@
 		  size_t file_length)
 {
   int i;
-  unsigned int j;
   unsigned int dynamic_addr;
   size_t dynamic_size;
   char *program_interpreter;
@@ -81,9 +80,8 @@
   elf_pheader = (ElfW(Phdr) *) (elf_header->e_phoff + file_contents);
   check_ptr (elf_pheader);
 
-  /* The library is an elf library, now search for soname and
-     libc5/libc6.  */
-  *flag = FLAG_ELF;
+  /* The library is an elf library.  */
+  *flag = FLAG_ELF_LIBC6;
 
   /* The default ISA level is 0.  */
   *isa_level = 0;
@@ -110,16 +108,6 @@
 	  program_interpreter = (char *) (file_contents + segment->p_offset);
 	  check_ptr (program_interpreter);
 
-	  /* Check if this is enough to classify the binary.  */
-	  for (j = 0; j < sizeof (interpreters) / sizeof (interpreters [0]);
-	       ++j)
-	    if (strcmp (program_interpreter, interpreters[j].soname) == 0)
-	      {
-		*flag = interpreters[j].flag;
-		break;
-	      }
-	  break;
-
 	case PT_GNU_PROPERTY:
 	  /* The NT_GNU_PROPERTY_TYPE_0 note must be aligned to 4 bytes
 	     in 32-bit objects and to 8 bytes in 64-bit objects.  Skip
@@ -244,38 +232,16 @@
   if (dynamic_strings == NULL)
     return 1;
 
-  /* Now read the DT_NEEDED and DT_SONAME entries.  */
+  /* Now read the DT_SONAME entries.  */
   for (dyn_entry = dynamic_segment; dyn_entry->d_tag != DT_NULL;
        ++dyn_entry)
     {
-      if (dyn_entry->d_tag == DT_NEEDED || dyn_entry->d_tag == DT_SONAME)
+      if (dyn_entry->d_tag == DT_SONAME)
 	{
 	  char *name = dynamic_strings + dyn_entry->d_un.d_val;
 	  check_ptr (name);
-
-	  if (dyn_entry->d_tag == DT_NEEDED)
-	    {
-
-	      if (*flag == FLAG_ELF)
-		{
-		  /* Check if this is enough to classify the binary.  */
-		  for (j = 0;
-		       j < sizeof (known_libs) / sizeof (known_libs [0]);
-		       ++j)
-		    if (strcmp (name, known_libs [j].soname) == 0)
-		      {
-			*flag = known_libs [j].flag;
-			break;
-		      }
-		}
-	    }
-
-	  else if (dyn_entry->d_tag == DT_SONAME)
-	    *soname = xstrdup (name);
-
-	  /* Do we have everything we need?  */
-	  if (*soname && *flag != FLAG_ELF)
-	    return 0;
+          *soname = xstrdup (name);
+          return 0;
 	}
     }
 
diff -aurN glibc-2.36/elf/readlib.c glibc-20220830_c7509d49c4/elf/readlib.c
--- glibc-2.36/elf/readlib.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/readlib.c	2022-08-31 07:16:41.000000000 +0200
@@ -43,24 +43,6 @@
   int flag;
 };
 
-static struct known_names interpreters[] =
-{
-  { "/lib/" LD_SO, FLAG_ELF_LIBC6 },
-#ifdef SYSDEP_KNOWN_INTERPRETER_NAMES
-  SYSDEP_KNOWN_INTERPRETER_NAMES
-#endif
-};
-
-static struct known_names known_libs[] =
-{
-  { LIBC_SO, FLAG_ELF_LIBC6 },
-  { LIBM_SO, FLAG_ELF_LIBC6 },
-#ifdef SYSDEP_KNOWN_LIBRARY_NAMES
-  SYSDEP_KNOWN_LIBRARY_NAMES
-#endif
-};
-
-
 /* Check if string corresponds to a GDB Python file.  */
 static bool
 is_gdb_python_file (const char *name)
@@ -83,7 +65,8 @@
   struct exec *aout_header;
 
   ret = 0;
-  *flag = FLAG_ANY;
+  /* Just set FLAG_ELF_LIBC6 as old formats are not supported anymore.  */
+  *flag = FLAG_ELF_LIBC6;
   *soname = NULL;
 
   file = fopen (real_file_name, "rb");
@@ -150,7 +133,6 @@
 	    *dot = '\0';
 	}
       *soname = copy;
-      *flag = FLAG_LIBC4;
       goto done;
     }
 
@@ -191,9 +173,6 @@
 {
   char *soname = xstrdup (lib);
 
-  if ((flag & FLAG_TYPE_MASK) != FLAG_LIBC4)
-    return soname;
-
   /* Aout files don't have a soname, just return the name
      including the major number.  */
   char *major = strstr (soname, ".so.");
diff -aurN glibc-2.36/elf/tst-dlmopen-twice.c glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice.c
--- glibc-2.36/elf/tst-dlmopen-twice.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice.c	2022-08-31 07:16:41.000000000 +0200
@@ -0,0 +1,34 @@
+/* Initialization of libc after dlmopen/dlclose/dlmopen (bug 29528).  Main.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/xdlfcn.h>
+#include <support/check.h>
+
+static int
+do_test (void)
+{
+  void *handle = xdlmopen (LM_ID_NEWLM, "tst-dlmopen-twice-mod1.so", RTLD_NOW);
+  xdlclose (handle);
+  handle = xdlmopen (LM_ID_NEWLM, "tst-dlmopen-twice-mod2.so", RTLD_NOW);
+  int (*run_check) (void) = xdlsym (handle, "run_check");
+  TEST_COMPARE (run_check (), 0);
+  xdlclose (handle);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/elf/tst-dlmopen-twice-mod1.c glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice-mod1.c
--- glibc-2.36/elf/tst-dlmopen-twice-mod1.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice-mod1.c	2022-08-31 07:16:41.000000000 +0200
@@ -0,0 +1,37 @@
+/* Initialization of libc after dlmopen/dlclose/dlmopen (bug 29528).  Module 1.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  puts ("info: tst-dlmopen-twice-mod1.so loaded");
+  fflush (stdout);
+}
+
+static void __attribute__ ((destructor))
+fini (void)
+{
+  puts ("info: tst-dlmopen-twice-mod1.so about to be unloaded");
+  fflush (stdout);
+}
+
+/* Large allocation.  The second module does not have this, so it
+   should load libc at a different address.  */
+char large_allocate[16 * 1024 * 1024];
diff -aurN glibc-2.36/elf/tst-dlmopen-twice-mod2.c glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice-mod2.c
--- glibc-2.36/elf/tst-dlmopen-twice-mod2.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/elf/tst-dlmopen-twice-mod2.c	2022-08-31 07:16:41.000000000 +0200
@@ -0,0 +1,50 @@
+/* Initialization of libc after dlmopen/dlclose/dlmopen (bug 29528).  Module 2.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <ctype.h>
+#include <stdio.h>
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  puts ("info: tst-dlmopen-twice-mod2.so loaded");
+  fflush (stdout);
+}
+
+static void __attribute__ ((destructor))
+fini (void)
+{
+  puts ("info: tst-dlmopen-twice-mod2.so about to be unloaded");
+  fflush (stdout);
+}
+
+int
+run_check (void)
+{
+  puts ("info: about to call isalpha");
+  fflush (stdout);
+
+  volatile char ch = 'a';
+  if (!isalpha (ch))
+    {
+      puts ("error: isalpha ('a') is not true");
+      fflush (stdout);
+      return 1;
+    }
+  return 0;
+}
diff -aurN glibc-2.36/elf/tst-glibcelf.py glibc-20220830_c7509d49c4/elf/tst-glibcelf.py
--- glibc-2.36/elf/tst-glibcelf.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/tst-glibcelf.py	2022-08-31 07:16:41.000000000 +0200
@@ -240,6 +240,24 @@
             error('{}: glibcelf has {!r}, <elf.h> has {!r}'.format(
                 name, glibcelf_value, elf_h_value))
 
+def check_hashes():
+    for name, expected_elf, expected_gnu in (
+            ('', 0, 0x1505),
+            ('PPPPPPPPPPPP', 0, 0x9f105c45),
+            ('GLIBC_2.0', 0xd696910, 0xf66c3dd5),
+            ('GLIBC_2.34', 0x69691b4, 0xc3f3f90c),
+            ('GLIBC_PRIVATE', 0x963cf85, 0x692a260)):
+        for convert in (lambda x: x, lambda x: x.encode('UTF-8')):
+            name = convert(name)
+            actual_elf = glibcelf.elf_hash(name)
+            if actual_elf != expected_elf:
+                error('elf_hash({!r}): {:x} != 0x{:x}'.format(
+                    name, actual_elf, expected_elf))
+            actual_gnu = glibcelf.gnu_hash(name)
+            if actual_gnu != expected_gnu:
+                error('gnu_hash({!r}): {:x} != 0x{:x}'.format(
+                    name, actual_gnu, expected_gnu))
+
 def main():
     """The main entry point."""
     parser = argparse.ArgumentParser(
@@ -251,6 +269,7 @@
     check_duplicates()
     check_constant_prefixes()
     check_constant_values(cc=args.cc)
+    check_hashes()
 
     if errors_encountered > 0:
         print("note: errors encountered:", errors_encountered)
diff -aurN glibc-2.36/elf/tst-rtld-list-tunables.exp glibc-20220830_c7509d49c4/elf/tst-rtld-list-tunables.exp
--- glibc-2.36/elf/tst-rtld-list-tunables.exp	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/elf/tst-rtld-list-tunables.exp	2022-08-31 07:16:41.000000000 +0200
@@ -9,7 +9,7 @@
 glibc.malloc.tcache_count: 0x0 (min: 0x0, max: 0x[f]+)
 glibc.malloc.tcache_max: 0x0 (min: 0x0, max: 0x[f]+)
 glibc.malloc.tcache_unsorted_limit: 0x0 (min: 0x0, max: 0x[f]+)
-glibc.malloc.top_pad: 0x0 (min: 0x0, max: 0x[f]+)
+glibc.malloc.top_pad: 0x20000 (min: 0x0, max: 0x[f]+)
 glibc.malloc.trim_threshold: 0x0 (min: 0x0, max: 0x[f]+)
 glibc.rtld.dynamic_sort: 2 (min: 1, max: 2)
 glibc.rtld.nns: 0x4 (min: 0x1, max: 0x10)
diff -aurN glibc-2.36/htl/cancellation.c glibc-20220830_c7509d49c4/htl/cancellation.c
--- glibc-2.36/htl/cancellation.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/htl/cancellation.c	2022-08-31 07:16:41.000000000 +0200
@@ -25,6 +25,10 @@
   struct __pthread *p = _pthread_self ();
   int oldtype;
 
+  if (___pthread_self == NULL)
+    /* We are not initialized yet, we can't be cancelled anyway.  */
+    return PTHREAD_CANCEL_DEFERRED;
+
   __pthread_mutex_lock (&p->cancel_lock);
   oldtype = p->cancel_type;
   p->cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
@@ -39,6 +43,10 @@
 {
   struct __pthread *p = _pthread_self ();
 
+  if (___pthread_self == NULL)
+    /* We are not initialized yet, we can't be cancelled anyway.  */
+    return;
+
   __pthread_mutex_lock (&p->cancel_lock);
   p->cancel_type = oldtype;
   __pthread_mutex_unlock (&p->cancel_lock);
diff -aurN glibc-2.36/htl/pt-self.c glibc-20220830_c7509d49c4/htl/pt-self.c
--- glibc-2.36/htl/pt-self.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/htl/pt-self.c	2022-08-31 07:16:41.000000000 +0200
@@ -24,7 +24,13 @@
 pthread_t
 __pthread_self (void)
 {
-  struct __pthread *self = _pthread_self ();
+  struct __pthread *self;
+
+  if (___pthread_self == NULL)
+    /* We are not initialized yet, we are the first thread.  */
+    return 1;
+
+  self = _pthread_self ();
   assert (self != NULL);
 
   return self->thread;
diff -aurN glibc-2.36/hurd/fd-write.c glibc-20220830_c7509d49c4/hurd/fd-write.c
--- glibc-2.36/hurd/fd-write.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/fd-write.c	2022-08-31 07:16:41.000000000 +0200
@@ -26,7 +26,7 @@
 		const void *buf, size_t *nbytes, loff_t offset)
 {
   error_t err;
-  mach_msg_type_number_t wrote;
+  vm_size_t wrote;
 
   error_t writefd (io_t port)
     {
diff -aurN glibc-2.36/hurd/fopenport.c glibc-20220830_c7509d49c4/hurd/fopenport.c
--- glibc-2.36/hurd/fopenport.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/fopenport.c	2022-08-31 07:16:41.000000000 +0200
@@ -48,7 +48,7 @@
 static ssize_t
 writeio (void *cookie, const char *buf, size_t n)
 {
-  mach_msg_type_number_t wrote;
+  vm_size_t wrote;
   error_t err;
 
   if (err = __io_write ((io_t) cookie, buf, n, -1, &wrote))
diff -aurN glibc-2.36/hurd/get-host.c glibc-20220830_c7509d49c4/hurd/get-host.c
--- glibc-2.36/hurd/get-host.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/get-host.c	2022-08-31 07:16:41.000000000 +0200
@@ -27,7 +27,8 @@
 {
   error_t err;
   char *data;
-  mach_msg_type_number_t nread, more;
+  mach_msg_type_number_t nread;
+  vm_size_t more;
   file_t config;
 
   err = __hurd_file_name_lookup (&_hurd_ports_use, &__getdport, 0,
diff -aurN glibc-2.36/hurd/hurdioctl.c glibc-20220830_c7509d49c4/hurd/hurdioctl.c
--- glibc-2.36/hurd/hurdioctl.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/hurdioctl.c	2022-08-31 07:16:41.000000000 +0200
@@ -70,7 +70,7 @@
 
     case FIONREAD:
       {
-	mach_msg_type_number_t navail;
+	vm_size_t navail;
 	err = HURD_DPORT_USE (fd, __io_readable (port, &navail));
 	if (!err)
 	  *arg = (int) navail;
diff -aurN glibc-2.36/hurd/set-host.c glibc-20220830_c7509d49c4/hurd/set-host.c
--- glibc-2.36/hurd/set-host.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/set-host.c	2022-08-31 07:16:41.000000000 +0200
@@ -24,7 +24,7 @@
 _hurd_set_host_config (const char *item, const char *value, size_t valuelen)
 {
   error_t err;
-  mach_msg_type_number_t nwrote;
+  vm_size_t nwrote;
   file_t new, dir;
   char *name;
 
diff -aurN glibc-2.36/hurd/vpprintf.c glibc-20220830_c7509d49c4/hurd/vpprintf.c
--- glibc-2.36/hurd/vpprintf.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/hurd/vpprintf.c	2022-08-31 07:16:41.000000000 +0200
@@ -25,8 +25,8 @@
 static ssize_t
 do_write (void *cookie,	const char *buf, size_t n)
 {
-  error_t error = __io_write ((io_t) cookie, buf, n, -1,
-			      (mach_msg_type_number_t *) &n);
+  vm_size_t amount = n;
+  error_t error = __io_write ((io_t) cookie, buf, n, -1, &amount);
   if (error)
     return __hurd_fail (error);
   return n;
diff -aurN glibc-2.36/include/arpa/nameser.h glibc-20220830_c7509d49c4/include/arpa/nameser.h
--- glibc-2.36/include/arpa/nameser.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/include/arpa/nameser.h	2022-08-31 07:16:41.000000000 +0200
@@ -55,6 +55,12 @@
 int __ns_name_unpack (const unsigned char *, const unsigned char *,
 		      const unsigned char *, unsigned char *, size_t) __THROW;
 
+/* Like ns_samename, but for uncompressed binary names.  Return true
+   if the two arguments compare are equal as case-insensitive domain
+   names.  */
+_Bool __ns_samebinaryname (const unsigned char *, const unsigned char *)
+  attribute_hidden;
+
 #define ns_msg_getflag(handle, flag) \
   (((handle)._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift)
 
@@ -89,5 +95,105 @@
 extern __typeof (ns_samename) __libc_ns_samename;
 libc_hidden_proto (__libc_ns_samename)
 
+/* Packet parser helper functions.  */
+
+/* Verify that P points to an uncompressed domain name in wire format.
+   On success, return the length of the encoded name, including the
+   terminating null byte.  On failure, return -1 and set errno.  EOM
+   must point one past the last byte in the packet.  */
+int __ns_name_length_uncompressed (const unsigned char *p,
+				   const unsigned char *eom) attribute_hidden;
+
+/* Iterator over the resource records in a DNS packet.  */
+struct ns_rr_cursor
+{
+  /* These members are not changed after initialization.  */
+  const unsigned char *begin;	/* First byte of packet.  */
+  const unsigned char *end;	/* One past the last byte of the packet.  */
+  const unsigned char *first_rr; /* First resource record (or packet end).  */
+
+  /* Advanced towards the end while reading the packet.  */
+  const unsigned char *current;
+};
+
+/* Returns the RCODE field from the DNS header.  */
+static inline int
+ns_rr_cursor_rcode (const struct ns_rr_cursor *c)
+{
+  return c->begin[3] & 0x0f;	/* Lower 4 bits at offset 3.  */
+}
+
+/* Returns the length of the answer section according to the DNS header.  */
+static inline int
+ns_rr_cursor_ancount (const struct ns_rr_cursor *c)
+{
+  return c->begin[6] * 256 + c->begin[7]; /* 16 bits at offset 6.  */
+}
+
+/* Returns the length of the authority (name server) section according
+   to the DNS header.  */
+static inline int
+ns_rr_cursor_nscount (const struct ns_rr_cursor *c)
+{
+  return c->begin[8] * 256 + c->begin[9]; /* 16 bits at offset 8.  */
+}
+
+/* Returns the length of the additional data section according to the
+   DNS header.  */
+static inline int
+ns_rr_cursor_adcount (const struct ns_rr_cursor *c)
+{
+  return c->begin[10] * 256 + c->begin[11]; /* 16 bits at offset 10.  */
+}
+
+/* Returns a pointer to the uncompressed question name in wire
+   format.  */
+static inline const unsigned char *
+ns_rr_cursor_qname (const struct ns_rr_cursor *c)
+{
+  return c->begin + 12;		/* QNAME starts right after the header.  */
+}
+
+/* Returns the question type of the first and only question.  */
+static inline const int
+ns_rr_cursor_qtype (const struct ns_rr_cursor *c)
+{
+  /* 16 bits 4 bytes back from the first RR header start.  */
+  return c->first_rr[-4] * 256 + c->first_rr[-3];
+}
+
+/* Returns the clss of the first and only question (usally C_IN).  */
+static inline const int
+ns_rr_cursor_qclass (const struct ns_rr_cursor *c)
+{
+  /* 16 bits 2 bytes back from the first RR header start.  */
+  return c->first_rr[-2] * 256 + c->first_rr[-1];
+}
+
+/* Initializes *C to cover the packet [BUF, BUF+LEN).  Returns false
+   if LEN is less than sizeof (*HD), if the packet does not contain a
+   full (uncompressed) question, or if the question count is not 1.  */
+_Bool __ns_rr_cursor_init (struct ns_rr_cursor *c,
+			   const unsigned char *buf, size_t len)
+  attribute_hidden;
+
+/* Like ns_rr, but the record owner name is not decoded into text format.  */
+struct ns_rr_wire
+{
+  unsigned char rname[NS_MAXCDNAME]; /* Owner name of the record.  */
+  uint16_t rtype;		/* Resource record type (T_*).  */
+  uint16_t rclass;		/* Resource record class (C_*).  */
+  uint32_t ttl;			/* Time-to-live field.  */
+  const unsigned char *rdata;	/* Start of resource record data.  */
+  uint16_t rdlength;		/* Length of the data at rdata, in bytes.  */
+};
+
+/* Attempts to parse the record at C into *RR.  On success, return
+   true, and C is advanced past the record, and RR->rdata points to
+   the record data.  On failure, errno is set to EMSGSIZE, and false
+   is returned.  */
+_Bool __ns_rr_cursor_next (struct ns_rr_cursor *c, struct ns_rr_wire *rr)
+  attribute_hidden;
+
 # endif /* !_ISOMAC */
 #endif
diff -aurN glibc-2.36/include/assert.h glibc-20220830_c7509d49c4/include/assert.h
--- glibc-2.36/include/assert.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/include/assert.h	2022-08-31 07:16:41.000000000 +0200
@@ -20,8 +20,14 @@
 				const char *function)
      __THROW  __attribute__ ((__noreturn__)) attribute_hidden;
 
-# if IS_IN (libc) || (IS_IN (rtld) && !defined NO_RTLD_HIDDEN)
-hidden_proto (__assert_fail)
-hidden_proto (__assert_perror_fail)
+rtld_hidden_proto (__assert_fail)
+rtld_hidden_proto (__assert_perror_fail)
+libc_hidden_proto (__assert_perror_fail)
+
+
+# if IS_IN (libc)
+/* Redirect to the internal version which does not use stderr.  */
+extern _Noreturn __typeof (__assert_fail) __libc_assert_fail attribute_hidden;
+#  define __assert_fail __libc_assert_fail
 # endif
 #endif
diff -aurN glibc-2.36/include/bits/wchar2-decl.h glibc-20220830_c7509d49c4/include/bits/wchar2-decl.h
--- glibc-2.36/include/bits/wchar2-decl.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/include/bits/wchar2-decl.h	2022-08-31 07:16:41.000000000 +0200
@@ -0,0 +1 @@
+#include <wcsmbs/bits/wchar2-decl.h>
diff -aurN glibc-2.36/include/resolv.h glibc-20220830_c7509d49c4/include/resolv.h
--- glibc-2.36/include/resolv.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/include/resolv.h	2022-08-31 07:16:41.000000000 +0200
@@ -70,5 +70,8 @@
 extern __typeof (__res_queriesmatch) __libc_res_queriesmatch;
 libc_hidden_proto (__libc_res_queriesmatch)
 
+/* Variant of res_hnok which operates on binary (but uncompressed) names.  */
+bool __res_binary_hnok (const unsigned char *dn) attribute_hidden;
+
 # endif /* _RESOLV_H_ && !_ISOMAC */
 #endif
diff -aurN glibc-2.36/include/stdio.h glibc-20220830_c7509d49c4/include/stdio.h
--- glibc-2.36/include/stdio.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/include/stdio.h	2022-08-31 07:16:41.000000000 +0200
@@ -143,18 +143,11 @@
 #  define __GT_DIR	1	/* create a directory */
 #  define __GT_NOCREATE	2	/* just find a name not currently in use */
 
-enum __libc_message_action
-{
-  do_message	= 0,		/* Print message.  */
-  do_abort	= 1 << 0,	/* Abort.  */
-};
-
 /* Print out MESSAGE (which should end with a newline) on the error output
    and abort.  */
 extern void __libc_fatal (const char *__message)
      __attribute__ ((__noreturn__));
-extern void __libc_message (enum __libc_message_action action,
-			    const char *__fnt, ...) attribute_hidden;
+_Noreturn void __libc_message (const char *__fnt, ...) attribute_hidden;
 extern void __fortify_fail (const char *msg) __attribute__ ((__noreturn__));
 libc_hidden_proto (__fortify_fail)
 
diff -aurN glibc-2.36/inet/netinet/in.h glibc-20220830_c7509d49c4/inet/netinet/in.h
--- glibc-2.36/inet/netinet/in.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/inet/netinet/in.h	2022-08-31 07:16:41.000000000 +0200
@@ -278,6 +278,19 @@
     struct in_addr imr_interface;
   };
 
+/* IPv4 multicast request with interface index.  */
+struct ip_mreqn
+  {
+    /* IP multicast address of group.  */
+    struct in_addr imr_multiaddr;
+
+    /* Local IP address of interface.  */
+    struct in_addr imr_address;
+
+    /* Interface index.  */
+    int imr_ifindex;
+  };
+
 struct ip_mreq_source
   {
     /* IP multicast address of group.  */
diff -aurN glibc-2.36/inet/rcmd.c glibc-20220830_c7509d49c4/inet/rcmd.c
--- glibc-2.36/inet/rcmd.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/inet/rcmd.c	2022-08-31 07:16:41.000000000 +0200
@@ -79,6 +79,7 @@
 #include <wchar.h>
 #include <sys/uio.h>
 #include <sigsetops.h>
+#include <shlib-compat.h>
 
 
 int __ivaliduser (FILE *, uint32_t, const char *, const char *);
@@ -621,18 +622,9 @@
   return iruserok_af (&raddr, superuser, ruser, luser, AF_INET);
 }
 
-/*
- * XXX
- * Don't make static, used by lpd(8).
- *
- * This function is not used anymore. It is only present because lpd(8)
- * calls it (!?!). We simply call __invaliduser2() with an illegal rhost
- * argument. This means that netgroups won't work in .rhost/hosts.equiv
- * files. If you want lpd to work with netgroups, fix lpd to use ruserok()
- * or PAM.
- * Returns 0 if ok, -1 if not ok.
- */
-int
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_37)
+/* Previously used by lpd.  Current lpd versions have their own copy.  */
+int attribute_compat_text_section
 __ivaliduser (FILE *hostf, uint32_t raddr, const char *luser,
 	      const char *ruser)
 {
@@ -643,7 +635,8 @@
 	return __validuser2_sa(hostf, (struct sockaddr *)&ra, sizeof(ra),
 			       luser, ruser, "-");
 }
-
+compat_symbol (libc, __ivaliduser, __ivaliduser, GLIBC_2_0);
+#endif
 
 /* Returns 1 on positive match, 0 on no match, -1 on negative match.  */
 static int
diff -aurN glibc-2.36/libio/vtables.c glibc-20220830_c7509d49c4/libio/vtables.c
--- glibc-2.36/libio/vtables.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/libio/vtables.c	2022-08-31 07:16:41.000000000 +0200
@@ -25,10 +25,6 @@
 
 void (*IO_accept_foreign_vtables) (void) attribute_hidden;
 
-/* Used to detected multiple libcs.  */
-extern struct dl_open_hook *_dl_open_hook;
-libc_hidden_proto (_dl_open_hook);
-
 #else  /* !SHARED */
 
 /* Used to check whether static dlopen support is needed.  */
diff -aurN glibc-2.36/localedata/locales/fr_BE glibc-20220830_c7509d49c4/localedata/locales/fr_BE
--- glibc-2.36/localedata/locales/fr_BE	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/localedata/locales/fr_BE	2022-08-31 07:16:41.000000000 +0200
@@ -25,7 +25,7 @@
 LC_IDENTIFICATION
 title      "French locale for Belgium"
 source     "RAP"
-address    "Sankt J<U00F8>rgens Alle 8, DK-1615 K<U00F8>benhavn V, Danmark"
+address    "Sankt Jørgens Alle 8, DK-1615 København V, Danmark"
 contact    ""
 email      "bug-glibc-locales@gnu.org"
 tel        ""
@@ -66,7 +66,7 @@
 
 LC_MONETARY
 int_curr_symbol           "EUR "
-currency_symbol           "<U20AC>"
+currency_symbol           "€"
 mon_decimal_point         ","
 mon_thousands_sep         "."
 mon_grouping              3;3
@@ -97,24 +97,24 @@
 	"jeudi";/
 	"vendredi";/
 	"samedi"
-abmon   "jan";"f<U00E9>v";/
+abmon   "jan";"fév";/
 	"mar";"avr";/
 	"mai";"jun";/
-	"jui";"ao<U00FB>";/
+	"jui";"aoû";/
 	"sep";"oct";/
-	"nov";"d<U00E9>c"
+	"nov";"déc"
 mon     "janvier";/
-	"f<U00E9>vrier";/
+	"février";/
 	"mars";/
 	"avril";/
 	"mai";/
 	"juin";/
 	"juillet";/
-	"ao<U00FB>t";/
+	"août";/
 	"septembre";/
 	"octobre";/
 	"novembre";/
-	"d<U00E9>cembre"
+	"décembre"
 d_t_fmt  "%a %d %b %Y %T"
 date_fmt "%a %d %b %Y %T %Z"
 d_fmt   "%d//%m//%y"
@@ -151,7 +151,7 @@
 country_ab3 "BEL"
 country_num 056
 country_car "B"
-lang_name "fran<U00E7>ais"
+lang_name "français"
 lang_ab      "fr"
 lang_term    "fra"
 lang_lib  "fre"
diff -aurN glibc-2.36/localedata/locales/fr_CA glibc-20220830_c7509d49c4/localedata/locales/fr_CA
--- glibc-2.36/localedata/locales/fr_CA	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/localedata/locales/fr_CA	2022-08-31 07:16:41.000000000 +0200
@@ -25,7 +25,7 @@
 LC_IDENTIFICATION
 title      "French locale for Canada"
 source     "RAP"
-address    "Sankt J<U00F8>rgens Alle 8, DK-1615 K<U00F8>benhavn V, Danmark"
+address    "Sankt Jørgens Alle 8, DK-1615 København V, Danmark"
 contact    ""
 email      "bug-glibc-locales@gnu.org"
 tel        ""
@@ -67,7 +67,7 @@
 int_curr_symbol           "CAD "
 currency_symbol           "$"
 mon_decimal_point         ","
-mon_thousands_sep         "<U202F>"
+mon_thousands_sep         " "
 mon_grouping              3;3
 positive_sign             ""
 negative_sign             "-"
@@ -94,24 +94,24 @@
 	"jeudi";/
 	"vendredi";/
 	"samedi"
-abmon   "jan";"f<U00E9>v";/
+abmon   "jan";"fév";/
 	"mar";"avr";/
 	"mai";"jun";/
-	"jui";"ao<U00FB>";/
+	"jui";"aoû";/
 	"sep";"oct";/
-	"nov";"d<U00E9>c"
+	"nov";"déc"
 mon     "janvier";/
-	"f<U00E9>vrier";/
+	"février";/
 	"mars";/
 	"avril";/
 	"mai";/
 	"juin";/
 	"juillet";/
-	"ao<U00FB>t";/
+	"août";/
 	"septembre";/
 	"octobre";/
 	"novembre";/
-	"d<U00E9>cembre"
+	"décembre"
 d_t_fmt  "%a %d %b %Y %T"
 date_fmt "%a %d %b %Y %T %Z"
 d_fmt   "%Y-%m-%d"
@@ -144,7 +144,7 @@
 country_ab3 "CAN"
 country_num 124
 country_car    "CDN"
-lang_name "fran<U00E7>ais"
+lang_name "français"
 lang_ab      "fr"
 lang_term    "fra"
 lang_lib  "fre"
diff -aurN glibc-2.36/localedata/locales/fr_CH glibc-20220830_c7509d49c4/localedata/locales/fr_CH
--- glibc-2.36/localedata/locales/fr_CH	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/localedata/locales/fr_CH	2022-08-31 07:16:41.000000000 +0200
@@ -25,7 +25,7 @@
 LC_IDENTIFICATION
 title      "French locale for Switzerland"
 source     "RAP"
-address    "Sankt J<U00F8>rgens Alle 8, DK-1615 K<U00F8>benhavn V, Danmark"
+address    "Sankt Jørgens Alle 8, DK-1615 København V, Danmark"
 contact    ""
 email      "bug-glibc-locales@gnu.org"
 tel        ""
@@ -81,24 +81,24 @@
 	"jeudi";/
 	"vendredi";/
 	"samedi"
-abmon   "jan";"f<U00E9>v";/
+abmon   "jan";"fév";/
 	"mar";"avr";/
 	"mai";"jun";/
-	"jui";"ao<U00FB>";/
+	"jui";"aoû";/
 	"sep";"oct";/
-	"nov";"d<U00E9>c"
+	"nov";"déc"
 mon     "janvier";/
-	"f<U00E9>vrier";/
+	"février";/
 	"mars";/
 	"avril";/
 	"mai";/
 	"juin";/
 	"juillet";/
-	"ao<U00FB>t";/
+	"août";/
 	"septembre";/
 	"octobre";/
 	"novembre";/
-	"d<U00E9>cembre"
+	"décembre"
 d_t_fmt  "%a %d %b %Y %T"
 date_fmt "%a %d %b %Y %T %Z"
 d_fmt   "%d. %m. %y"
@@ -134,7 +134,7 @@
 country_ab3 "CHE"
 country_num 756
 country_car "CH"
-lang_name "fran<U00E7>ais"
+lang_name "français"
 lang_ab      "fr"
 lang_term    "fra"
 lang_lib  "fre"
diff -aurN glibc-2.36/localedata/locales/fr_FR glibc-20220830_c7509d49c4/localedata/locales/fr_FR
--- glibc-2.36/localedata/locales/fr_FR	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/localedata/locales/fr_FR	2022-08-31 07:16:41.000000000 +0200
@@ -76,9 +76,9 @@
 
 LC_MONETARY
 int_curr_symbol           "EUR "
-currency_symbol           "<U20AC>"
+currency_symbol           "€"
 mon_decimal_point         ","
-mon_thousands_sep         "<U202F>"
+mon_thousands_sep         " "
 mon_grouping              3
 positive_sign             ""
 negative_sign             "-"
@@ -94,7 +94,7 @@
 
 LC_NUMERIC
 decimal_point             ","
-thousands_sep             "<U202F>"
+thousands_sep             " "
 grouping                  3
 END LC_NUMERIC
 
@@ -108,29 +108,29 @@
         "vendredi";/
         "samedi"
 abmon   "janv.";/
-        "f<U00E9>vr.";/
+        "févr.";/
         "mars";/
         "avril";/
         "mai";/
         "juin";/
         "juil.";/
-        "ao<U00FB>t";/
+        "août";/
         "sept.";/
         "oct.";/
         "nov.";/
-        "d<U00E9>c."
+        "déc."
 mon     "janvier";/
-        "f<U00E9>vrier";/
+        "février";/
         "mars";/
         "avril";/
         "mai";/
         "juin";/
         "juillet";/
-        "ao<U00FB>t";/
+        "août";/
         "septembre";/
         "octobre";/
         "novembre";/
-        "d<U00E9>cembre"
+        "décembre"
 d_t_fmt  "%a %d %b %Y %T"
 date_fmt "%a %d %b %Y %T %Z"
 d_fmt   "%d//%m//%Y"
@@ -169,7 +169,7 @@
 country_num 250
 country_isbn "979-10"
 country_car  "F"
-lang_name "fran<U00E7>ais"
+lang_name "français"
 lang_ab      "fr"
 lang_term    "fra"
 lang_lib  "fre"
diff -aurN glibc-2.36/localedata/locales/fr_LU glibc-20220830_c7509d49c4/localedata/locales/fr_LU
--- glibc-2.36/localedata/locales/fr_LU	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/localedata/locales/fr_LU	2022-08-31 07:16:41.000000000 +0200
@@ -25,7 +25,7 @@
 LC_IDENTIFICATION
 title      "French locale for Luxemburg"
 source     "RAP"
-address    "Sankt J<U00F8>rgens Alle 8, DK-1615 K<U00F8>benhavn V, Danmark"
+address    "Sankt Jørgens Alle 8, DK-1615 København V, Danmark"
 contact    ""
 email      "bug-glibc-locales@gnu.org"
 tel        ""
@@ -66,9 +66,9 @@
 
 LC_MONETARY
 int_curr_symbol           "EUR "
-currency_symbol           "<U20AC>"
+currency_symbol           "€"
 mon_decimal_point         ","
-mon_thousands_sep         "<U202F>"
+mon_thousands_sep         " "
 mon_grouping              3;3
 positive_sign             ""
 negative_sign             "-"
@@ -84,7 +84,7 @@
 
 LC_NUMERIC
 decimal_point             ","
-thousands_sep             "<U202F>"
+thousands_sep             " "
 grouping                  3;3
 END LC_NUMERIC
 
@@ -97,24 +97,24 @@
 	"jeudi";/
 	"vendredi";/
 	"samedi"
-abmon   "jan";"f<U00E9>v";/
+abmon   "jan";"fév";/
 	"mar";"avr";/
 	"mai";"jun";/
-	"jui";"ao<U00FB>";/
+	"jui";"aoû";/
 	"sep";"oct";/
-	"nov";"d<U00E9>c"
+	"nov";"déc"
 mon     "janvier";/
-	"f<U00E9>vrier";/
+	"février";/
 	"mars";/
 	"avril";/
 	"mai";/
 	"juin";/
 	"juillet";/
-	"ao<U00FB>t";/
+	"août";/
 	"septembre";/
 	"octobre";/
 	"novembre";/
-	"d<U00E9>cembre"
+	"décembre"
 d_t_fmt  "%a %d %b %Y %T"
 date_fmt "%a %d %b %Y %T %Z"
 d_fmt   "%d.%m.%Y"
@@ -150,7 +150,7 @@
 country_ab3 "LUX"
 country_num 442
 country_car "L"
-lang_name "fran<U00E7>ais"
+lang_name "français"
 lang_ab      "fr"
 lang_term    "fra"
 lang_lib  "fre"
diff -aurN glibc-2.36/Makeconfig glibc-20220830_c7509d49c4/Makeconfig
--- glibc-2.36/Makeconfig	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/Makeconfig	2022-08-31 07:16:41.000000000 +0200
@@ -866,7 +866,7 @@
 +extra-math-flags = $(if $(filter libm,$(in-module)),-fno-math-errno,-fmath-errno)
 
 # Use 64 bit time_t support for installed programs
-installed-modules = nonlib nscd lddlibc4 ldconfig locale_programs \
+installed-modules = nonlib nscd ldconfig locale_programs \
 		    iconvprogs libnss_files libnss_compat libnss_db libnss_hesiod \
 		    libutil libpcprofile libSegFault
 +extra-time-flags = $(if $(filter $(installed-modules),\
@@ -966,7 +966,7 @@
 libio-include = -I$(..)libio
 
 # List of non-library modules that we build.
-built-modules = iconvprogs iconvdata ldconfig lddlibc4 libmemusage \
+built-modules = iconvprogs iconvdata ldconfig libmemusage \
 		libSegFault libpcprofile librpcsvc locale-programs \
 		memusagestat nonlib nscd extramodules libnldbl libsupport \
 		testsuite testsuite-internal
@@ -1052,7 +1052,7 @@
 PIC-ccflag = -fPIC
 endif
 # This can be changed by a sysdep makefile
-pie-ccflag = -fpie
+pie-ccflag = -fPIE
 no-pie-ccflag = -fno-pie
 # This one should always stay like this unless there is a very good reason.
 PIE-ccflag = -fPIE
diff -aurN glibc-2.36/malloc/arena.c glibc-20220830_c7509d49c4/malloc/arena.c
--- glibc-2.36/malloc/arena.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/malloc/arena.c	2022-08-31 07:16:41.000000000 +0200
@@ -300,11 +300,6 @@
 #endif
 
 
-#ifdef SHARED
-extern struct dl_open_hook *_dl_open_hook;
-libc_hidden_proto (_dl_open_hook);
-#endif
-
 #if USE_TCACHE
 static void tcache_key_initialize (void);
 #endif
@@ -564,16 +559,13 @@
 #if HAVE_TUNABLES
   if (__glibc_unlikely (mp_.hp_pagesize != 0))
     {
-      /* MAP_NORESERVE is not used for huge pages because some kernel may
-	 not reserve the mmap region and a subsequent access may trigger
-	 a SIGBUS if there is no free pages in the pool.  */
       heap_info *h = alloc_new_heap (size, top_pad, mp_.hp_pagesize,
 				     mp_.hp_flags);
       if (h != NULL)
 	return h;
     }
 #endif
-  return alloc_new_heap (size, top_pad, GLRO (dl_pagesize), MAP_NORESERVE);
+  return alloc_new_heap (size, top_pad, GLRO (dl_pagesize), 0);
 }
 
 /* Grow a heap.  size is automatically rounded up to a
diff -aurN glibc-2.36/malloc/malloc.c glibc-20220830_c7509d49c4/malloc/malloc.c
--- glibc-2.36/malloc/malloc.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/malloc/malloc.c	2022-08-31 07:16:41.000000000 +0200
@@ -254,6 +254,7 @@
 /* For tcache double-free check.  */
 #include <random-bits.h>
 #include <sys/random.h>
+#include <not-cancel.h>
 
 /*
   Debugging:
@@ -287,23 +288,6 @@
 #define MALLOC_DEBUG 0
 #endif
 
-#if IS_IN (libc)
-#ifndef NDEBUG
-# define __assert_fail(assertion, file, line, function)			\
-	 __malloc_assert(assertion, file, line, function)
-
-_Noreturn static void
-__malloc_assert (const char *assertion, const char *file, unsigned int line,
-		 const char *function)
-{
-  __libc_message (do_abort, "\
-Fatal glibc error: malloc assertion failure in %s: %s\n",
-		  function, assertion);
-  __builtin_unreachable ();
-}
-#endif
-#endif
-
 #if USE_TCACHE
 /* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */
 # define TCACHE_MAX_BINS		64
@@ -1126,10 +1110,6 @@
 # define MAP_ANONYMOUS MAP_ANON
 #endif
 
-#ifndef MAP_NORESERVE
-# define MAP_NORESERVE 0
-#endif
-
 #define MMAP(addr, size, prot, flags) \
  __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)
 
@@ -3153,7 +3133,7 @@
 static void
 tcache_key_initialize (void)
 {
-  if (__getrandom (&tcache_key, sizeof(tcache_key), GRND_NONBLOCK)
+  if (__getrandom_nocancel (&tcache_key, sizeof(tcache_key), GRND_NONBLOCK)
       != sizeof (tcache_key))
     {
       tcache_key = random_bits ();
@@ -5657,7 +5637,7 @@
 malloc_printerr (const char *str)
 {
 #if IS_IN (libc)
-  __libc_message (do_abort, "%s\n", str);
+  __libc_message ("%s\n", str);
 #else
   __libc_fatal (str);
 #endif
diff -aurN glibc-2.36/manual/tunables.texi glibc-20220830_c7509d49c4/manual/tunables.texi
--- glibc-2.36/manual/tunables.texi	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/manual/tunables.texi	2022-08-31 07:16:41.000000000 +0200
@@ -143,7 +143,7 @@
 necessary hysteresis in heap size such that excessive amounts of system calls
 can be avoided.
 
-The default value of this tunable is @samp{0}.
+The default value of this tunable is @samp{131072} (128 KB).
 @end deftp
 
 @deftp Tunable glibc.malloc.perturb
diff -aurN glibc-2.36/misc/syslog.c glibc-20220830_c7509d49c4/misc/syslog.c
--- glibc-2.36/misc/syslog.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/misc/syslog.c	2022-08-31 07:16:41.000000000 +0200
@@ -193,28 +193,32 @@
       int vl = __vsnprintf_internal (bufs + l, sizeof bufs - l, fmt, apc,
                                      mode_flags);
       if (0 <= vl && vl < sizeof bufs - l)
-        {
-          buf = bufs;
-          bufsize = l + vl;
-        }
+        buf = bufs;
+      bufsize = l + vl;
 
       va_end (apc);
     }
 
   if (buf == NULL)
     {
-      buf = malloc (l * sizeof (char));
+      buf = malloc ((bufsize + 1) * sizeof (char));
       if (buf != NULL)
 	{
 	  /* Tell the cancellation handler to free this buffer.  */
 	  clarg.buf = buf;
 
 	  if (has_ts)
-	    __snprintf (bufs, sizeof bufs,
+	    __snprintf (buf, l + 1,
 			SYSLOG_HEADER (pri, timestamp, &msgoff, pid));
 	  else
-	    __snprintf (bufs, sizeof bufs,
+	    __snprintf (buf, l + 1,
 			SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));
+
+	  va_list apc;
+	  va_copy (apc, ap);
+	  __vsnprintf_internal (buf + l, bufsize - l + 1, fmt, apc,
+				mode_flags);
+	  va_end (apc);
 	}
       else
         {
diff -aurN glibc-2.36/misc/tst-syslog.c glibc-20220830_c7509d49c4/misc/tst-syslog.c
--- glibc-2.36/misc/tst-syslog.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/misc/tst-syslog.c	2022-08-31 07:16:41.000000000 +0200
@@ -68,21 +68,19 @@
     LOG_DEBUG
   };
 
-enum
-  {
-    ident_length = 64,
-    msg_length = 64
-  };
+#define IDENT_LENGTH 64
+#define MSG_LENGTH   1024
 
 #define SYSLOG_MSG_BASE "syslog_message"
 #define OPENLOG_IDENT   "openlog_ident"
+static char large_message[MSG_LENGTH];
 
 struct msg_t
   {
     int priority;
     int facility;
-    char ident[ident_length];
-    char msg[msg_length];
+    char ident[IDENT_LENGTH];
+    char msg[MSG_LENGTH];
     pid_t pid;
   };
 
@@ -148,6 +146,37 @@
 }
 
 static void
+send_syslog_large (int options)
+{
+  int facility = LOG_USER;
+  int priority = LOG_INFO;
+
+  syslog (facility | priority, "%s %d %d", large_message, facility,
+	  priority);
+}
+
+static void
+send_vsyslog_large (int options)
+{
+  int facility = LOG_USER;
+  int priority = LOG_INFO;
+
+  call_vsyslog (facility | priority, "%s %d %d", large_message, facility,
+		priority);
+}
+
+static bool
+check_syslog_message_large (const struct msg_t *msg, int msgnum, int options,
+			    pid_t pid)
+{
+  TEST_COMPARE (msg->facility, LOG_USER);
+  TEST_COMPARE (msg->priority, LOG_INFO);
+  TEST_COMPARE_STRING (msg->msg, large_message);
+
+  return false;
+}
+
+static void
 send_openlog (int options)
 {
   /* Define a non-default IDENT and a not default facility.  */
@@ -179,6 +208,17 @@
   closelog ();
 }
 
+static void
+send_openlog_large (int options)
+{
+  /* Define a non-default IDENT and a not default facility.  */
+  openlog (OPENLOG_IDENT, options, LOG_LOCAL0);
+
+  syslog (LOG_INFO, "%s %d %d", large_message, LOG_LOCAL0, LOG_INFO);
+
+  closelog ();
+}
+
 static bool
 check_openlog_message (const struct msg_t *msg, int msgnum,
                        int options, pid_t pid)
@@ -189,7 +229,7 @@
   int expected_priority = priorities[msgnum % array_length (priorities)];
   TEST_COMPARE (msg->priority, expected_priority);
 
-  char expected_ident[ident_length];
+  char expected_ident[IDENT_LENGTH];
   snprintf (expected_ident, sizeof (expected_ident), "%s%s%.0d%s:",
             OPENLOG_IDENT,
             options & LOG_PID ? "[" : "",
@@ -211,15 +251,38 @@
   return true;
 }
 
+static bool
+check_openlog_message_large (const struct msg_t *msg, int msgnum,
+			     int options, pid_t pid)
+{
+  char expected_ident[IDENT_LENGTH];
+  snprintf (expected_ident, sizeof (expected_ident), "%s%s%.0d%s:",
+            OPENLOG_IDENT,
+            options & LOG_PID ? "[" : "",
+            options & LOG_PID ? pid : 0,
+            options & LOG_PID ? "]" : "");
+
+  TEST_COMPARE_STRING (msg->ident, expected_ident);
+  TEST_COMPARE_STRING (msg->msg, large_message);
+  TEST_COMPARE (msg->priority, LOG_INFO);
+  TEST_COMPARE (msg->facility, LOG_LOCAL0);
+
+  return false;
+}
+
 static struct msg_t
 parse_syslog_msg (const char *msg)
 {
   struct msg_t r = { .pid = -1 };
   int number;
 
+#define STRINPUT(size)  XSTRINPUT(size)
+#define XSTRINPUT(size) "%" # size "s"
+
   /* The message in the form:
-     <179>Apr  8 14:51:19 tst-syslog: syslog message 176 3  */
-  int n = sscanf (msg, "<%3d>%*s %*d %*d:%*d:%*d %32s %64s %*d %*d",
+     <179>Apr  8 14:51:19  tst-syslog: message 176 3  */
+  int n = sscanf (msg, "<%3d>%*s %*d %*d:%*d:%*d " STRINPUT(IDENT_LENGTH)
+		       " " STRINPUT(MSG_LENGTH) " %*d %*d",
                   &number, r.ident, r.msg);
   TEST_COMPARE (n, 3);
 
@@ -246,7 +309,7 @@
 
   /* The message in the form:
      openlog_ident: syslog_message 128 0  */
-  int n = sscanf (msg, "%32s %64s %d %d",
+  int n = sscanf (msg, STRINPUT(IDENT_LENGTH) " " STRINPUT(MSG_LENGTH) " %d %d",
       r.ident, r.msg, &facility, &priority);
   TEST_COMPARE (n, 4);
 
@@ -281,7 +344,7 @@
   int msgnum = 0;
   while (1)
     {
-      char buf[512];
+      char buf[2048];
       size_t l = xrecvfrom (server_udp, buf, sizeof (buf), 0,
                             (struct sockaddr *) &addr, &addrlen);
       buf[l] = '\0';
@@ -325,7 +388,7 @@
 
   int client_tcp = xaccept (server_tcp, NULL, NULL);
 
-  char buf[512], *rb = buf;
+  char buf[2048], *rb = buf;
   size_t rbl = sizeof (buf);
   size_t prl = 0;  /* Track the size of the partial record.  */
   int msgnum = 0;
@@ -393,20 +456,34 @@
 }
 
 static void
-check_syslog_console (void)
+check_syslog_console_read_large (FILE *fp)
+{
+  char buf[2048];
+  TEST_VERIFY (fgets (buf, sizeof (buf), fp) != NULL);
+  struct msg_t msg = parse_syslog_console (buf);
+
+  TEST_COMPARE_STRING (msg.ident, OPENLOG_IDENT ":");
+  TEST_COMPARE_STRING (msg.msg, large_message);
+  TEST_COMPARE (msg.priority, LOG_INFO);
+  TEST_COMPARE (msg.facility, LOG_LOCAL0);
+}
+
+static void
+check_syslog_console (void (*syslog_send)(int),
+		      void (*syslog_check)(FILE *fp))
 {
   xmkfifo (_PATH_CONSOLE, 0666);
 
   pid_t sender_pid = xfork ();
   if (sender_pid == 0)
     {
-      send_openlog (LOG_CONS);
+      syslog_send (LOG_CONS);
       _exit (0);
     }
 
   {
     FILE *fp = xfopen (_PATH_CONSOLE, "r+");
-    check_syslog_console_read (fp);
+    syslog_check (fp);
     xfclose (fp);
   }
 
@@ -425,16 +502,28 @@
 }
 
 static void
-check_syslog_perror (void)
+send_openlog_callback_large (void *clousure)
+{
+  int options = *(int *) clousure;
+  send_openlog_large (options);
+}
+
+static void
+check_syslog_perror (bool large)
 {
   struct support_capture_subprocess result;
-  result = support_capture_subprocess (send_openlog_callback,
+  result = support_capture_subprocess (large
+				       ? send_openlog_callback_large
+				       : send_openlog_callback,
                                        &(int){LOG_PERROR});
 
   FILE *mfp = fmemopen (result.err.buffer, result.err.length, "r");
   if (mfp == NULL)
     FAIL_EXIT1 ("fmemopen: %m");
-  check_syslog_console_read (mfp);
+  if (large)
+    check_syslog_console_read_large (mfp);
+  else
+    check_syslog_console_read (mfp);
   xfclose (mfp);
 
   support_capture_subprocess_check (&result, "tst-openlog-child", 0,
@@ -462,10 +551,31 @@
   check_syslog_tcp (send_openlog, LOG_PID, check_openlog_message);
 
   /* Check the LOG_CONS option.  */
-  check_syslog_console ();
+  check_syslog_console (send_openlog, check_syslog_console_read);
 
   /* Check the LOG_PERROR option.  */
-  check_syslog_perror ();
+  check_syslog_perror (false);
+
+  /* Similar tests as before, but with a large message to trigger the
+     syslog path that uses dynamically allocated memory.  */
+  memset (large_message, 'a', sizeof large_message - 1);
+  large_message[sizeof large_message - 1] = '\0';
+
+  check_syslog_udp (send_syslog_large, 0, check_syslog_message_large);
+  check_syslog_tcp (send_syslog_large, 0, check_syslog_message_large);
+
+  check_syslog_udp (send_vsyslog_large, 0, check_syslog_message_large);
+  check_syslog_tcp (send_vsyslog_large, 0, check_syslog_message_large);
+
+  check_syslog_udp (send_openlog_large, 0, check_openlog_message_large);
+  check_syslog_tcp (send_openlog_large, 0, check_openlog_message_large);
+
+  check_syslog_udp (send_openlog_large, LOG_PID, check_openlog_message_large);
+  check_syslog_tcp (send_openlog_large, LOG_PID, check_openlog_message_large);
+
+  check_syslog_console (send_openlog_large, check_syslog_console_read_large);
+
+  check_syslog_perror (true);
 
   return 0;
 }
diff -aurN glibc-2.36/NEWS glibc-20220830_c7509d49c4/NEWS
--- glibc-2.36/NEWS	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/NEWS	2022-08-31 07:16:41.000000000 +0200
@@ -5,6 +5,29 @@
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
 
+Version 2.37
+
+Major new features:
+
+  [Add new features here]
+
+Deprecated and removed features, and other changes affecting compatibility:
+
+  [Add deprecations, removals and changes affecting compatibility here]
+
+Changes to build and runtime requirements:
+
+  [Add changes to build and runtime requirements here]
+
+Security related changes:
+
+  [Add security related changes here]
+
+The following bugs are resolved with this release:
+
+  [The release manager will add the list generated by
+  scripts/list-fixed-bugs.py just before the release.]
+
 Version 2.36
 
 Major new features:
diff -aurN glibc-2.36/nscd/connections.c glibc-20220830_c7509d49c4/nscd/connections.c
--- glibc-2.36/nscd/connections.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/nscd/connections.c	2022-08-31 07:16:41.000000000 +0200
@@ -2284,7 +2284,8 @@
 					     sizeof (buf))) != -1)
 	      ;
 
-	    __bump_nl_timestamp ();
+	    dbs[hstdb].head->extra_data[NSCD_HST_IDX_CONF_TIMESTAMP]
+	      = __bump_nl_timestamp ();
 	  }
 # endif
 	else
diff -aurN glibc-2.36/posix/getopt.c glibc-20220830_c7509d49c4/posix/getopt.c
--- glibc-2.36/posix/getopt.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/posix/getopt.c	2022-08-31 07:16:41.000000000 +0200
@@ -45,7 +45,8 @@
 # define _(msgid) gettext (msgid)
 /* When used standalone, flockfile and funlockfile might not be
    available.  */
-# ifndef _POSIX_THREAD_SAFE_FUNCTIONS
+# if (!defined _POSIX_THREAD_SAFE_FUNCTIONS \
+      || (defined _WIN32 && ! defined __CYGWIN__))
 #  define flockfile(fp) /* nop */
 #  define funlockfile(fp) /* nop */
 # endif
@@ -377,8 +378,8 @@
 /* Initialize internal data upon the first call to getopt.  */
 
 static const char *
-_getopt_initialize (int argc _GL_UNUSED,
-		    char **argv _GL_UNUSED, const char *optstring,
+_getopt_initialize (_GL_UNUSED int argc,
+		    _GL_UNUSED char **argv, const char *optstring,
 		    struct _getopt_data *d, int posixly_correct)
 {
   /* Start processing options with ARGV-element 1 (since ARGV-element 0
diff -aurN glibc-2.36/resolv/Makefile glibc-20220830_c7509d49c4/resolv/Makefile
--- glibc-2.36/resolv/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -40,12 +40,16 @@
   inet_pton \
   ns_makecanon \
   ns_name_compress \
+  ns_name_length_uncompressed \
   ns_name_ntop \
   ns_name_pack \
   ns_name_pton \
   ns_name_skip \
   ns_name_uncompress \
   ns_name_unpack \
+  ns_rr_cursor_init \
+  ns_rr_cursor_next \
+  ns_samebinaryname \
   ns_samename \
   nsap_addr \
   nss_dns_functions \
@@ -89,9 +93,12 @@
   tst-ns_name_pton \
   tst-res_hconf_reorder \
   tst-res_hnok \
+  tst-resolv-aliases \
   tst-resolv-basic \
   tst-resolv-binary \
+  tst-resolv-byaddr \
   tst-resolv-edns \
+  tst-resolv-invalid-cname \
   tst-resolv-network \
   tst-resolv-noaaaa \
   tst-resolv-nondecimal \
@@ -104,6 +111,18 @@
 tests-internal += tst-resolv-txnid-collision
 tests-static += tst-resolv-txnid-collision
 
+# Likewise for __ns_samebinaryname.
+tests-internal += tst-ns_samebinaryname
+tests-static += tst-ns_samebinaryname
+
+# Likewise for __ns_name_length_uncompressed.
+tests-internal += tst-ns_name_length_uncompressed
+tests-static += tst-ns_name_length_uncompressed
+
+# Likewise for struct ns_rr_cursor and its functions.
+tests-internal += tst-ns_rr_cursor
+tests-static += tst-ns_rr_cursor
+
 # These tests need libdl.
 ifeq (yes,$(build-shared))
 tests += \
@@ -258,8 +277,10 @@
 $(objpfx)tst-resolv-ai_idn-latin1.out: $(gen-locales)
 $(objpfx)tst-resolv-ai_idn-nolibidn2.out: \
   $(gen-locales) $(objpfx)tst-no-libidn2.so
+$(objpfx)tst-resolv-aliases: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-basic: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-binary: $(objpfx)libresolv.so $(shared-thread-library)
+$(objpfx)tst-resolv-byaddr: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-edns: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-network: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-res_init: $(objpfx)libresolv.so
@@ -267,6 +288,8 @@
   $(shared-thread-library)
 $(objpfx)tst-resolv-res_init-thread: $(objpfx)libresolv.so \
   $(shared-thread-library)
+$(objpfx)tst-resolv-invalid-cname: $(objpfx)libresolv.so \
+  $(shared-thread-library)
 $(objpfx)tst-resolv-noaaaa: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-nondecimal: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-qtypes: $(objpfx)libresolv.so $(shared-thread-library)
diff -aurN glibc-2.36/resolv/mapv4v6addr.h glibc-20220830_c7509d49c4/resolv/mapv4v6addr.h
--- glibc-2.36/resolv/mapv4v6addr.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/mapv4v6addr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * ++Copyright++ 1985, 1988, 1993
- * -
- * Copyright (c) 1985, 1988, 1993
- *    The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * -
- * Portions Copyright (c) 1993 by Digital Equipment Corporation.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies, and that
- * the name of Digital Equipment Corporation not be used in advertising or
- * publicity pertaining to distribution of the document or software without
- * specific, written prior permission.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
- * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- * -
- * --Copyright--
- */
-
-#include <string.h>
-#include <arpa/nameser.h>
-
-static void
-map_v4v6_address (const char *src, char *dst)
-{
-  u_char *p = (u_char *) dst;
-  int i;
-
-  /* Move the IPv4 part to the right position.  */
-  memcpy (dst + 12, src, INADDRSZ);
-
-  /* Mark this ipv6 addr as a mapped ipv4. */
-  for (i = 0; i < 10; i++)
-    *p++ = 0x00;
-  *p++ = 0xff;
-  *p = 0xff;
-}
diff -aurN glibc-2.36/resolv/mapv4v6hostent.h glibc-20220830_c7509d49c4/resolv/mapv4v6hostent.h
--- glibc-2.36/resolv/mapv4v6hostent.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/mapv4v6hostent.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-/*
- * ++Copyright++ 1985, 1988, 1993
- * -
- * Copyright (c) 1985, 1988, 1993
- *    The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * -
- * Portions Copyright (c) 1993 by Digital Equipment Corporation.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies, and that
- * the name of Digital Equipment Corporation not be used in advertising or
- * publicity pertaining to distribution of the document or software without
- * specific, written prior permission.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
- * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
- * SOFTWARE.
- * -
- * --Copyright--
- */
-
-#include <arpa/nameser.h>
-#include <sys/socket.h>
-
-typedef union {
-    int32_t al;
-    char ac;
-} align;
-
-static int
-map_v4v6_hostent (struct hostent *hp, char **bpp, int *lenp)
-{
-  char **ap;
-
-  if (hp->h_addrtype != AF_INET || hp->h_length != INADDRSZ)
-    return 0;
-  hp->h_addrtype = AF_INET6;
-  hp->h_length = IN6ADDRSZ;
-  for (ap = hp->h_addr_list; *ap; ap++)
-    {
-      int i = sizeof (align) - ((u_long) *bpp % sizeof (align));
-
-      if (*lenp < (i + IN6ADDRSZ))
-	/* Out of memory.  */
-	return 1;
-      *bpp += i;
-      *lenp -= i;
-      map_v4v6_address (*ap, *bpp);
-      *ap = *bpp;
-      *bpp += IN6ADDRSZ;
-      *lenp -= IN6ADDRSZ;
-    }
-  return 0;
-}
diff -aurN glibc-2.36/resolv/ns_name_length_uncompressed.c glibc-20220830_c7509d49c4/resolv/ns_name_length_uncompressed.c
--- glibc-2.36/resolv/ns_name_length_uncompressed.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/ns_name_length_uncompressed.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,72 @@
+/* Skip over an uncompressed name in wire format.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <errno.h>
+#include <stdbool.h>
+
+int
+__ns_name_length_uncompressed (const unsigned char *p,
+                                const unsigned char *eom)
+{
+  const unsigned char *start = p;
+
+  while (true)
+    {
+      if (p == eom)
+        {
+          /* Truncated packet: no room for label length.  */
+          __set_errno (EMSGSIZE);
+          return -1;
+        }
+
+      unsigned char b = *p;
+      ++p;
+      if (b == 0)
+        {
+          /* Root label.  */
+          size_t length = p - start;
+          if (length > NS_MAXCDNAME)
+            {
+              /* Domain name too long.  */
+              __set_errno (EMSGSIZE);
+              return -1;
+            }
+          return length;
+        }
+
+      if (b <= 63)
+        {
+          /* Regular label.  */
+          if (b <= eom - p)
+            p += b;
+          else
+            {
+              /* Truncated packet: label incomplete.  */
+              __set_errno (EMSGSIZE);
+              return -1;
+            }
+        }
+      else
+        {
+          /* Compression reference or corrupted label length.  */
+          __set_errno (EMSGSIZE);
+          return -1;
+        }
+    }
+}
diff -aurN glibc-2.36/resolv/ns_rr_cursor_init.c glibc-20220830_c7509d49c4/resolv/ns_rr_cursor_init.c
--- glibc-2.36/resolv/ns_rr_cursor_init.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/ns_rr_cursor_init.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,62 @@
+/* Initialize a simple DNS packet parser.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <string.h>
+
+bool
+__ns_rr_cursor_init (struct ns_rr_cursor *c,
+                     const unsigned char *buf, size_t len)
+{
+  c->begin = buf;
+  c->end = buf + len;
+
+  /* Check for header size and 16-bit question count value (it must be 1).  */
+  if (len < 12 || buf[4] != 0 || buf[5] != 1)
+    {
+      __set_errno (EMSGSIZE);
+      c->current = c->end;
+      return false;
+    }
+  c->current = buf + 12;
+
+  int consumed = __ns_name_length_uncompressed (c->current, c->end);
+  if (consumed < 0)
+    {
+      __set_errno (EMSGSIZE);
+      c->current = c->end;
+      c->first_rr = NULL;
+      return false;
+    }
+  c->current += consumed;
+
+  /* Ensure there is room for question type and class.  */
+  if (c->end - c->current < 4)
+    {
+      __set_errno (EMSGSIZE);
+      c->current = c->end;
+      c->first_rr = NULL;
+      return false;
+    }
+  c->current += 4;
+  c->first_rr = c->current;
+
+  return true;
+}
diff -aurN glibc-2.36/resolv/ns_rr_cursor_next.c glibc-20220830_c7509d49c4/resolv/ns_rr_cursor_next.c
--- glibc-2.36/resolv/ns_rr_cursor_next.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/ns_rr_cursor_next.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,74 @@
+/* Simple DNS record parser without textual name decoding.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <string.h>
+
+bool
+__ns_rr_cursor_next (struct ns_rr_cursor *c, struct ns_rr_wire *rr)
+{
+  rr->rdata = NULL;
+
+  /* Extract the record owner name.  */
+  int consumed = __ns_name_unpack (c->begin, c->end, c->current,
+                                   rr->rname, sizeof (rr->rname));
+  if (consumed < 0)
+    {
+      memset (rr, 0, sizeof (*rr));
+      __set_errno (EMSGSIZE);
+      return false;
+    }
+  c->current += consumed;
+
+  /* Extract the metadata.  */
+  struct
+  {
+    uint16_t rtype;
+    uint16_t rclass;
+    uint32_t ttl;
+    uint16_t rdlength;
+  } __attribute__ ((packed)) metadata;
+  _Static_assert (sizeof (metadata) == 10, "sizeof metadata");
+  if (c->end - c->current < sizeof (metadata))
+    {
+      memset (rr, 0, sizeof (*rr));
+      __set_errno (EMSGSIZE);
+      return false;
+    }
+  memcpy (&metadata, c->current, sizeof (metadata));
+  c->current += sizeof (metadata);
+  /* Endianess conversion.  */
+  rr->rtype = ntohs (metadata.rtype);
+  rr->rclass = ntohs (metadata.rclass);
+  rr->ttl = ntohl (metadata.ttl);
+  rr->rdlength = ntohs (metadata.rdlength);
+
+  /* Extract record data.  */
+  if (c->end - c->current < rr->rdlength)
+    {
+      memset (rr, 0, sizeof (*rr));
+      __set_errno (EMSGSIZE);
+      return false;
+    }
+  rr->rdata = c->current;
+  c->current += rr->rdlength;
+
+  return true;
+}
diff -aurN glibc-2.36/resolv/ns_samebinaryname.c glibc-20220830_c7509d49c4/resolv/ns_samebinaryname.c
--- glibc-2.36/resolv/ns_samebinaryname.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/ns_samebinaryname.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,55 @@
+/* Compare two binary domain names for quality.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <stdbool.h>
+
+/* Convert ASCII letters to upper case.  */
+static inline int
+ascii_toupper (unsigned char ch)
+{
+  if (ch >= 'a' && ch <= 'z')
+    return ch - 'a' + 'A';
+  else
+    return ch;
+}
+
+bool
+__ns_samebinaryname (const unsigned char *a, const unsigned char *b)
+{
+  while (*a != 0 && *b != 0)
+    {
+      if (*a != *b)
+        /* Different label length.  */
+        return false;
+      int labellen = *a;
+      ++a;
+      ++b;
+      for (int i = 0; i < labellen; ++i)
+        {
+          if (*a != *b && ascii_toupper (*a) != ascii_toupper (*b))
+            /* Different character in label.  */
+            return false;
+          ++a;
+          ++b;
+        }
+    }
+
+  /* Match if both names are at the root label.  */
+  return *a == 0 && *b == 0;
+}
diff -aurN glibc-2.36/resolv/nss_dns/dns-host.c glibc-20220830_c7509d49c4/resolv/nss_dns/dns-host.c
--- glibc-2.36/resolv/nss_dns/dns-host.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/nss_dns/dns-host.c	2022-08-31 07:16:42.000000000 +0200
@@ -69,6 +69,7 @@
  * --Copyright--
  */
 
+#include <alloc_buffer.h>
 #include <assert.h>
 #include <ctype.h>
 #include <errno.h>
@@ -86,10 +87,6 @@
 #include <resolv/resolv-internal.h>
 #include <resolv/resolv_context.h>
 
-/* Get implementations of some internal functions.  */
-#include <resolv/mapv4v6addr.h>
-#include <resolv/mapv4v6hostent.h>
-
 #define RESOLVSORT
 
 #if PACKETSZ > 65536
@@ -103,32 +100,36 @@
 #endif
 #define MAXHOSTNAMELEN 256
 
-/* We need this time later.  */
-typedef union querybuf
-{
-  HEADER hdr;
-  u_char buf[MAXPACKET];
-} querybuf;
-
-static enum nss_status getanswer_r (struct resolv_context *ctx,
-				    const querybuf *answer, int anslen,
-				    const char *qname, int qtype,
-				    struct hostent *result, char *buffer,
-				    size_t buflen, int *errnop, int *h_errnop,
-				    int map, int32_t *ttlp, char **canonp);
-
-static enum nss_status gaih_getanswer (const querybuf *answer1, int anslen1,
-				       const querybuf *answer2, int anslen2,
-				       const char *qname,
+/* For historic reasons, pointers to IP addresses are char *, so use a
+   single list type for addresses and host names.  */
+#define DYNARRAY_STRUCT ptrlist
+#define DYNARRAY_ELEMENT char *
+#define DYNARRAY_PREFIX ptrlist_
+#include <malloc/dynarray-skeleton.c>
+
+static enum nss_status getanswer_r (unsigned char *packet, size_t packetlen,
+				    uint16_t qtype, struct alloc_buffer *abuf,
+				    struct ptrlist *addresses,
+				    struct ptrlist *aliases,
+				    int *errnop, int *h_errnop, int32_t *ttlp);
+static void addrsort (struct resolv_context *ctx, char **ap, int num);
+static enum nss_status getanswer_ptr (unsigned char *packet, size_t packetlen,
+				      struct alloc_buffer *abuf,
+				      char **hnamep, int *errnop,
+				      int *h_errnop, int32_t *ttlp);
+
+static enum nss_status gaih_getanswer (unsigned char *packet1,
+				       size_t packet1len,
+				       unsigned char *packet2,
+				       size_t packet2len,
+				       struct alloc_buffer *abuf,
 				       struct gaih_addrtuple **pat,
-				       char *buffer, size_t buflen,
 				       int *errnop, int *h_errnop,
 				       int32_t *ttlp);
-static enum nss_status gaih_getanswer_noaaaa (const querybuf *answer1,
-					      int anslen1,
-					      const char *qname,
+static enum nss_status gaih_getanswer_noaaaa (unsigned char *packet,
+					      size_t packetlen,
+					      struct alloc_buffer *abuf,
 					      struct gaih_addrtuple **pat,
-					      char *buffer, size_t buflen,
 					      int *errnop, int *h_errnop,
 					      int32_t *ttlp);
 
@@ -183,16 +184,9 @@
 			char *buffer, size_t buflen, int *errnop,
 			int *h_errnop, int32_t *ttlp, char **canonp)
 {
-  union
-  {
-    querybuf *buf;
-    u_char *ptr;
-  } host_buffer;
-  querybuf *orig_host_buffer;
   char tmp[NS_MAXDNAME];
   int size, type, n;
   const char *cp;
-  int map = 0;
   int olderr = errno;
   enum nss_status status;
 
@@ -223,10 +217,12 @@
       && (cp = __res_context_hostalias (ctx, name, tmp, sizeof (tmp))) != NULL)
     name = cp;
 
-  host_buffer.buf = orig_host_buffer = (querybuf *) alloca (1024);
+  unsigned char dns_packet_buffer[1024];
+  unsigned char *alt_dns_packet_buffer = dns_packet_buffer;
 
-  n = __res_context_search (ctx, name, C_IN, type, host_buffer.buf->buf,
-			    1024, &host_buffer.ptr, NULL, NULL, NULL, NULL);
+  n = __res_context_search (ctx, name, C_IN, type,
+			    dns_packet_buffer, sizeof (dns_packet_buffer),
+			    &alt_dns_packet_buffer, NULL, NULL, NULL, NULL);
   if (n < 0)
     {
       switch (errno)
@@ -253,34 +249,79 @@
 	*errnop = EAGAIN;
       else
 	__set_errno (olderr);
+    }
+  else
+    {
+      struct alloc_buffer abuf = alloc_buffer_create (buffer, buflen);
 
-      /* If we are looking for an IPv6 address and mapping is enabled
-	 by having the RES_USE_INET6 bit in _res.options set, we try
-	 another lookup.  */
-      if (af == AF_INET6 && res_use_inet6 ())
-	n = __res_context_search (ctx, name, C_IN, T_A, host_buffer.buf->buf,
-				  host_buffer.buf != orig_host_buffer
-				  ? MAXPACKET : 1024, &host_buffer.ptr,
-				  NULL, NULL, NULL, NULL);
-
-      if (n < 0)
+      struct ptrlist addresses;
+      ptrlist_init (&addresses);
+      struct ptrlist aliases;
+      ptrlist_init (&aliases);
+
+      status = getanswer_r (alt_dns_packet_buffer, n, type,
+			    &abuf, &addresses, &aliases,
+			    errnop, h_errnop, ttlp);
+      if (status == NSS_STATUS_SUCCESS)
 	{
-	  if (host_buffer.buf != orig_host_buffer)
-	    free (host_buffer.buf);
-	  return status;
-	}
+	  if (ptrlist_has_failed (&addresses)
+	      || ptrlist_has_failed (&aliases))
+	    {
+	      /* malloc failure.  Do not retry using the ERANGE protocol.  */
+	      *errnop = ENOMEM;
+	      *h_errnop = NETDB_INTERNAL;
+	      status = NSS_STATUS_UNAVAIL;
+	    }
 
-      map = 1;
+	  /* Reserve the address and alias arrays in the result
+	     buffer.  Both are NULL-terminated, but the first element
+	     of the alias array is stored in h_name, so no extra space
+	     for the NULL terminator is needed there.  */
+	  result->h_addr_list
+	    = alloc_buffer_alloc_array (&abuf, char *,
+					ptrlist_size (&addresses) + 1);
+	  result->h_aliases
+	    = alloc_buffer_alloc_array (&abuf, char *,
+					ptrlist_size (&aliases));
+	  if (alloc_buffer_has_failed (&abuf))
+	    {
+	      /* Retry using the ERANGE protocol.  */
+	      *errnop = ERANGE;
+	      *h_errnop = NETDB_INTERNAL;
+	      status = NSS_STATUS_TRYAGAIN;
+	    }
+	  else
+	    {
+	      /* Copy the address list and NULL-terminate it.  */
+	      memcpy (result->h_addr_list, ptrlist_begin (&addresses),
+		      ptrlist_size (&addresses) * sizeof (char *));
+	      result->h_addr_list[ptrlist_size (&addresses)] = NULL;
+
+	      /* Sort the address list if requested.  */
+	      if (type == T_A && __resolv_context_sort_count (ctx) > 0)
+		addrsort (ctx, result->h_addr_list, ptrlist_size (&addresses));
+
+	      /* Copy the aliases,  excluding the last one. */
+	      memcpy (result->h_aliases, ptrlist_begin (&aliases),
+		      (ptrlist_size (&aliases) - 1) * sizeof (char *));
+	      result->h_aliases[ptrlist_size (&aliases) - 1] = NULL;
+
+	      /* The last alias goes into h_name.  */
+	      assert (ptrlist_size (&aliases) >= 1);
+	      result->h_name = ptrlist_end (&aliases)[-1];
+
+	      /* This is also the canonical name.  */
+	      if (canonp != NULL)
+		*canonp = result->h_name;
+	    }
+	}
 
-      result->h_addrtype = AF_INET;
-      result->h_length = INADDRSZ;
+      ptrlist_free (&aliases);
+      ptrlist_free (&addresses);
     }
 
-  status = getanswer_r
-    (ctx, host_buffer.buf, n, name, type, result, buffer, buflen,
-     errnop, h_errnop, map, ttlp, canonp);
-  if (host_buffer.buf != orig_host_buffer)
-    free (host_buffer.buf);
+  if (alt_dns_packet_buffer != dns_packet_buffer)
+    free (alt_dns_packet_buffer);
   return status;
 }
 
@@ -324,13 +365,8 @@
       *h_errnop = NETDB_INTERNAL;
       return NSS_STATUS_UNAVAIL;
     }
-  status = NSS_STATUS_NOTFOUND;
-  if (res_use_inet6 ())
-    status = gethostbyname3_context (ctx, name, AF_INET6, result, buffer,
-				     buflen, errnop, h_errnop, NULL, NULL);
-  if (status == NSS_STATUS_NOTFOUND)
-    status = gethostbyname3_context (ctx, name, AF_INET, result, buffer,
-				     buflen, errnop, h_errnop, NULL, NULL);
+  status = gethostbyname3_context (ctx, name, AF_INET, result, buffer,
+				   buflen, errnop, h_errnop, NULL, NULL);
   __resolv_context_put (ctx);
   return status;
 }
@@ -365,17 +401,13 @@
 	name = cp;
     }
 
-  union
-  {
-    querybuf *buf;
-    u_char *ptr;
-  } host_buffer;
-  querybuf *orig_host_buffer;
-  host_buffer.buf = orig_host_buffer = (querybuf *) alloca (2048);
+  unsigned char dns_packet_buffer[2048];
+  unsigned char *alt_dns_packet_buffer = dns_packet_buffer;
   u_char *ans2p = NULL;
   int nans2p = 0;
   int resplen2 = 0;
   int ans2p_malloced = 0;
+  struct alloc_buffer abuf = alloc_buffer_create (buffer, buflen);
 
 
   int olderr = errno;
@@ -384,22 +416,21 @@
   if ((ctx->resp->options & RES_NOAAAA) == 0)
     {
       n = __res_context_search (ctx, name, C_IN, T_QUERY_A_AND_AAAA,
-				host_buffer.buf->buf, 2048, &host_buffer.ptr,
-				&ans2p, &nans2p, &resplen2, &ans2p_malloced);
+				dns_packet_buffer, sizeof (dns_packet_buffer),
+				&alt_dns_packet_buffer, &ans2p, &nans2p,
+				&resplen2, &ans2p_malloced);
       if (n >= 0)
-	status = gaih_getanswer (host_buffer.buf, n, (const querybuf *) ans2p,
-				 resplen2, name, pat, buffer, buflen,
-				 errnop, herrnop, ttlp);
+	status = gaih_getanswer (alt_dns_packet_buffer, n, ans2p, resplen2,
+				 &abuf, pat, errnop, herrnop, ttlp);
     }
   else
     {
       n = __res_context_search (ctx, name, C_IN, T_A,
-				host_buffer.buf->buf, 2048, NULL,
-				NULL, NULL, NULL, NULL);
+				dns_packet_buffer, sizeof (dns_packet_buffer),
+				NULL, NULL, NULL, NULL, NULL);
       if (n >= 0)
-	status = gaih_getanswer_noaaaa (host_buffer.buf, n,
-					name, pat, buffer, buflen,
-					errnop, herrnop, ttlp);
+	status = gaih_getanswer_noaaaa (alt_dns_packet_buffer, n,
+					&abuf, pat, errnop, herrnop, ttlp);
     }
   if (n < 0)
     {
@@ -430,12 +461,20 @@
 	__set_errno (olderr);
     }
 
+  /* Implement the buffer resizing protocol.  */
+  if (alloc_buffer_has_failed (&abuf))
+    {
+      *errnop = ERANGE;
+      *herrnop = NETDB_INTERNAL;
+      status = NSS_STATUS_TRYAGAIN;
+    }
+
   /* Check whether ans2p was separately allocated.  */
   if (ans2p_malloced)
     free (ans2p);
 
-  if (host_buffer.buf != orig_host_buffer)
-    free (host_buffer.buf);
+  if (alt_dns_packet_buffer != dns_packet_buffer)
+    free (alt_dns_packet_buffer);
 
   __resolv_context_put (ctx);
   return status;
@@ -451,36 +490,21 @@
   static const u_char tunnelled[] = { 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 };
   static const u_char v6local[] = { 0,0, 0,1 };
   const u_char *uaddr = (const u_char *)addr;
-  struct host_data
-  {
-    char *aliases[MAX_NR_ALIASES];
-    unsigned char host_addr[16];	/* IPv4 or IPv6 */
-    char *h_addr_ptrs[MAX_NR_ADDRS + 1];
-    char linebuffer[0];
-  } *host_data = (struct host_data *) buffer;
-  union
-  {
-    querybuf *buf;
-    u_char *ptr;
-  } host_buffer;
-  querybuf *orig_host_buffer;
   char qbuf[MAXDNAME+1], *qp = NULL;
   size_t size;
   int n, status;
   int olderr = errno;
 
- uintptr_t pad = -(uintptr_t) buffer % __alignof__ (struct host_data);
- buffer += pad;
- buflen = buflen > pad ? buflen - pad : 0;
-
- if (__glibc_unlikely (buflen < sizeof (struct host_data)))
-   {
-     *errnop = ERANGE;
-     *h_errnop = NETDB_INTERNAL;
-     return NSS_STATUS_TRYAGAIN;
-   }
-
- host_data = (struct host_data *) buffer;
+  /* Prepare the allocation buffer.  Store the pointer array first, to
+     benefit from buffer alignment.  */
+  struct alloc_buffer abuf = alloc_buffer_create (buffer, buflen);
+  char **address_array = alloc_buffer_alloc_array (&abuf, char *, 2);
+  if (address_array == NULL)
+    {
+      *errnop = ERANGE;
+      *h_errnop = NETDB_INTERNAL;
+      return NSS_STATUS_TRYAGAIN;
+    }
 
   struct resolv_context *ctx = __resolv_context_get ();
   if (ctx == NULL)
@@ -524,8 +548,6 @@
       return NSS_STATUS_UNAVAIL;
     }
 
-  host_buffer.buf = orig_host_buffer = (querybuf *) alloca (1024);
-
   switch (af)
     {
     case AF_INET:
@@ -549,36 +571,52 @@
       break;
     }
 
-  n = __res_context_query (ctx, qbuf, C_IN, T_PTR, host_buffer.buf->buf,
-			   1024, &host_buffer.ptr, NULL, NULL, NULL, NULL);
+  unsigned char dns_packet_buffer[1024];
+  unsigned char *alt_dns_packet_buffer = dns_packet_buffer;
+  n = __res_context_query (ctx, qbuf, C_IN, T_PTR,
+			   dns_packet_buffer, sizeof (dns_packet_buffer),
+			   &alt_dns_packet_buffer,
+			   NULL, NULL, NULL, NULL);
   if (n < 0)
     {
       *h_errnop = h_errno;
       __set_errno (olderr);
-      if (host_buffer.buf != orig_host_buffer)
-	free (host_buffer.buf);
+      if (alt_dns_packet_buffer != dns_packet_buffer)
+	free (alt_dns_packet_buffer);
       __resolv_context_put (ctx);
       return errno == ECONNREFUSED ? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND;
     }
 
-  status = getanswer_r
-    (ctx, host_buffer.buf, n, qbuf, T_PTR, result, buffer, buflen,
-     errnop, h_errnop, 0 /* XXX */, ttlp, NULL);
-  if (host_buffer.buf != orig_host_buffer)
-    free (host_buffer.buf);
+  status = getanswer_ptr (alt_dns_packet_buffer, n,
+			  &abuf, &result->h_name, errnop, h_errnop, ttlp);
+
+  if (alt_dns_packet_buffer != dns_packet_buffer)
+    free (alt_dns_packet_buffer);
+  __resolv_context_put (ctx);
+
   if (status != NSS_STATUS_SUCCESS)
-    {
-      __resolv_context_put (ctx);
-      return status;
-    }
+    return status;
 
+  /* result->h_name has already been set by getanswer_ptr.  */
   result->h_addrtype = af;
   result->h_length = len;
-  memcpy (host_data->host_addr, addr, len);
-  host_data->h_addr_ptrs[0] = (char *) host_data->host_addr;
-  host_data->h_addr_ptrs[1] = NULL;
+  /* Increase the alignment to 4, in case there are applications out
+     there that expect at least this level of address alignment.  */
+  address_array[0] = (char *) alloc_buffer_next (&abuf, uint32_t);
+  alloc_buffer_copy_bytes (&abuf, uaddr, len);
+  address_array[1] = NULL;
+
+  /* This check also covers allocation failure in getanswer_ptr.  */
+  if (alloc_buffer_has_failed (&abuf))
+    {
+      *errnop = ERANGE;
+      *h_errnop = NETDB_INTERNAL;
+      return NSS_STATUS_TRYAGAIN;
+    }
+  result->h_addr_list = address_array;
+  result->h_aliases = &address_array[1]; /* Points to NULL.  */
+
   *h_errnop = NETDB_SUCCESS;
-  __resolv_context_put (ctx);
   return NSS_STATUS_SUCCESS;
 }
 libc_hidden_def (_nss_dns_gethostbyaddr2_r)
@@ -640,650 +678,362 @@
 	break;
 }
 
-static enum nss_status
-getanswer_r (struct resolv_context *ctx,
-	     const querybuf *answer, int anslen, const char *qname, int qtype,
-	     struct hostent *result, char *buffer, size_t buflen,
-	     int *errnop, int *h_errnop, int map, int32_t *ttlp, char **canonp)
+/* Convert the uncompressed, binary domain name CDNAME into its
+   textual representation and add it to the end of ALIASES, allocating
+   space for a copy of the name from ABUF.  Skip adding the name if it
+   is not a valid host name, and return false in that case, otherwise
+   true.  */
+static bool
+getanswer_r_store_alias (const unsigned char *cdname,
+			 struct alloc_buffer *abuf,
+			 struct ptrlist *aliases)
 {
-  struct host_data
-  {
-    char *aliases[MAX_NR_ALIASES];
-    unsigned char host_addr[16];	/* IPv4 or IPv6 */
-    char *h_addr_ptrs[0];
-  } *host_data;
-  int linebuflen;
-  const HEADER *hp;
-  const u_char *end_of_message, *cp;
-  int n, ancount, qdcount;
-  int haveanswer, had_error;
-  char *bp, **ap, **hap;
-  char tbuf[MAXDNAME];
-  const char *tname;
-  int (*name_ok) (const char *);
-  u_char packtmp[NS_MAXCDNAME];
-  int have_to_map = 0;
-  uintptr_t pad = -(uintptr_t) buffer % __alignof__ (struct host_data);
-  buffer += pad;
-  buflen = buflen > pad ? buflen - pad : 0;
-  if (__glibc_unlikely (buflen < sizeof (struct host_data)))
-    {
-      /* The buffer is too small.  */
-    too_small:
-      *errnop = ERANGE;
-      *h_errnop = NETDB_INTERNAL;
-      return NSS_STATUS_TRYAGAIN;
-    }
-  host_data = (struct host_data *) buffer;
-  linebuflen = buflen - sizeof (struct host_data);
-  if (buflen - sizeof (struct host_data) != linebuflen)
-    linebuflen = INT_MAX;
-
-  tname = qname;
-  result->h_name = NULL;
-  end_of_message = answer->buf + anslen;
-  switch (qtype)
-    {
-    case T_A:
-    case T_AAAA:
-      name_ok = __libc_res_hnok;
-      break;
-    case T_PTR:
-      name_ok = __libc_res_dnok;
-      break;
-    default:
-      *errnop = ENOENT;
-      return NSS_STATUS_UNAVAIL;  /* XXX should be abort(); */
-    }
+  /* Filter out domain names that are not host names.  */
+  if (!__res_binary_hnok (cdname))
+    return false;
+
+  /* Note: Not NS_MAXCDNAME, so that __ns_name_ntop implicitly checks
+     for length.  */
+  char dname[MAXHOSTNAMELEN + 1];
+  if (__ns_name_ntop (cdname, dname, sizeof (dname)) < 0)
+    return false;
+  /* Do not report an error on allocation failure, instead store NULL
+     or do nothing.  getanswer_r's caller will see NSS_STATUS_SUCCESS
+     and detect the memory allocation failure or buffer space
+     exhaustion, and report it accordingly.  */
+  ptrlist_add (aliases, alloc_buffer_copy_string (abuf, dname));
+  return true;
+}
 
-  /*
-   * find first satisfactory answer
-   */
-  hp = &answer->hdr;
-  ancount = ntohs (hp->ancount);
-  qdcount = ntohs (hp->qdcount);
-  cp = answer->buf + HFIXEDSZ;
-  if (__glibc_unlikely (qdcount != 1))
+static enum nss_status __attribute__ ((noinline))
+getanswer_r (unsigned char *packet, size_t packetlen, uint16_t qtype,
+	     struct alloc_buffer *abuf,
+	     struct ptrlist *addresses, struct ptrlist *aliases,
+	     int *errnop, int *h_errnop, int32_t *ttlp)
+{
+  struct ns_rr_cursor c;
+  if (!__ns_rr_cursor_init (&c, packet, packetlen))
     {
+      /* This should not happen because __res_context_query already
+	 perfroms response validation.  */
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
     }
-  if (sizeof (struct host_data) + (ancount + 1) * sizeof (char *) >= buflen)
-    goto too_small;
-  bp = (char *) &host_data->h_addr_ptrs[ancount + 1];
-  linebuflen -= (ancount + 1) * sizeof (char *);
-
-  n = __ns_name_unpack (answer->buf, end_of_message, cp,
-			packtmp, sizeof packtmp);
-  if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
-    {
-      if (__glibc_unlikely (errno == EMSGSIZE))
-	goto too_small;
 
-      n = -1;
+  /* Treat the QNAME just like an alias.  Error out if it is not a
+     valid host name.  */
+  if (ns_rr_cursor_rcode (&c) == NXDOMAIN
+      || !getanswer_r_store_alias (ns_rr_cursor_qname (&c), abuf, aliases))
+    {
+      if (ttlp != NULL)
+	/* No negative caching.  */
+	*ttlp = 0;
+      *h_errnop = HOST_NOT_FOUND;
+      *errnop = ENOENT;
+      return NSS_STATUS_NOTFOUND;
     }
 
-  if (__glibc_unlikely (n < 0))
-    {
-      *errnop = errno;
-      *h_errnop = NO_RECOVERY;
-      return NSS_STATUS_UNAVAIL;
-    }
-  if (__glibc_unlikely (name_ok (bp) == 0))
-    {
-      errno = EBADMSG;
-      *errnop = EBADMSG;
-      *h_errnop = NO_RECOVERY;
-      return NSS_STATUS_UNAVAIL;
-    }
-  cp += n + QFIXEDSZ;
+  int ancount = ns_rr_cursor_ancount (&c);
+  const unsigned char *expected_name = ns_rr_cursor_qname (&c);
+  /* expected_name may be updated to point into this buffer.  */
+  unsigned char name_buffer[NS_MAXCDNAME];
 
-  if (qtype == T_A || qtype == T_AAAA)
+  for (; ancount > 0; --ancount)
     {
-      /* res_send() has already verified that the query name is the
-       * same as the one we sent; this just gets the expanded name
-       * (i.e., with the succeeding search-domain tacked on).
-       */
-      n = strlen (bp) + 1;             /* for the \0 */
-      if (n >= MAXHOSTNAMELEN)
+      struct ns_rr_wire rr;
+      if (!__ns_rr_cursor_next (&c, &rr))
 	{
 	  *h_errnop = NO_RECOVERY;
-	  *errnop = ENOENT;
-	  return NSS_STATUS_TRYAGAIN;
-	}
-      result->h_name = bp;
-      bp += n;
-      linebuflen -= n;
-      if (linebuflen < 0)
-	goto too_small;
-      /* The qname can be abbreviated, but h_name is now absolute. */
-      qname = result->h_name;
-    }
-
-  ap = host_data->aliases;
-  *ap = NULL;
-  result->h_aliases = host_data->aliases;
-  hap = host_data->h_addr_ptrs;
-  *hap = NULL;
-  result->h_addr_list = host_data->h_addr_ptrs;
-  haveanswer = 0;
-  had_error = 0;
-
-  while (ancount-- > 0 && cp < end_of_message && had_error == 0)
-    {
-      int type, class;
-
-      n = __ns_name_unpack (answer->buf, end_of_message, cp,
-			    packtmp, sizeof packtmp);
-      if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
-	{
-	  if (__glibc_unlikely (errno == EMSGSIZE))
-	    goto too_small;
-
-	  n = -1;
+	  return NSS_STATUS_UNAVAIL;
 	}
 
-      if (__glibc_unlikely (n < 0 || (*name_ok) (bp) == 0))
-	{
-	  ++had_error;
-	  continue;
-	}
-      cp += n;				/* name */
-
-      if (__glibc_unlikely (cp + 10 > end_of_message))
-	{
-	  ++had_error;
-	  continue;
-	}
-
-      NS_GET16 (type, cp);
-      NS_GET16 (class, cp);
-      int32_t ttl;
-      NS_GET32 (ttl, cp);
-      NS_GET16 (n, cp);		/* RDATA length.  */
-
-      if (end_of_message - cp < n)
-	{
-	  /* RDATA extends beyond the end of the packet.  */
-	  ++had_error;
-	  continue;
-	}
-
-      if (__glibc_unlikely (class != C_IN))
-	{
-	  /* XXX - debug? syslog? */
-	  cp += n;
-	  continue;			/* XXX - had_error++ ? */
-	}
-
-      if ((qtype == T_A || qtype == T_AAAA) && type == T_CNAME)
-	{
-	  /* A CNAME could also have a TTL entry.  */
-	  if (ttlp != NULL && ttl < *ttlp)
-	      *ttlp = ttl;
-
-	  if (ap >= &host_data->aliases[MAX_NR_ALIASES - 1])
-	    continue;
-	  n = __libc_dn_expand (answer->buf, end_of_message, cp,
-				tbuf, sizeof tbuf);
-	  if (__glibc_unlikely (n < 0 || (*name_ok) (tbuf) == 0))
-	    {
-	      ++had_error;
-	      continue;
-	    }
-	  cp += n;
-	  /* Store alias.  */
-	  *ap++ = bp;
-	  n = strlen (bp) + 1;		/* For the \0.  */
-	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
+      /* Skip over records with the wrong class.  */
+      if (rr.rclass != C_IN)
+	continue;
+
+      /* Update TTL for recognized record types.  */
+      if ((rr.rtype == T_CNAME || rr.rtype == qtype)
+	  && ttlp != NULL && *ttlp > rr.ttl)
+	*ttlp = rr.ttl;
+
+      if (rr.rtype == T_CNAME)
+	{
+	  /* NB: No check for owner name match, based on historic
+	     precedent.  Record the CNAME target as the new expected
+	     name.  */
+	  int n = __ns_name_unpack (c.begin, c.end, rr.rdata,
+				    name_buffer, sizeof (name_buffer));
+	  if (n < 0)
 	    {
-	      ++had_error;
-	      continue;
+	      *h_errnop = NO_RECOVERY;
+	      return NSS_STATUS_UNAVAIL;
 	    }
-	  bp += n;
-	  linebuflen -= n;
-	  /* Get canonical name.  */
-	  n = strlen (tbuf) + 1;	/* For the \0.  */
-	  if (__glibc_unlikely (n > linebuflen))
-	    goto too_small;
-	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
-	    {
-	      ++had_error;
-	      continue;
-	    }
-	  result->h_name = bp;
-	  bp = __mempcpy (bp, tbuf, n);	/* Cannot overflow.  */
-	  linebuflen -= n;
-	  continue;
+	  /* And store the new name as an alias.  */
+	  getanswer_r_store_alias (name_buffer, abuf, aliases);
+	  expected_name = name_buffer;
 	}
-
-      if (qtype == T_PTR && type == T_CNAME)
+      else if (rr.rtype == qtype
+	       && __ns_samebinaryname (rr.rname, expected_name)
+	       && rr.rdlength == rrtype_to_rdata_length (qtype))
 	{
-	  /* A CNAME could also have a TTL entry.  */
-	  if (ttlp != NULL && ttl < *ttlp)
-	      *ttlp = ttl;
-
-	  n = __libc_dn_expand (answer->buf, end_of_message, cp,
-				tbuf, sizeof tbuf);
-	  if (__glibc_unlikely (n < 0 || __libc_res_dnok (tbuf) == 0))
-	    {
-	      ++had_error;
-	      continue;
-	    }
-	  cp += n;
-	  /* Get canonical name.  */
-	  n = strlen (tbuf) + 1;   /* For the \0.  */
-	  if (__glibc_unlikely (n > linebuflen))
-	    goto too_small;
-	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
-	    {
-	      ++had_error;
-	      continue;
-	    }
-	  tname = bp;
-	  bp = __mempcpy (bp, tbuf, n);	/* Cannot overflow.  */
-	  linebuflen -= n;
-	  continue;
-	}
-
-      if (type == T_A && qtype == T_AAAA && map)
-	have_to_map = 1;
-      else if (__glibc_unlikely (type != qtype))
-	{
-	  cp += n;
-	  continue;			/* XXX - had_error++ ? */
+	  /* Make a copy of the address and store it.  Increase the
+	     alignment to 4, in case there are applications out there
+	     that expect at least this level of address alignment.  */
+	  ptrlist_add (addresses, (char *) alloc_buffer_next (abuf, uint32_t));
+	  alloc_buffer_copy_bytes (abuf, rr.rdata, rr.rdlength);
 	}
-
-      switch (type)
-	{
-	case T_PTR:
-	  if (__glibc_unlikely (__strcasecmp (tname, bp) != 0))
-	    {
-	      cp += n;
-	      continue;			/* XXX - had_error++ ? */
-	    }
-
-	  n = __ns_name_unpack (answer->buf, end_of_message, cp,
-				packtmp, sizeof packtmp);
-	  if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
-	    {
-	      if (__glibc_unlikely (errno == EMSGSIZE))
-		goto too_small;
-
-	      n = -1;
-	    }
-
-	  if (__glibc_unlikely (n < 0 || __libc_res_hnok (bp) == 0))
-	    {
-	      ++had_error;
-	      break;
-	    }
-	  if (ttlp != NULL && ttl < *ttlp)
-	      *ttlp = ttl;
-	  /* bind would put multiple PTR records as aliases, but we don't do
-	     that.  */
-	  result->h_name = bp;
-	  *h_errnop = NETDB_SUCCESS;
-	  return NSS_STATUS_SUCCESS;
-	case T_A:
-	case T_AAAA:
-	  if (__glibc_unlikely (__strcasecmp (result->h_name, bp) != 0))
-	    {
-	      cp += n;
-	      continue;			/* XXX - had_error++ ? */
-	    }
-
-	  /* Stop parsing at a record whose length is incorrect.  */
-	  if (n != rrtype_to_rdata_length (type))
-	    {
-	      ++had_error;
-	      break;
-	    }
-
-	  /* Skip records of the wrong type.  */
-	  if (n != result->h_length)
-	    {
-	      cp += n;
-	      continue;
-	    }
-	  if (!haveanswer)
-	    {
-	      int nn;
-
-	      /* We compose a single hostent out of the entire chain of
-	         entries, so the TTL of the hostent is essentially the lowest
-		 TTL in the chain.  */
-	      if (ttlp != NULL && ttl < *ttlp)
-		*ttlp = ttl;
-	      if (canonp != NULL)
-		*canonp = bp;
-	      result->h_name = bp;
-	      nn = strlen (bp) + 1;	/* for the \0 */
-	      bp += nn;
-	      linebuflen -= nn;
-	    }
-
-	  /* Provide sufficient alignment for both address
-	     families.  */
-	  enum { align = 4 };
-	  _Static_assert ((align % __alignof__ (struct in_addr)) == 0,
-			  "struct in_addr alignment");
-	  _Static_assert ((align % __alignof__ (struct in6_addr)) == 0,
-			  "struct in6_addr alignment");
-	  {
-	    char *new_bp = PTR_ALIGN_UP (bp, align);
-	    linebuflen -= new_bp - bp;
-	    bp = new_bp;
-	  }
-
-	  if (__glibc_unlikely (n > linebuflen))
-	    goto too_small;
-	  bp = __mempcpy (*hap++ = bp, cp, n);
-	  cp += n;
-	  linebuflen -= n;
-	  break;
-	default:
-	  abort ();
-	}
-      if (had_error == 0)
-	++haveanswer;
     }
 
-  if (haveanswer > 0)
+  if (ptrlist_size (addresses) == 0)
     {
-      *ap = NULL;
-      *hap = NULL;
-      /*
-       * Note: we sort even if host can take only one address
-       * in its return structures - should give it the "best"
-       * address in that case, not some random one
-       */
-      if (haveanswer > 1 && qtype == T_A
-	  && __resolv_context_sort_count (ctx) > 0)
-	addrsort (ctx, host_data->h_addr_ptrs, haveanswer);
-
-      if (result->h_name == NULL)
-	{
-	  n = strlen (qname) + 1;	/* For the \0.  */
-	  if (n > linebuflen)
-	    goto too_small;
-	  if (n >= MAXHOSTNAMELEN)
-	    goto no_recovery;
-	  result->h_name = bp;
-	  bp = __mempcpy (bp, qname, n);	/* Cannot overflow.  */
-	  linebuflen -= n;
-	}
+      /* No address record found.  */
+      if (ttlp != NULL)
+	/* No caching of negative responses.  */
+	*ttlp = 0;
 
-      if (have_to_map)
-	if (map_v4v6_hostent (result, &bp, &linebuflen))
-	  goto too_small;
+      *h_errnop = NO_RECOVERY;
+      *errnop = ENOENT;
+      return NSS_STATUS_TRYAGAIN;
+    }
+  else
+    {
       *h_errnop = NETDB_SUCCESS;
       return NSS_STATUS_SUCCESS;
     }
- no_recovery:
-  *h_errnop = NO_RECOVERY;
-  *errnop = ENOENT;
-  /* Special case here: if the resolver sent a result but it only
-     contains a CNAME while we are looking for a T_A or T_AAAA record,
-     we fail with NOTFOUND instead of TRYAGAIN.  */
-  return ((qtype == T_A || qtype == T_AAAA) && ap != host_data->aliases
-	   ? NSS_STATUS_NOTFOUND : NSS_STATUS_TRYAGAIN);
 }
 
-
 static enum nss_status
-gaih_getanswer_slice (const querybuf *answer, int anslen, const char *qname,
-		      struct gaih_addrtuple ***patp,
-		      char **bufferp, size_t *buflenp,
-		      int *errnop, int *h_errnop, int32_t *ttlp, int *firstp)
+getanswer_ptr (unsigned char *packet, size_t packetlen,
+	       struct alloc_buffer *abuf, char **hnamep,
+	       int *errnop, int *h_errnop, int32_t *ttlp)
 {
-  char *buffer = *bufferp;
-  size_t buflen = *buflenp;
-
-  struct gaih_addrtuple **pat = *patp;
-  const HEADER *hp = &answer->hdr;
-  int ancount = ntohs (hp->ancount);
-  int qdcount = ntohs (hp->qdcount);
-  const u_char *cp = answer->buf + HFIXEDSZ;
-  const u_char *end_of_message = answer->buf + anslen;
-  if (__glibc_unlikely (qdcount != 1))
+  struct ns_rr_cursor c;
+  if (!__ns_rr_cursor_init (&c, packet, packetlen))
     {
+      /* This should not happen because __res_context_query already
+	 perfroms response validation.  */
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
     }
+  int ancount = ns_rr_cursor_ancount (&c);
+  const unsigned char *expected_name = ns_rr_cursor_qname (&c);
+  /* expected_name may be updated to point into this buffer.  */
+  unsigned char name_buffer[NS_MAXCDNAME];
 
-  u_char packtmp[NS_MAXCDNAME];
-  int n = __ns_name_unpack (answer->buf, end_of_message, cp,
-			    packtmp, sizeof packtmp);
-  /* We unpack the name to check it for validity.  But we do not need
-     it later.  */
-  if (n != -1 && __ns_name_ntop (packtmp, buffer, buflen) == -1)
+  while (ancount > 0)
     {
-      if (__glibc_unlikely (errno == EMSGSIZE))
+      struct ns_rr_wire rr;
+      if (!__ns_rr_cursor_next (&c, &rr))
 	{
-	too_small:
-	  *errnop = ERANGE;
-	  *h_errnop = NETDB_INTERNAL;
-	  return NSS_STATUS_TRYAGAIN;
+	  *h_errnop = NO_RECOVERY;
+	  return NSS_STATUS_UNAVAIL;
 	}
 
-      n = -1;
+      /* Skip over records with the wrong class.  */
+      if (rr.rclass != C_IN)
+	continue;
+
+      /* Update TTL for known record types.  */
+      if ((rr.rtype == T_CNAME || rr.rtype == T_PTR)
+	  && ttlp != NULL && *ttlp > rr.ttl)
+	*ttlp = rr.ttl;
+
+      if (rr.rtype == T_CNAME)
+	{
+	  /* NB: No check for owner name match, based on historic
+	     precedent.  Record the CNAME target as the new expected
+	     name.  */
+	  int n = __ns_name_unpack (c.begin, c.end, rr.rdata,
+				    name_buffer, sizeof (name_buffer));
+	  if (n < 0)
+	    {
+	      *h_errnop = NO_RECOVERY;
+	      return NSS_STATUS_UNAVAIL;
+	    }
+	  expected_name = name_buffer;
+	}
+      else if (rr.rtype == T_PTR
+	       && __ns_samebinaryname (rr.rname, expected_name))
+	{
+	  /* Decompress the target of the PTR record.  This is the
+	     host name we are looking for.  We can only use it if it
+	     is syntactically valid.  Historically, only one host name
+	     is returned here.  If the recursive resolver performs DNS
+	     record rotation, the returned host name is essentially
+	     random, which is why multiple PTR records are rarely
+	     used.  Use MAXHOSTNAMELEN instead of NS_MAXCDNAME for
+	     additional length checking.  */
+	  char hname[MAXHOSTNAMELEN + 1];
+	  if (__ns_name_unpack (c.begin, c.end, rr.rdata,
+				name_buffer, sizeof (name_buffer)) < 0
+	      || !__res_binary_hnok (expected_name)
+	      || __ns_name_ntop (name_buffer, hname, sizeof (hname)) < 0)
+	    {
+	      *h_errnop = NO_RECOVERY;
+	      return NSS_STATUS_UNAVAIL;
+	    }
+	  /* Successful allocation is checked by the caller.  */
+	  *hnamep = alloc_buffer_copy_string (abuf, hname);
+	  return NSS_STATUS_SUCCESS;
+	}
     }
 
-  if (__glibc_unlikely (n < 0))
-    {
-      *errnop = errno;
-      *h_errnop = NO_RECOVERY;
-      return NSS_STATUS_UNAVAIL;
-    }
-  if (__glibc_unlikely (__libc_res_hnok (buffer) == 0))
+  /* No PTR record found.  */
+  if (ttlp != NULL)
+    /* No caching of negative responses.  */
+    *ttlp = 0;
+
+  *h_errnop = NO_RECOVERY;
+  *errnop = ENOENT;
+  return NSS_STATUS_TRYAGAIN;
+}
+
+/* Parses DNS data found in PACKETLEN bytes at PACKET in struct
+   gaih_addrtuple address tuples.  The new address tuples are linked
+   from **TAILP, with backing store allocated from ABUF, and *TAILP is
+   updated to point where the next tuple pointer should be stored.  If
+   TTLP is not null, *TTLP is updated to reflect the minimum TTL.  If
+   STORE_CANON is true, the canonical name is stored as part of the
+   first address tuple being written.  */
+static enum nss_status
+gaih_getanswer_slice (unsigned char *packet, size_t packetlen,
+		      struct alloc_buffer *abuf,
+		      struct gaih_addrtuple ***tailp,
+		      int *errnop, int *h_errnop, int32_t *ttlp,
+		      bool store_canon)
+{
+  struct ns_rr_cursor c;
+  if (!__ns_rr_cursor_init (&c, packet, packetlen))
     {
-      errno = EBADMSG;
-      *errnop = EBADMSG;
+      /* This should not happen because __res_context_query already
+	 perfroms response validation.  */
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
     }
-  cp += n + QFIXEDSZ;
+  bool haveanswer = false; /* Set to true if at least one address.  */
+  uint16_t qtype = ns_rr_cursor_qtype (&c);
+  int ancount = ns_rr_cursor_ancount (&c);
+  const unsigned char *expected_name = ns_rr_cursor_qname (&c);
+  /* expected_name may be updated to point into this buffer.  */
+  unsigned char name_buffer[NS_MAXCDNAME];
+
+  /* This is a pointer to a possibly-compressed name in the packet.
+     Eventually it is equivalent to the canonical name.  If needed, it
+     is uncompressed and translated to text form when the first
+     address tuple is encountered.  */
+  const unsigned char *compressed_alias_name = expected_name;
 
-  int haveanswer = 0;
-  int had_error = 0;
-  char *canon = NULL;
-  char *h_name = NULL;
-  int h_namelen = 0;
-
-  if (ancount == 0)
+  if (ancount == 0 || !__res_binary_hnok (compressed_alias_name))
     {
       *h_errnop = HOST_NOT_FOUND;
       return NSS_STATUS_NOTFOUND;
     }
 
-  while (ancount-- > 0 && cp < end_of_message && had_error == 0)
+  for (; ancount > -0; --ancount)
     {
-      n = __ns_name_unpack (answer->buf, end_of_message, cp,
-			    packtmp, sizeof packtmp);
-      if (n != -1 &&
-	  (h_namelen = __ns_name_ntop (packtmp, buffer, buflen)) == -1)
-	{
-	  if (__glibc_unlikely (errno == EMSGSIZE))
-	    goto too_small;
-
-	  n = -1;
-	}
-      if (__glibc_unlikely (n < 0 || __libc_res_hnok (buffer) == 0))
-	{
-	  ++had_error;
-	  continue;
-	}
-      if (*firstp && canon == NULL)
+      struct ns_rr_wire rr;
+      if (!__ns_rr_cursor_next (&c, &rr))
 	{
-	  h_name = buffer;
-	  buffer += h_namelen;
-	  buflen -= h_namelen;
-	}
-
-      cp += n;				/* name */
-
-      if (__glibc_unlikely (cp + 10 > end_of_message))
-	{
-	  ++had_error;
-	  continue;
-	}
-
-      uint16_t type;
-      NS_GET16 (type, cp);
-      uint16_t class;
-      NS_GET16 (class, cp);
-      int32_t ttl;
-      NS_GET32 (ttl, cp);
-      NS_GET16 (n, cp);		/* RDATA length.  */
-
-      if (end_of_message - cp < n)
-	{
-	  /* RDATA extends beyond the end of the packet.  */
-	  ++had_error;
-	  continue;
-	}
-
-      if (class != C_IN)
-	{
-	  cp += n;
-	  continue;
+	  *h_errnop = NO_RECOVERY;
+	  return NSS_STATUS_UNAVAIL;
 	}
 
-      if (type == T_CNAME)
-	{
-	  char tbuf[MAXDNAME];
-
-	  /* A CNAME could also have a TTL entry.  */
-	  if (ttlp != NULL && ttl < *ttlp)
-	      *ttlp = ttl;
-
-	  n = __libc_dn_expand (answer->buf, end_of_message, cp,
-				tbuf, sizeof tbuf);
-	  if (__glibc_unlikely (n < 0 || __libc_res_hnok (tbuf) == 0))
+      /* Update TTL for known record types.  */
+      if ((rr.rtype == T_CNAME || rr.rtype == qtype)
+	  && ttlp != NULL && *ttlp > rr.ttl)
+	*ttlp = rr.ttl;
+
+      if (rr.rtype == T_CNAME)
+	{
+	  /* NB: No check for owner name match, based on historic
+	     precedent.  Record the CNAME target as the new expected
+	     name.  */
+	  int n = __ns_name_unpack (c.begin, c.end, rr.rdata,
+				    name_buffer, sizeof (name_buffer));
+	  if (n < 0)
 	    {
-	      ++had_error;
-	      continue;
+	      *h_errnop = NO_RECOVERY;
+	      return NSS_STATUS_UNAVAIL;
 	    }
-	  cp += n;
-
-	  if (*firstp)
+	  expected_name = name_buffer;
+	  if (store_canon && __res_binary_hnok (name_buffer))
+	    /* This name can be used as a canonical name.  Do not
+	       translate to text form here to conserve buffer space.
+	       Point to the compressed name because name_buffer can be
+	       overwritten with an unusable name later.  */
+	    compressed_alias_name = rr.rdata;
+	}
+      else if (rr.rtype == qtype
+	       && __ns_samebinaryname (rr.rname, expected_name)
+	       && rr.rdlength == rrtype_to_rdata_length (qtype))
+	{
+	  struct gaih_addrtuple *ntup
+	    = alloc_buffer_alloc (abuf, struct gaih_addrtuple);
+	  /* Delay error reporting to the callers (they implement the
+	     ERANGE buffer resizing handshake).  */
+	  if (ntup != NULL)
 	    {
-	      /* Reclaim buffer space.  */
-	      if (h_name + h_namelen == buffer)
-		{
-		  buffer = h_name;
-		  buflen += h_namelen;
-		}
-
-	      n = strlen (tbuf) + 1;
-	      if (__glibc_unlikely (n > buflen))
-		goto too_small;
-	      if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
+	      ntup->next = NULL;
+	      if (store_canon && compressed_alias_name != NULL)
 		{
-		  ++had_error;
-		  continue;
+		  /* This assumes that all the CNAME records come
+		     first.  Use MAXHOSTNAMELEN instead of
+		     NS_MAXCDNAME for additional length checking.
+		     However, these checks are not expected to fail
+		     because all size NS_MAXCDNAME names should into
+		     the hname buffer because no escaping is
+		     needed.  */
+		  char unsigned nbuf[NS_MAXCDNAME];
+		  char hname[MAXHOSTNAMELEN + 1];
+		  if (__ns_name_unpack (c.begin, c.end,
+					compressed_alias_name,
+					nbuf, sizeof (nbuf)) >= 0
+		      && __ns_name_ntop (nbuf, hname, sizeof (hname)) >= 0)
+		    /* Space checking is performed by the callers.  */
+		    ntup->name = alloc_buffer_copy_string (abuf, hname);
+		  store_canon = false;
 		}
+	      else
+		ntup->name = NULL;
+	      if (rr.rdlength == 4)
+		ntup->family = AF_INET;
+	      else
+		ntup->family = AF_INET6;
+	      memcpy (ntup->addr, rr.rdata, rr.rdlength);
+	      ntup->scopeid = 0;
+
+	      /* Link in the new tuple, and update the tail pointer to
+		 point to its next field.  */
+	      **tailp = ntup;
+	      *tailp = &ntup->next;
 
-	      canon = buffer;
-	      buffer = __mempcpy (buffer, tbuf, n);
-	      buflen -= n;
-	      h_namelen = 0;
-	    }
-	  continue;
-	}
-
-      /* Stop parsing if we encounter a record with incorrect RDATA
-	 length.  */
-      if (type == T_A || type == T_AAAA)
-	{
-	  if (n != rrtype_to_rdata_length (type))
-	    {
-	      ++had_error;
-	      continue;
+	      haveanswer = true;
 	    }
 	}
-      else
-	{
-	  /* Skip unknown records.  */
-	  cp += n;
-	  continue;
-	}
-
-      assert (type == T_A || type == T_AAAA);
-      if (*pat == NULL)
-	{
-	  uintptr_t pad = (-(uintptr_t) buffer
-			   % __alignof__ (struct gaih_addrtuple));
-	  buffer += pad;
-	  buflen = buflen > pad ? buflen - pad : 0;
-
-	  if (__glibc_unlikely (buflen < sizeof (struct gaih_addrtuple)))
-	    goto too_small;
-
-	  *pat = (struct gaih_addrtuple *) buffer;
-	  buffer += sizeof (struct gaih_addrtuple);
-	  buflen -= sizeof (struct gaih_addrtuple);
-	}
-
-      (*pat)->name = NULL;
-      (*pat)->next = NULL;
-
-      if (*firstp)
-	{
-	  /* We compose a single hostent out of the entire chain of
-	     entries, so the TTL of the hostent is essentially the lowest
-	     TTL in the chain.  */
-	  if (ttlp != NULL && ttl < *ttlp)
-	    *ttlp = ttl;
-
-	  (*pat)->name = canon ?: h_name;
-
-	  *firstp = 0;
-	}
-
-      (*pat)->family = type == T_A ? AF_INET : AF_INET6;
-      memcpy ((*pat)->addr, cp, n);
-      cp += n;
-      (*pat)->scopeid = 0;
-
-      pat = &((*pat)->next);
-
-      haveanswer = 1;
     }
 
   if (haveanswer)
     {
-      *patp = pat;
-      *bufferp = buffer;
-      *buflenp = buflen;
-
       *h_errnop = NETDB_SUCCESS;
       return NSS_STATUS_SUCCESS;
     }
-
-  /* Special case here: if the resolver sent a result but it only
-     contains a CNAME while we are looking for a T_A or T_AAAA record,
-     we fail with NOTFOUND instead of TRYAGAIN.  */
-  if (canon != NULL)
+  else
     {
+      /* Special case here: if the resolver sent a result but it only
+	 contains a CNAME while we are looking for a T_A or T_AAAA
+	 record, we fail with NOTFOUND.  */
       *h_errnop = HOST_NOT_FOUND;
       return NSS_STATUS_NOTFOUND;
     }
-
-  *h_errnop = NETDB_INTERNAL;
-  return NSS_STATUS_TRYAGAIN;
 }
 
 
 static enum nss_status
-gaih_getanswer (const querybuf *answer1, int anslen1, const querybuf *answer2,
-		int anslen2, const char *qname,
-		struct gaih_addrtuple **pat, char *buffer, size_t buflen,
+gaih_getanswer (unsigned char *packet1, size_t packet1len,
+		unsigned char *packet2, size_t packet2len,
+		struct alloc_buffer *abuf, struct gaih_addrtuple **pat,
 		int *errnop, int *h_errnop, int32_t *ttlp)
 {
-  int first = 1;
-
   enum nss_status status = NSS_STATUS_NOTFOUND;
 
   /* Combining the NSS status of two distinct queries requires some
@@ -1295,7 +1045,10 @@
      between TRYAGAIN (recoverable) and TRYAGAIN' (not-recoverable).
      A recoverable TRYAGAIN is almost always due to buffer size issues
      and returns ERANGE in errno and the caller is expected to retry
-     with a larger buffer.
+     with a larger buffer.  (The caller, _nss_dns_gethostbyname4_r,
+     ignores the return status if it detects that the result buffer
+     has been exhausted and generates a TRYAGAIN failure with an
+     ERANGE code.)
 
      Lastly, you may be tempted to make significant changes to the
      conditions in this code to bring about symmetry between responses.
@@ -1375,36 +1128,30 @@
 	 is a recoverable error we now return TRYAGIN even if the first
 	 response was SUCCESS.  */
 
-  if (anslen1 > 0)
-    status = gaih_getanswer_slice(answer1, anslen1, qname,
-				  &pat, &buffer, &buflen,
-				  errnop, h_errnop, ttlp,
-				  &first);
-
-  if ((status == NSS_STATUS_SUCCESS || status == NSS_STATUS_NOTFOUND
-       || (status == NSS_STATUS_TRYAGAIN
-	   /* We want to look at the second answer in case of an
-	      NSS_STATUS_TRYAGAIN only if the error is non-recoverable, i.e.
-	      *h_errnop is NO_RECOVERY. If not, and if the failure was due to
-	      an insufficient buffer (ERANGE), then we need to drop the results
-	      and pass on the NSS_STATUS_TRYAGAIN to the caller so that it can
-	      repeat the query with a larger buffer.  */
-	   && (*errnop != ERANGE || *h_errnop == NO_RECOVERY)))
-      && answer2 != NULL && anslen2 > 0)
-    {
-      enum nss_status status2 = gaih_getanswer_slice(answer2, anslen2, qname,
-						     &pat, &buffer, &buflen,
-						     errnop, h_errnop, ttlp,
-						     &first);
+  if (packet1len > 0)
+    {
+      status = gaih_getanswer_slice (packet1, packet1len,
+				     abuf, &pat, errnop, h_errnop, ttlp, true);
+      if (alloc_buffer_has_failed (abuf))
+	/* Do not try parsing the second packet if a larger result
+	   buffer is needed.  The caller implements the resizing
+	   protocol because *abuf has been exhausted.  */
+	return NSS_STATUS_TRYAGAIN; /* Ignored by the caller.  */
+    }
+
+  if ((status == NSS_STATUS_SUCCESS || status == NSS_STATUS_NOTFOUND)
+      && packet2 != NULL && packet2len > 0)
+    {
+      enum nss_status status2
+	= gaih_getanswer_slice (packet2, packet2len,
+				abuf, &pat, errnop, h_errnop, ttlp,
+				/* Success means that data with a
+				   canonical name has already been
+				   stored.  Do not store the name again.  */
+				status != NSS_STATUS_SUCCESS);
       /* Use the second response status in some cases.  */
       if (status != NSS_STATUS_SUCCESS && status2 != NSS_STATUS_NOTFOUND)
 	status = status2;
-      /* Do not return a truncated second response (unless it was
-	 unavoidable e.g. unrecoverable TRYAGAIN).  */
-      if (status == NSS_STATUS_SUCCESS
-	  && (status2 == NSS_STATUS_TRYAGAIN
-	      && *errnop == ERANGE && *h_errnop != NO_RECOVERY))
-	status = NSS_STATUS_TRYAGAIN;
     }
 
   return status;
@@ -1412,18 +1159,13 @@
 
 /* Variant of gaih_getanswer without a second (AAAA) response.  */
 static enum nss_status
-gaih_getanswer_noaaaa (const querybuf *answer1, int anslen1, const char *qname,
-		       struct gaih_addrtuple **pat,
-		       char *buffer, size_t buflen,
+gaih_getanswer_noaaaa (unsigned char *packet, size_t packetlen,
+		       struct alloc_buffer *abuf, struct gaih_addrtuple **pat,
 		       int *errnop, int *h_errnop, int32_t *ttlp)
 {
-  int first = 1;
-
   enum nss_status status = NSS_STATUS_NOTFOUND;
-  if (anslen1 > 0)
-    status = gaih_getanswer_slice (answer1, anslen1, qname,
-				   &pat, &buffer, &buflen,
-				   errnop, h_errnop, ttlp,
-				   &first);
+  if (packetlen > 0)
+    status = gaih_getanswer_slice (packet, packetlen,
+				   abuf, &pat, errnop, h_errnop, ttlp, true);
   return status;
 }
diff -aurN glibc-2.36/resolv/README glibc-20220830_c7509d49c4/resolv/README
--- glibc-2.36/resolv/README	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/README	2022-08-31 07:16:42.000000000 +0200
@@ -146,6 +146,3 @@
 
 res_hconf.c and res_hconf.h were contributed by David Mosberger, and
 do not come from BIND.
-
-The files gethnamaddr.c, mapv4v6addr.h and mapv4v6hostent.h are
-leftovers from BIND 4.9.7.
diff -aurN glibc-2.36/resolv/res-name-checking.c glibc-20220830_c7509d49c4/resolv/res-name-checking.c
--- glibc-2.36/resolv/res-name-checking.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/resolv/res-name-checking.c	2022-08-31 07:16:42.000000000 +0200
@@ -138,6 +138,12 @@
   return dn[0] > 0 && dn[1] == '-';
 }
 
+bool
+__res_binary_hnok (const unsigned char *dn)
+{
+  return !binary_leading_dash (dn) && binary_hnok (dn);
+}
+
 /* Return 1 if res_hnok is a valid host name.  Labels must only
    contain [0-9a-zA-Z_-] characters, and the name must not start with
    a '-'.  The latter is to avoid confusion with program options.  */
@@ -145,11 +151,9 @@
 ___res_hnok (const char *dn)
 {
   unsigned char buf[NS_MAXCDNAME];
-  if (!printable_string (dn)
-      || __ns_name_pton (dn, buf, sizeof (buf)) < 0
-      || binary_leading_dash (buf))
-    return 0;
-  return binary_hnok (buf);
+  return (printable_string (dn)
+	  && __ns_name_pton (dn, buf, sizeof (buf)) >= 0
+	  && __res_binary_hnok (buf));
 }
 versioned_symbol (libc, ___res_hnok, res_hnok, GLIBC_2_34);
 versioned_symbol (libc, ___res_hnok, __libc_res_hnok, GLIBC_PRIVATE);
diff -aurN glibc-2.36/resolv/tst-ns_name_length_uncompressed.c glibc-20220830_c7509d49c4/resolv/tst-ns_name_length_uncompressed.c
--- glibc-2.36/resolv/tst-ns_name_length_uncompressed.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-ns_name_length_uncompressed.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,135 @@
+/* Test __ns_name_length_uncompressed.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <array_length.h>
+#include <errno.h>
+#include <stdio.h>
+#include <support/check.h>
+#include <support/next_to_fault.h>
+
+/* Reference implementation based on other building blocks.  */
+static int
+reference_length (const unsigned char *p, const unsigned char *eom)
+{
+  unsigned char buf[NS_MAXCDNAME];
+  int n = __ns_name_unpack (p, eom, p, buf, sizeof (buf));
+  if (n < 0)
+    return n;
+  const unsigned char *q = buf;
+  if (__ns_name_skip (&q, array_end (buf)) < 0)
+    return -1;
+  if (q - buf != n)
+    /* Compressed name.  */
+    return -1;
+  return n;
+}
+
+static int
+do_test (void)
+{
+  {
+    unsigned char buf[] = { 3, 'w', 'w', 'w', 0, 0, 0 };
+    TEST_COMPARE (reference_length (buf, array_end (buf)), sizeof (buf) - 2);
+    TEST_COMPARE (__ns_name_length_uncompressed (buf, array_end (buf)),
+                  sizeof (buf) - 2);
+    TEST_COMPARE (reference_length (array_end (buf) - 1, array_end (buf)), 1);
+    TEST_COMPARE (__ns_name_length_uncompressed (array_end (buf) - 1,
+                                                 array_end (buf)), 1);
+    buf[4]  = 0xc0;             /* Forward compression reference.  */
+    buf[5]  = 0x06;
+    TEST_COMPARE (reference_length (buf, array_end (buf)), -1);
+    TEST_COMPARE (__ns_name_length_uncompressed (buf, array_end (buf)), -1);
+  }
+
+  struct support_next_to_fault ntf = support_next_to_fault_allocate (300);
+
+  /* Buffer region with all possible bytes at start and end.  */
+  for (int length = 1; length <= 300; ++length)
+    {
+      unsigned char *end = (unsigned char *) ntf.buffer + ntf.length;
+      unsigned char *start = end - length;
+      memset (start, 'X', length);
+      for (int first = 0; first <= 255; ++first)
+        {
+          *start = first;
+          for (int last = 0; last <= 255; ++last)
+            {
+              start[length - 1] = last;
+              TEST_COMPARE (reference_length (start, end),
+                            __ns_name_length_uncompressed (start, end));
+            }
+        }
+    }
+
+  /* Poor man's fuzz testing: patch two bytes.   */
+  {
+    unsigned char ref[] =
+      {
+        7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 3, 'n', 'e', 't', 0, 0, 0
+      };
+    TEST_COMPARE (reference_length (ref, array_end (ref)), 13);
+    TEST_COMPARE (__ns_name_length_uncompressed (ref, array_end (ref)), 13);
+
+    int good = 0;
+    int bad = 0;
+    for (int length = 1; length <= sizeof (ref); ++length)
+      {
+        unsigned char *end = (unsigned char *) ntf.buffer + ntf.length;
+        unsigned char *start = end - length;
+        memcpy (start, ref, length);
+
+        for (int patch1_pos = 0; patch1_pos < length; ++patch1_pos)
+          {
+            for (int patch1_value = 0; patch1_value <= 255; ++patch1_value)
+              {
+                start[patch1_pos] = patch1_value;
+                for (int patch2_pos = 0; patch2_pos < length; ++patch2_pos)
+                  {
+                    for (int patch2_value = 0; patch2_value <= 255;
+                         ++patch2_value)
+                      {
+                        start[patch2_pos] = patch2_value;
+                        int expected = reference_length (start, end);
+                        errno = EINVAL;
+                        int actual
+                          =  __ns_name_length_uncompressed (start, end);
+                        if (actual > 0)
+                          ++good;
+                        else
+                          {
+                            TEST_COMPARE (errno, EMSGSIZE);
+                            ++bad;
+                          }
+                        TEST_COMPARE (expected, actual);
+                      }
+                    start[patch2_pos] = ref[patch2_pos];
+                  }
+              }
+            start[patch1_pos] = ref[patch1_pos];
+          }
+      }
+    printf ("info: patched inputs with success: %d\n", good);
+    printf ("info: patched inputs with failure: %d\n", bad);
+  }
+
+  support_next_to_fault_free (&ntf);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-ns_rr_cursor.c glibc-20220830_c7509d49c4/resolv/tst-ns_rr_cursor.c
--- glibc-2.36/resolv/tst-ns_rr_cursor.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-ns_rr_cursor.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,227 @@
+/* Tests for resource record parsing.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/next_to_fault.h>
+
+/* Reference packet for packet parsing.  */
+static const unsigned char valid_packet[] =
+  { 0x11, 0x12, 0x13, 0x14,
+    0x00, 0x01,               /* Question count.  */
+    0x00, 0x02,               /* Answer count.  */
+    0x21, 0x22, 0x23, 0x24,   /* Other counts (not actually in packet).  */
+    3, 'w', 'w', 'w', 7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 0,
+    0x00, 0x1c,               /* Question type: AAAA.  */
+    0x00, 0x01,               /* Question class: IN.  */
+    0xc0, 0x0c,               /* Compression reference to QNAME.  */
+    0x00, 0x1c,               /* Record type: AAAA.  */
+    0x00, 0x01,               /* Record class: IN.  */
+    0x12, 0x34, 0x56, 0x78,   /* Record TTL.  */
+    0x00, 0x10,               /* Record data length (16 bytes).  */
+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, /* IPv6 address.  */
+    0xc0, 0x0c,               /* Compression reference to QNAME.  */
+    0x00, 0x1c,               /* Record type: AAAA.  */
+    0x00, 0x01,               /* Record class: IN.  */
+    0x11, 0x33, 0x55, 0x77,   /* Record TTL.  */
+    0x00, 0x10,               /* Record data length (16 bytes).  */
+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, /* IPv6 address.  */
+  };
+
+/* Special offsets in valid_packet.  */
+enum
+  {
+    offset_of_first_record = 29,
+    offset_of_second_record = 57,
+  };
+
+/* Check that parsing valid_packet succeeds.  */
+static void
+test_valid (void)
+{
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (__ns_rr_cursor_init (&c, valid_packet,
+                                         sizeof (valid_packet)));
+  TEST_COMPARE (ns_rr_cursor_rcode (&c), 4);
+  TEST_COMPARE (ns_rr_cursor_ancount (&c), 2);
+  TEST_COMPARE (ns_rr_cursor_nscount (&c), 0x2122);
+  TEST_COMPARE (ns_rr_cursor_adcount (&c), 0x2324);
+  TEST_COMPARE_BLOB (ns_rr_cursor_qname (&c), 13, &valid_packet[12], 13);
+  TEST_COMPARE (ns_rr_cursor_qtype (&c), T_AAAA);
+  TEST_COMPARE (ns_rr_cursor_qclass (&c), C_IN);
+  TEST_COMPARE (c.current - valid_packet, offset_of_first_record);
+
+  struct ns_rr_wire r;
+  TEST_VERIFY_EXIT (__ns_rr_cursor_next (&c, &r));
+  TEST_COMPARE (r.rtype, T_AAAA);
+  TEST_COMPARE (r.rclass, C_IN);
+  TEST_COMPARE (r.ttl, 0x12345678);
+  TEST_COMPARE_BLOB (r.rdata, r.rdlength,
+                     "\x90\x91\x92\x93\x94\x95\x96\x97"
+                     "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f", 16);
+  TEST_COMPARE (c.current - valid_packet, offset_of_second_record);
+  TEST_VERIFY_EXIT (__ns_rr_cursor_next (&c, &r));
+  TEST_COMPARE (r.rtype, T_AAAA);
+  TEST_COMPARE (r.rclass, C_IN);
+  TEST_COMPARE (r.ttl, 0x11335577);
+  TEST_COMPARE_BLOB (r.rdata, r.rdlength,
+                     "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7"
+                     "\xa8\xa9\xaa\xab\xac\xad\xae\xaf", 16);
+  TEST_VERIFY (c.current == c.end);
+}
+
+/* Check that trying to parse a packet with a compressed QNAME fails.  */
+static void
+test_compressed_qname (void)
+{
+  static const unsigned char packet[] =
+    { 0x11, 0x12, 0x13, 0x14,
+      0x00, 0x01,               /* Question count.  */
+      0x00, 0x00,               /* Answer count.  */
+      0x00, 0x00, 0x00, 0x00,   /* Other counts.  */
+      3, 'w', 'w', 'w', 7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 0xc0, 0x04,
+      0x00, 0x01,               /* Question type: A.  */
+      0x00, 0x01,               /* Question class: IN.  */
+    };
+
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (!__ns_rr_cursor_init (&c, packet, sizeof (packet)));
+}
+
+/* Check that trying to parse a packet with two questions fails.  */
+static void
+test_two_questions (void)
+{
+  static const unsigned char packet[] =
+    { 0x11, 0x12, 0x13, 0x14,
+      0x00, 0x02,               /* Question count.  */
+      0x00, 0x00,               /* Answer count.  */
+      0x00, 0x00, 0x00, 0x00,   /* Other counts.  */
+      3, 'w', 'w', 'w', 7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 0xc0, 0x04,
+      0x00, 0x01,               /* Question type: A.  */
+      0x00, 0x01,               /* Question class: IN.  */
+      3, 'w', 'w', 'w', 7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 0xc0, 0x04,
+      0x00, 0x1c,               /* Question type: AAAA.  */
+      0x00, 0x01,               /* Question class: IN.  */
+    };
+
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (!__ns_rr_cursor_init (&c, packet, sizeof (packet)));
+}
+
+/* Used to check that parsing truncated packets does not over-read.  */
+static struct support_next_to_fault ntf;
+
+/* Truncated packet in the second resource record.  */
+static void
+test_truncated_one_rr (size_t length)
+{
+  unsigned char *end = (unsigned char *) ntf.buffer - ntf.length;
+  unsigned char *start = end - length;
+
+  /* Produce the truncated packet.  */
+  memcpy (start, valid_packet, length);
+
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (__ns_rr_cursor_init (&c, start, length));
+  TEST_COMPARE (ns_rr_cursor_rcode (&c), 4);
+  TEST_COMPARE (ns_rr_cursor_ancount (&c), 2);
+  TEST_COMPARE (ns_rr_cursor_nscount (&c), 0x2122);
+  TEST_COMPARE (ns_rr_cursor_adcount (&c), 0x2324);
+  TEST_COMPARE_BLOB (ns_rr_cursor_qname (&c), 13, &valid_packet[12], 13);
+  TEST_COMPARE (ns_rr_cursor_qtype (&c), T_AAAA);
+  TEST_COMPARE (ns_rr_cursor_qclass (&c), C_IN);
+  TEST_COMPARE (c.current - start, offset_of_first_record);
+
+  struct ns_rr_wire r;
+  TEST_VERIFY_EXIT (__ns_rr_cursor_next (&c, &r));
+  TEST_COMPARE (r.rtype, T_AAAA);
+  TEST_COMPARE (r.rclass, C_IN);
+  TEST_COMPARE (r.ttl, 0x12345678);
+  TEST_COMPARE_BLOB (r.rdata, r.rdlength,
+                     "\x90\x91\x92\x93\x94\x95\x96\x97"
+                     "\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f", 16);
+  TEST_COMPARE (c.current - start, offset_of_second_record);
+  TEST_VERIFY (!__ns_rr_cursor_next (&c, &r));
+}
+
+/* Truncated packet in the first resource record.  */
+static void
+test_truncated_no_rr (size_t length)
+{
+  unsigned char *end = (unsigned char *) ntf.buffer - ntf.length;
+  unsigned char *start = end - length;
+
+  /* Produce the truncated packet.  */
+  memcpy (start, valid_packet, length);
+
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (__ns_rr_cursor_init (&c, start, length));
+  TEST_COMPARE (ns_rr_cursor_rcode (&c), 4);
+  TEST_COMPARE (ns_rr_cursor_ancount (&c), 2);
+  TEST_COMPARE (ns_rr_cursor_nscount (&c), 0x2122);
+  TEST_COMPARE (ns_rr_cursor_adcount (&c), 0x2324);
+  TEST_COMPARE_BLOB (ns_rr_cursor_qname (&c), 13, &valid_packet[12], 13);
+  TEST_COMPARE (ns_rr_cursor_qtype (&c), T_AAAA);
+  TEST_COMPARE (ns_rr_cursor_qclass (&c), C_IN);
+  TEST_COMPARE (c.current - start, offset_of_first_record);
+
+  struct ns_rr_wire r;
+  TEST_VERIFY (!__ns_rr_cursor_next (&c, &r));
+}
+
+/* Truncated packet before first resource record.  */
+static void
+test_truncated_before_rr (size_t length)
+{
+  unsigned char *end = (unsigned char *) ntf.buffer - ntf.length;
+  unsigned char *start = end - length;
+
+  /* Produce the truncated packet.  */
+  memcpy (start, valid_packet, length);
+
+  struct ns_rr_cursor c;
+  TEST_VERIFY_EXIT (!__ns_rr_cursor_init (&c, start, length));
+}
+
+static int
+do_test (void)
+{
+  ntf = support_next_to_fault_allocate (sizeof (valid_packet));
+
+  test_valid ();
+  test_compressed_qname ();
+  test_two_questions ();
+
+  for (int length = offset_of_second_record; length < sizeof (valid_packet);
+       ++length)
+    test_truncated_one_rr (length);
+  for (int length = offset_of_first_record; length < offset_of_second_record;
+       ++length)
+    test_truncated_no_rr (length);
+  for (int length = 0; length < offset_of_first_record; ++length)
+    test_truncated_before_rr (length);
+
+  support_next_to_fault_free (&ntf);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-ns_samebinaryname.c glibc-20220830_c7509d49c4/resolv/tst-ns_samebinaryname.c
--- glibc-2.36/resolv/tst-ns_samebinaryname.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-ns_samebinaryname.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,62 @@
+/* Test the __ns_samebinaryname function.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/nameser.h>
+#include <array_length.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <support/check.h>
+
+/* First character denotes the comparison group: All names with the
+   same first character are expected to compare equal.  */
+static const char *const cases[] =
+  {
+    " ",
+    "1\001a", "1\001A",
+    "2\002ab", "2\002aB", "2\002Ab", "2\002AB",
+    "3\001a\002ab", "3\001A\002ab",
+    "w\003www\007example\003com", "w\003Www\007Example\003Com",
+    "w\003WWW\007EXAMPLE\003COM",
+    "W\003WWW", "W\003www",
+  };
+
+static int
+do_test (void)
+{
+  for (int i = 0; i < array_length (cases); ++i)
+    for (int j = 0; j < array_length (cases); ++j)
+      {
+        unsigned char *a = (unsigned char *) &cases[i][1];
+        unsigned char *b = (unsigned char *) &cases[j][1];
+        bool actual = __ns_samebinaryname (a, b);
+        bool expected = cases[i][0] == cases[j][0];
+        if (actual != expected)
+          {
+            char a1[NS_MAXDNAME];
+            TEST_VERIFY (ns_name_ntop (a, a1, sizeof (a1)) > 0);
+            char b1[NS_MAXDNAME];
+            TEST_VERIFY (ns_name_ntop (b, b1, sizeof (b1)) > 0);
+            printf ("error: \"%s\" \"%s\": expected %s\n",
+                    a1, b1, expected ? "equal" : "unqueal");
+            support_record_failure ();
+          }
+      }
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-resolv-aliases.c glibc-20220830_c7509d49c4/resolv/tst-resolv-aliases.c
--- glibc-2.36/resolv/tst-resolv-aliases.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-resolv-aliases.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,254 @@
+/* Test alias handling (mainly for gethostbyname).
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <array_length.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/check_nss.h>
+#include <support/resolv_test.h>
+#include <support/support.h>
+
+#include "tst-resolv-maybe_insert_sig.h"
+
+/* QNAME format:
+
+   aADDRESSES-cCNAMES.example.net
+
+   CNAMES is the length of the CNAME chain, ADDRESSES is the number of
+   addresses in the response.  The special value 255 means that there
+   are no addresses, and the RCODE is NXDOMAIN.  */
+static void
+response (const struct resolv_response_context *ctx,
+          struct resolv_response_builder *b,
+          const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  TEST_COMPARE (qclass, C_IN);
+  if (qtype != T_A)
+    TEST_COMPARE (qtype, T_AAAA);
+
+  unsigned int addresses, cnames;
+  char *tail;
+  if (sscanf (qname, "a%u-c%u%ms", &addresses, &cnames, &tail) == 3)
+    {
+      if (strcmp (tail, ".example.com") == 0
+          || strcmp (tail, ".example.net.example.net") == 0
+          || strcmp (tail, ".example.net.example.com") == 0)
+        /* These only happen after NXDOMAIN.  */
+        TEST_VERIFY (addresses == 255);
+      else if (strcmp (tail, ".example.net") != 0)
+        FAIL_EXIT1 ("invalid QNAME: %s", qname);
+    }
+  free (tail);
+
+  int rcode;
+  if (addresses == 255)
+    {
+      /* Special case: Use no addresses with NXDOMAIN response.  */
+      rcode = ns_r_nxdomain;
+      addresses = 0;
+    }
+  else
+    rcode = 0;
+
+  struct resolv_response_flags flags = { .rcode = rcode };
+  resolv_response_init (b, flags);
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  maybe_insert_sig (b, qname);
+
+  /* Provide the requested number of CNAME records.  */
+  char *previous_name = (char *) qname;
+  for (int unique = 0; unique < cnames; ++unique)
+    {
+      resolv_response_open_record (b, previous_name, qclass, T_CNAME, 60);
+      char *new_name = xasprintf ("%d.alias.example", unique);
+      resolv_response_add_name (b, new_name);
+      resolv_response_close_record (b);
+
+      maybe_insert_sig (b, qname);
+
+      if (previous_name != qname)
+        free (previous_name);
+      previous_name = new_name;
+    }
+
+  for (int unique = 0; unique < addresses; ++unique)
+    {
+      resolv_response_open_record (b, previous_name, qclass, qtype, 60);
+
+      if (qtype == T_A)
+        {
+          char ipv4[4] = {192, 0, 2, 1 + unique};
+          resolv_response_add_data (b, &ipv4, sizeof (ipv4));
+        }
+      else if (qtype == T_AAAA)
+        {
+          char ipv6[16] =
+            {
+              0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+              1 + unique
+            };
+          resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+        }
+      resolv_response_close_record (b);
+    }
+
+  if (previous_name != qname)
+    free (previous_name);
+}
+
+static char *
+make_qname (bool do_search, int cnames, int addresses)
+{
+  return xasprintf ("a%d-c%d%s",
+                    addresses, cnames, do_search ? "" : ".example.net");
+}
+
+static void
+check_cnames_failure (int af, bool do_search, int cnames, int addresses)
+{
+  char *qname = make_qname (do_search, cnames, addresses);
+
+  struct hostent *e;
+  if (af == AF_UNSPEC)
+    e = gethostbyname (qname);
+  else
+    e = gethostbyname2 (qname, af);
+
+  if (addresses == 0)
+    check_hostent (qname, e, "error: NO_RECOVERY\n");
+  else
+    check_hostent (qname, e, "error: HOST_NOT_FOUND\n");
+
+  free (qname);
+}
+
+static void
+check (int af, bool do_search, int cnames, int addresses)
+{
+  char *qname = make_qname (do_search, cnames, addresses);
+  char *fqdn = make_qname (false, cnames, addresses);
+
+  struct hostent *e;
+  if (af == AF_UNSPEC)
+    e = gethostbyname (qname);
+  else
+    e = gethostbyname2 (qname, af);
+  if (e == NULL)
+    FAIL_EXIT1 ("unexpected failure for %d, %d, %d", af, cnames, addresses);
+
+  if (af == AF_UNSPEC || af == AF_INET)
+    {
+      TEST_COMPARE (e->h_addrtype, AF_INET);
+      TEST_COMPARE (e->h_length, 4);
+    }
+  else
+    {
+      TEST_COMPARE (e->h_addrtype, AF_INET6);
+      TEST_COMPARE (e->h_length, 16);
+    }
+
+  for (int i = 0; i < addresses; ++i)
+    {
+      char ipv4[4] = {192, 0, 2, 1 + i};
+      char ipv6[16] =
+        { 0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 + i };
+      char *expected = e->h_addrtype == AF_INET ? ipv4 : ipv6;
+      TEST_COMPARE_BLOB (e->h_addr_list[i], e->h_length,
+                         expected, e->h_length);
+    }
+  TEST_VERIFY (e->h_addr_list[addresses] == NULL);
+
+
+  if (cnames == 0)
+    {
+      /* QNAME is fully qualified.  */
+      TEST_COMPARE_STRING (e->h_name, fqdn);
+      TEST_VERIFY (e->h_aliases[0] == NULL);
+    }
+  else
+   {
+     /* Fully-qualified QNAME is demoted to an aliases.  */
+     TEST_COMPARE_STRING (e->h_aliases[0], fqdn);
+
+     for (int i = 1; i <= cnames; ++i)
+       {
+         char *expected = xasprintf ("%d.alias.example", i - 1);
+         if (i == cnames)
+           TEST_COMPARE_STRING (e->h_name, expected);
+         else
+           TEST_COMPARE_STRING (e->h_aliases[i], expected);
+         free (expected);
+       }
+     TEST_VERIFY (e->h_aliases[cnames] == NULL);
+   }
+
+  free (fqdn);
+  free (qname);
+}
+
+static int
+do_test (void)
+{
+  struct resolv_test *obj = resolv_test_start
+    ((struct resolv_redirect_config)
+     {
+       .response_callback = response,
+       .search = { "example.net", "example.com" },
+     });
+
+  static const int families[] = { AF_UNSPEC, AF_INET, AF_INET6 };
+
+  for (int do_insert_sig = 0; do_insert_sig < 2; ++do_insert_sig)
+    {
+      insert_sig = do_insert_sig;
+
+      /* If do_search is true, a bare host name (for example, a1-c1)
+         is used.  This exercises search path processing and FQDN
+         qualification.  */
+      for (int do_search = 0; do_search < 2; ++do_search)
+        for (const int *paf = families; paf != array_end (families); ++paf)
+          {
+            for (int cnames = 0; cnames <= 100; ++cnames)
+              {
+                check_cnames_failure (*paf, do_search, cnames, 0);
+                /* Now with NXDOMAIN responses.  */
+                check_cnames_failure (*paf, do_search, cnames, 255);
+              }
+
+            for (int cnames = 0; cnames <= 10; ++cnames)
+              for (int addresses = 1; addresses <= 10; ++addresses)
+                check (*paf, do_search, cnames, addresses);
+
+            /* The current implementation is limited to 47 aliases.
+               Addresses do not have such a limit.  */
+            check (*paf, do_search, 47, 60);
+          }
+    }
+
+  resolv_test_end (obj);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-resolv-byaddr.c glibc-20220830_c7509d49c4/resolv/tst-resolv-byaddr.c
--- glibc-2.36/resolv/tst-resolv-byaddr.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-resolv-byaddr.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,326 @@
+/* Test reverse DNS lookup.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <netdb.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/check_nss.h>
+#include <support/next_to_fault.h>
+#include <support/resolv_test.h>
+#include <support/support.h>
+
+#include "tst-resolv-maybe_insert_sig.h"
+
+/* QNAME format:
+
+   ADDRESSES.CNAMES...(lots of 0s)...8.b.d.0.1.0.0.2.ip6.arpa.
+   CNAMES|ADDRESSES.2.0.192.in-addr-arpa.
+
+   For the IPv4 reverse lookup, the address count is in the lower
+   bits.
+
+   CNAMES is the length of the CNAME chain, ADDRESSES is the number of
+   addresses in the response.  The special value 15 means that there
+   are no addresses, and the RCODE is NXDOMAIN.  */
+static void
+response (const struct resolv_response_context *ctx,
+          struct resolv_response_builder *b,
+          const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  TEST_COMPARE (qclass, C_IN);
+  TEST_COMPARE (qtype, T_PTR);
+
+  unsigned int addresses, cnames, bits;
+  char *tail;
+  if (strstr (qname, "ip6.arpa") != NULL
+      && sscanf (qname, "%x.%x.%ms", &addresses, &cnames, &tail) == 3)
+    TEST_COMPARE_STRING (tail, "\
+0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa");
+  else if (sscanf (qname, "%u.%ms", &bits, &tail) == 2)
+    {
+      TEST_COMPARE_STRING (tail, "2.0.192.in-addr.arpa");
+      addresses = bits & 0x0f;
+      cnames = bits >> 4;
+    }
+  else
+    FAIL_EXIT1 ("invalid QNAME: %s", qname);
+  free (tail);
+
+  int rcode;
+  if (addresses == 15)
+    {
+      /* Special case: Use no addresses with NXDOMAIN response.  */
+      rcode = ns_r_nxdomain;
+      addresses = 0;
+    }
+  else
+    rcode = 0;
+
+  struct resolv_response_flags flags = { .rcode = rcode };
+  resolv_response_init (b, flags);
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  maybe_insert_sig (b, qname);
+
+  /* Provide the requested number of CNAME records.  */
+  char *previous_name = (char *) qname;
+  for (int unique = 0; unique < cnames; ++unique)
+    {
+      resolv_response_open_record (b, previous_name, qclass, T_CNAME, 60);
+      char *new_name = xasprintf ("%d.alias.example", unique);
+      resolv_response_add_name (b, new_name);
+      resolv_response_close_record (b);
+
+      maybe_insert_sig (b, qname);
+
+      if (previous_name != qname)
+        free (previous_name);
+      previous_name = new_name;
+    }
+
+  for (int unique = 0; unique < addresses; ++unique)
+    {
+      resolv_response_open_record (b, previous_name, qclass, T_PTR, 60);
+      char *ptr = xasprintf ("unique-%d.cnames-%u.addresses-%u.example",
+                             unique, cnames, addresses);
+      resolv_response_add_name (b, ptr);
+      free (ptr);
+      resolv_response_close_record (b);
+    }
+
+  if (previous_name != qname)
+    free (previous_name);
+}
+
+/* Used to check that gethostbyaddr_r does not write past the buffer
+   end.  */
+static struct support_next_to_fault ntf;
+
+/* Perform a gethostbyaddr call and check the result.  */
+static void
+check_gethostbyaddr (const char *address, const char *expected)
+{
+  unsigned char bytes[16];
+  unsigned int byteslen;
+  int family;
+  if (strchr (address, ':') != NULL)
+    {
+      family = AF_INET6;
+      byteslen = 16;
+    }
+  else
+    {
+      family = AF_INET;
+      byteslen = 4;
+    }
+  TEST_COMPARE (inet_pton (family, address, bytes), 1);
+
+  struct hostent *e = gethostbyaddr (bytes, byteslen, family);
+  check_hostent (address, e, expected);
+
+  if (e == NULL)
+    return;
+
+  /* Try gethostbyaddr_r with increasing sizes until success.  First
+     compute a reasonable minimum buffer size, to avoid many pointless
+     attempts.  */
+  size_t minimum_size = strlen (e->h_name);
+  for (int i = 0; e->h_addr_list[i] != NULL; ++i)
+    minimum_size += e->h_length + sizeof (char *);
+  for (int i = 0; e->h_aliases[i] != NULL; ++i)
+    minimum_size += strlen (e->h_aliases[i]) + 1 + sizeof (char *);
+
+  /* Gradually increase the size until success.  */
+  for (size_t size = minimum_size; size < ntf.length; ++size)
+    {
+      struct hostent result;
+      int herrno;
+      int ret = gethostbyaddr_r (bytes, byteslen, family, &result,
+                                 ntf.buffer + ntf.length - size, size,
+                                 &e, &herrno);
+      if (ret == ERANGE)
+        /* Retry with larger size.  */
+        TEST_COMPARE (herrno, NETDB_INTERNAL);
+      else if (ret == 0)
+        {
+         TEST_VERIFY (size > minimum_size);
+         check_hostent (address, e, expected);
+         return;
+        }
+      else
+        FAIL_EXIT1 ("Unexpected gethostbyaddr_r failure: %d", ret);
+    }
+
+  FAIL_EXIT1 ("gethostbyaddr_r always failed for: %s", address);
+}
+
+/* Perform a getnameinfo call and check the result.  */
+static void
+check_getnameinfo (const char *address, const char *expected)
+{
+  struct sockaddr_in sin = { };
+  struct sockaddr_in6 sin6 = { };
+  void *sa;
+  socklen_t salen;
+  if (strchr (address, ':') != NULL)
+    {
+      sin6.sin6_family = AF_INET6;
+      TEST_COMPARE (inet_pton (AF_INET6, address, &sin6.sin6_addr), 1);
+      sin6.sin6_port = htons (80);
+      sa = &sin6;
+      salen = sizeof (sin6);
+    }
+  else
+    {
+      sin.sin_family = AF_INET;
+      TEST_COMPARE (inet_pton (AF_INET, address, &sin.sin_addr), 1);
+      sin.sin_port = htons (80);
+      sa = &sin;
+      salen = sizeof (sin);
+    }
+
+  char host[64];
+  char service[64];
+  int ret = getnameinfo (sa, salen, host,
+                         sizeof (host), service, sizeof (service),
+                         NI_NAMEREQD | NI_NUMERICSERV);
+  switch (ret)
+    {
+    case 0:
+      TEST_COMPARE_STRING (host, expected);
+      TEST_COMPARE_STRING (service, "80");
+      break;
+    case EAI_SYSTEM:
+      TEST_COMPARE_STRING (strerror (errno), expected);
+      break;
+    default:
+      TEST_COMPARE_STRING (gai_strerror (ret), expected);
+    }
+}
+
+static int
+do_test (void)
+{
+  /* Some reasonably upper bound for the maximum response size.  */
+  ntf = support_next_to_fault_allocate (4096);
+
+  struct resolv_test *obj = resolv_test_start
+    ((struct resolv_redirect_config)
+     {
+       .response_callback = response
+     });
+
+  for (int do_insert_sig = 0; do_insert_sig < 2; ++do_insert_sig)
+    {
+      insert_sig = do_insert_sig;
+
+      /* No PTR record, RCODE=0.  */
+      check_gethostbyaddr ("192.0.2.0", "error: NO_RECOVERY\n");
+      check_getnameinfo ("192.0.2.0", "Name or service not known");
+      check_gethostbyaddr ("192.0.2.16", "error: NO_RECOVERY\n");
+      check_getnameinfo ("192.0.2.16", "Name or service not known");
+      check_gethostbyaddr ("192.0.2.32", "error: NO_RECOVERY\n");
+      check_getnameinfo ("192.0.2.32", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::", "error: NO_RECOVERY\n");
+      check_getnameinfo ("2001:db8::", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::10", "error: NO_RECOVERY\n");
+      check_getnameinfo ("2001:db8::10", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::20", "error: NO_RECOVERY\n");
+      check_getnameinfo ("2001:db8::20", "Name or service not known");
+
+      /* No PTR record, NXDOMAIN.  */
+      check_gethostbyaddr ("192.0.2.15", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("192.0.2.15", "Name or service not known");
+      check_gethostbyaddr ("192.0.2.31", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("192.0.2.31", "Name or service not known");
+      check_gethostbyaddr ("192.0.2.47", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("192.0.2.47", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::f", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("2001:db8::f", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::1f", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("2001:db8::1f", "Name or service not known");
+      check_gethostbyaddr ("2001:db8::2f", "error: HOST_NOT_FOUND\n");
+      check_getnameinfo ("2001:db8::2f", "Name or service not known");
+
+      /* Actual response data.  Only the first PTR record is returned.  */
+      check_gethostbyaddr ("192.0.2.1",
+                           "name: unique-0.cnames-0.addresses-1.example\n"
+                           "address: 192.0.2.1\n");
+      check_getnameinfo ("192.0.2.1",
+                         "unique-0.cnames-0.addresses-1.example");
+      check_gethostbyaddr ("192.0.2.17",
+                           "name: unique-0.cnames-1.addresses-1.example\n"
+                           "address: 192.0.2.17\n");
+      check_getnameinfo ("192.0.2.17",
+                         "unique-0.cnames-1.addresses-1.example");
+      check_gethostbyaddr ("192.0.2.18",
+                           "name: unique-0.cnames-1.addresses-2.example\n"
+                           "address: 192.0.2.18\n");
+      check_getnameinfo ("192.0.2.18",
+                         "unique-0.cnames-1.addresses-2.example");
+      check_gethostbyaddr ("192.0.2.33",
+                           "name: unique-0.cnames-2.addresses-1.example\n"
+                           "address: 192.0.2.33\n");
+      check_getnameinfo ("192.0.2.33",
+                         "unique-0.cnames-2.addresses-1.example");
+      check_gethostbyaddr ("192.0.2.34",
+                           "name: unique-0.cnames-2.addresses-2.example\n"
+                           "address: 192.0.2.34\n");
+      check_getnameinfo ("192.0.2.34",
+                         "unique-0.cnames-2.addresses-2.example");
+
+      /* Same for IPv6 addresses.  */
+      check_gethostbyaddr ("2001:db8::1",
+                           "name: unique-0.cnames-0.addresses-1.example\n"
+                           "address: 2001:db8::1\n");
+      check_getnameinfo ("2001:db8::1",
+                         "unique-0.cnames-0.addresses-1.example");
+      check_gethostbyaddr ("2001:db8::11",
+                           "name: unique-0.cnames-1.addresses-1.example\n"
+                           "address: 2001:db8::11\n");
+      check_getnameinfo ("2001:db8::11",
+                         "unique-0.cnames-1.addresses-1.example");
+      check_gethostbyaddr ("2001:db8::12",
+                           "name: unique-0.cnames-1.addresses-2.example\n"
+                           "address: 2001:db8::12\n");
+      check_getnameinfo ("2001:db8::12",
+                         "unique-0.cnames-1.addresses-2.example");
+      check_gethostbyaddr ("2001:db8::21",
+                           "name: unique-0.cnames-2.addresses-1.example\n"
+                           "address: 2001:db8::21\n");
+      check_getnameinfo ("2001:db8::21",
+                         "unique-0.cnames-2.addresses-1.example");
+      check_gethostbyaddr ("2001:db8::22",
+                           "name: unique-0.cnames-2.addresses-2.example\n"
+                           "address: 2001:db8::22\n");
+      check_getnameinfo ("2001:db8::22",
+                         "unique-0.cnames-2.addresses-2.example");
+    }
+
+  resolv_test_end (obj);
+
+  support_next_to_fault_free (&ntf);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-resolv-invalid-cname.c glibc-20220830_c7509d49c4/resolv/tst-resolv-invalid-cname.c
--- glibc-2.36/resolv/tst-resolv-invalid-cname.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-resolv-invalid-cname.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,406 @@
+/* Test handling of CNAMEs with non-host domain names (bug 12154).
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <netdb.h>
+#include <resolv.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/check_nss.h>
+#include <support/resolv_test.h>
+#include <support/support.h>
+#include <support/xmemstream.h>
+
+/* Query strings describe the CNAME chain in the response.  They have
+   the format "bitsBITS.countCOUNT.example.", where BITS and COUNT are
+   replaced by unsigned decimal numbers.  COUNT is the number of CNAME
+   records in the response.  BITS has two bits for each CNAME record,
+   describing a special prefix that is added to that CNAME.
+
+   0: No special leading label.
+   1: Starting with "*.".
+   2: Starting with "-x.".
+   3: Starting with "star.*.".
+
+   The first CNAME in the response using the two least significant
+   bits.
+
+   For PTR queries, the QNAME format is different, it is either
+   COUNT.BITS.168.192.in-addr.arpa. (with BITS and COUNT still
+   decimal), or:
+
+COUNT.BITS0.BITS1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa.
+
+   where BITS and COUNT are hexadecimal.  */
+
+static void
+response (const struct resolv_response_context *ctx,
+          struct resolv_response_builder *b,
+          const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  TEST_COMPARE (qclass, C_IN);
+
+  /* The only other query type besides A is PTR.  */
+  if (qtype != T_A && qtype != T_AAAA)
+    TEST_COMPARE (qtype, T_PTR);
+
+  unsigned int bits, bits1, count;
+  char *tail = NULL;
+  if (sscanf (qname, "bits%u.count%u.%ms", &bits, &count, &tail) == 3)
+    TEST_COMPARE_STRING (tail, "example");
+  else if (strstr (qname, "in-addr.arpa") != NULL
+           && sscanf (qname, "%u.%u.%ms", &bits, &count, &tail) == 3)
+    TEST_COMPARE_STRING (tail, "168.192.in-addr.arpa");
+  else if (sscanf (qname, "%x.%x.%x.%ms", &bits, &bits1, &count, &tail) == 4)
+    {
+      TEST_COMPARE_STRING (tail, "\
+0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa");
+      bits |= bits1 << 4;
+    }
+  else
+    FAIL_EXIT1 ("invalid QNAME: %s\n", qname);
+  free (tail);
+
+  struct resolv_response_flags flags = {};
+  resolv_response_init (b, flags);
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+
+  /* Provide the requested number of CNAME records.  */
+  char *previous_name = (char *) qname;
+  unsigned int original_bits = bits;
+  for (int unique = 0; unique < count; ++unique)
+    {
+      resolv_response_open_record (b, previous_name, qclass, T_CNAME, 60);
+
+      static const char bits_to_prefix[4][8] = { "", "*.", "-x.", "star.*." };
+      char *new_name = xasprintf ("%sunique%d.example",
+                                  bits_to_prefix[bits & 3], unique);
+      bits >>= 2;
+      resolv_response_add_name (b, new_name);
+      resolv_response_close_record (b);
+
+      if (previous_name != qname)
+        free (previous_name);
+      previous_name = new_name;
+    }
+
+  /* Actual answer record.  */
+  resolv_response_open_record (b, previous_name, qclass, qtype, 60);
+  switch (qtype)
+    {
+    case T_A:
+      {
+        char ipv4[4] = {192, 168, count, original_bits};
+        resolv_response_add_data (b, &ipv4, sizeof (ipv4));
+      }
+      break;
+    case T_AAAA:
+      {
+        char ipv6[16] =
+          {
+            0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            count, original_bits
+          };
+        resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+      }
+      break;
+
+    case T_PTR:
+      {
+        char *name = xasprintf ("bits%u.count%u.example",
+                                original_bits, count);
+        resolv_response_add_name (b, name);
+        free (name);
+      }
+      break;
+    }
+  resolv_response_close_record (b);
+
+  if (previous_name != qname)
+    free (previous_name);
+}
+
+/* Controls which name resolution function is invoked.  */
+enum test_mode
+  {
+    byname,                     /* gethostbyname.  */
+    byname2,                    /* gethostbyname2.  */
+    gai,                        /* getaddrinfo without AI_CANONNAME.  */
+    gai_canon,                  /* getaddrinfo with AI_CANONNAME.  */
+
+    test_mode_num               /* Number of enum values.  */
+  };
+
+static const char *
+test_mode_to_string (enum test_mode mode)
+{
+  switch (mode)
+    {
+    case byname:
+      return "byname";
+    case byname2:
+      return "byname2";
+    case gai:
+      return "gai";
+    case gai_canon:
+      return "gai_canon";
+    case test_mode_num:
+      break;                    /* Report error below.  */
+    }
+  FAIL_EXIT1 ("invalid test_mode: %d", mode);
+}
+
+/* Append the name and aliases to OUT.  */
+static void
+append_names (FILE *out, const char *qname, int bits, int count,
+              enum test_mode mode)
+{
+  /* Largest valid index which has a corresponding zero in bits
+     (meaning a syntactically valid CNAME).  */
+  int last_valid_cname = -1;
+
+  for (int i = 0; i < count; ++i)
+    if ((bits & (3 << (i * 2))) == 0)
+      last_valid_cname = i;
+
+  if (mode != gai)
+    {
+      const char *label;
+      if (mode == gai_canon)
+        label = "canonname";
+      else
+        label = "name";
+      if (last_valid_cname >= 0)
+        fprintf (out, "%s: unique%d.example\n", label, last_valid_cname);
+      else
+        fprintf (out, "%s: %s\n", label, qname);
+    }
+
+  if (mode == byname || mode == byname2)
+    {
+      if (last_valid_cname >= 0)
+        fprintf (out, "alias: %s\n", qname);
+      for (int i = 0; i < count; ++i)
+        {
+          if ((bits & (3 << (i * 2))) == 0 && i != last_valid_cname)
+            fprintf (out, "alias: unique%d.example\n", i);
+        }
+    }
+}
+
+/* Append the address information to OUT.  */
+static void
+append_addresses (FILE *out, int af, int bits, int count, enum test_mode mode)
+{
+  int last = count * 256 + bits;
+  if (mode == gai || mode == gai_canon)
+    {
+      if (af == AF_INET || af == AF_UNSPEC)
+        fprintf (out, "address: STREAM/TCP 192.168.%d.%d 80\n", count, bits);
+      if (af == AF_INET6 || af == AF_UNSPEC)
+        {
+          if (last == 0)
+            fprintf (out, "address: STREAM/TCP 2001:db8:: 80\n");
+          else
+            fprintf (out, "address: STREAM/TCP 2001:db8::%x 80\n", last);
+        }
+    }
+  else
+    {
+      TEST_VERIFY (af != AF_UNSPEC);
+      if (af == AF_INET)
+        fprintf (out, "address: 192.168.%d.%d\n", count, bits);
+      if (af == AF_INET6)
+        {
+          if (last == 0)
+            fprintf (out, "address: 2001:db8::\n");
+          else
+            fprintf (out, "address: 2001:db8::%x\n", last);
+        }
+    }
+}
+
+/* Perform one test using a forward lookup.  */
+static void
+check_forward (int af, int bits, int count, enum test_mode mode)
+{
+  char *qname = xasprintf ("bits%d.count%d.example", bits, count);
+  char *label = xasprintf ("af=%d bits=%d count=%d mode=%s qname=%s",
+                           af, bits, count, test_mode_to_string (mode), qname);
+
+  struct xmemstream expected;
+  xopen_memstream (&expected);
+  if (mode == gai_canon)
+    fprintf (expected.out, "flags: AI_CANONNAME\n");
+  append_names (expected.out, qname, bits, count, mode);
+  append_addresses (expected.out, af, bits, count, mode);
+  xfclose_memstream (&expected);
+
+  if (mode == gai || mode == gai_canon)
+    {
+      struct addrinfo *ai;
+      struct addrinfo hints =
+        {
+          .ai_family = af,
+          .ai_socktype = SOCK_STREAM,
+        };
+      if (mode == gai_canon)
+        hints.ai_flags |= AI_CANONNAME;
+      int ret = getaddrinfo (qname, "80", &hints, &ai);
+      check_addrinfo (label, ai, ret, expected.buffer);
+      if (ret == 0)
+        freeaddrinfo (ai);
+    }
+  else
+    {
+      struct hostent *e;
+      if (mode == gai)
+        {
+          TEST_COMPARE (af, AF_INET);
+          e = gethostbyname (qname);
+        }
+      else
+        {
+          if (af != AF_INET)
+            TEST_COMPARE (af, AF_INET6);
+          e = gethostbyname2 (qname, af);
+        }
+      check_hostent (label, e, expected.buffer);
+    }
+
+  free (expected.buffer);
+  free (label);
+  free (qname);
+}
+
+/* Perform one check using a reverse lookup.  */
+
+static void
+check_reverse (int af, int bits, int count)
+{
+  TEST_VERIFY (af == AF_INET || af == AF_INET6);
+
+  char *label = xasprintf ("af=%d bits=%d count=%d", af, bits, count);
+  char *fqdn = xasprintf ("bits%d.count%d.example", bits, count);
+
+  struct xmemstream expected;
+  xopen_memstream (&expected);
+  fprintf (expected.out, "name: %s\n", fqdn);
+  append_addresses (expected.out, af, bits, count, byname);
+  xfclose_memstream (&expected);
+
+  char addr[16] = { 0 };
+  socklen_t addrlen;
+  if (af == AF_INET)
+    {
+      addr[0] = 192;
+      addr[1] = 168;
+      addr[2] = count;
+      addr[3] = bits;
+      addrlen = 4;
+    }
+  else
+    {
+      addr[0] = 0x20;
+      addr[1] = 0x01;
+      addr[2] = 0x0d;
+      addr[3] = 0xb8;
+      addr[14] = count;
+      addr[15] = bits;
+      addrlen = 16;
+    }
+
+  struct hostent *e = gethostbyaddr (addr, addrlen, af);
+  check_hostent (label, e, expected.buffer);
+
+  /* getnameinfo check is different.  There is no generic check_*
+     function for it.  */
+  {
+    struct sockaddr_in sin = { };
+    struct sockaddr_in6 sin6 = { };
+    void *sa;
+    socklen_t salen;
+    if (af == AF_INET)
+      {
+        sin.sin_family = AF_INET;
+        memcpy (&sin.sin_addr, addr, addrlen);
+        sin.sin_port = htons (80);
+        sa = &sin;
+        salen = sizeof (sin);
+      }
+    else
+      {
+        sin6.sin6_family = AF_INET6;
+        memcpy (&sin6.sin6_addr, addr, addrlen);
+        sin6.sin6_port = htons (80);
+        sa = &sin6;
+        salen = sizeof (sin6);
+      }
+
+    char host[64];
+    char service[64];
+    int ret = getnameinfo (sa, salen, host,
+                           sizeof (host), service, sizeof (service),
+                           NI_NAMEREQD | NI_NUMERICSERV);
+    TEST_COMPARE (ret, 0);
+    TEST_COMPARE_STRING (host, fqdn);
+    TEST_COMPARE_STRING (service, "80");
+  }
+
+  free (expected.buffer);
+  free (fqdn);
+  free (label);
+}
+
+static int
+do_test (void)
+{
+  struct resolv_test *obj = resolv_test_start
+    ((struct resolv_redirect_config)
+     {
+       .response_callback = response
+     });
+
+  for (int count = 0; count <= 3; ++count)
+    for (int bits = 0; bits <= 1 << (count * 2); ++bits)
+      {
+        if (count > 0 && bits == count)
+          /* The last bits value is only checked if count == 0.  */
+          continue;
+
+        for (enum test_mode mode = 0; mode < test_mode_num; ++mode)
+          {
+            check_forward (AF_INET, bits, count, mode);
+            if (mode != byname)
+              check_forward (AF_INET6, bits, count, mode);
+            if (mode == gai || mode == gai_canon)
+              check_forward (AF_UNSPEC, bits, count, mode);
+          }
+
+        check_reverse (AF_INET, bits, count);
+        check_reverse (AF_INET6, bits, count);
+      }
+
+  resolv_test_end (obj);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/resolv/tst-resolv-maybe_insert_sig.h glibc-20220830_c7509d49c4/resolv/tst-resolv-maybe_insert_sig.h
--- glibc-2.36/resolv/tst-resolv-maybe_insert_sig.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/resolv/tst-resolv-maybe_insert_sig.h	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,32 @@
+/* Code snippet for optionally inserting ignored SIG records in resolver tests.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Set to true for an alternative pass that inserts (ignored) SIG
+   records.  This does not alter the response, so this property is not
+   encoded in the QNAME.  The variable needs to be volatile because
+   leaf attributes tell GCC that the response function is not
+   called.  */
+static volatile bool insert_sig;
+
+static void
+maybe_insert_sig (struct resolv_response_builder *b, const char *owner)
+{
+  resolv_response_open_record (b, owner, C_IN, T_SIG, 60);
+  resolv_response_add_data (b, "", 1);
+  resolv_response_close_record (b);
+}
diff -aurN glibc-2.36/scripts/build-many-glibcs.py glibc-20220830_c7509d49c4/scripts/build-many-glibcs.py
--- glibc-2.36/scripts/build-many-glibcs.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/scripts/build-many-glibcs.py	2022-08-31 07:16:42.000000000 +0200
@@ -789,11 +789,11 @@
 
     def checkout(self, versions):
         """Check out the desired component versions."""
-        default_versions = {'binutils': 'vcs-2.38',
+        default_versions = {'binutils': 'vcs-2.39',
                             'gcc': 'vcs-12',
                             'glibc': 'vcs-mainline',
                             'gmp': '6.2.1',
-                            'linux': '5.18',
+                            'linux': '5.19',
                             'mpc': '1.2.1',
                             'mpfr': '4.1.0',
                             'mig': 'vcs-mainline',
diff -aurN glibc-2.36/scripts/glibcelf.py glibc-20220830_c7509d49c4/scripts/glibcelf.py
--- glibc-2.36/scripts/glibcelf.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/scripts/glibcelf.py	2022-08-31 07:16:42.000000000 +0200
@@ -1158,5 +1158,24 @@
         self._stringtab[sh_link] = strtab
         return strtab
 
+def elf_hash(s):
+    """Computes the ELF hash of the string."""
+    acc = 0
+    for ch in s:
+        if type(ch) is not int:
+            ch = ord(ch)
+        acc = ((acc << 4) + ch) & 0xffffffff
+        top = acc & 0xf0000000
+        acc = (acc ^ (top >> 24)) & ~top
+    return acc
+
+def gnu_hash(s):
+    """Computes the GNU hash of the string."""
+    h = 5381
+    for ch in s:
+        if type(ch) is not int:
+            ch = ord(ch)
+        h = (h * 33 + ch) & 0xffffffff
+    return h
 
 __all__ = [name for name in dir() if name[0].isupper()]
diff -aurN glibc-2.36/scripts/glibcextract.py glibc-20220830_c7509d49c4/scripts/glibcextract.py
--- glibc-2.36/scripts/glibcextract.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/scripts/glibcextract.py	2022-08-31 07:16:42.000000000 +0200
@@ -17,6 +17,7 @@
 # License along with the GNU C Library; if not, see
 # <https://www.gnu.org/licenses/>.
 
+import collections
 import os.path
 import re
 import subprocess
@@ -173,3 +174,21 @@
             if not allow_extra_2:
                 ret = 1
     return ret
+
+CompileResult = collections.namedtuple("CompileResult", "returncode output")
+
+def compile_c_snippet(snippet, cc, extra_cc_args=''):
+    """Compile and return whether the SNIPPET can be build with CC along
+       EXTRA_CC_ARGS compiler flags.  Return a CompileResult with RETURNCODE
+       being 0 for success, or the failure value and the compiler output.
+    """
+    with tempfile.TemporaryDirectory() as temp_dir:
+        c_file_name = os.path.join(temp_dir, 'test.c')
+        obj_file_name = os.path.join(temp_dir, 'test.o')
+        with open(c_file_name, 'w') as c_file:
+            c_file.write(snippet + '\n')
+        cmd = cc.split() + extra_cc_args.split() + ['-c', '-o', obj_file_name,
+                c_file_name]
+        r = subprocess.run(cmd, check=False, stdout=subprocess.PIPE,
+                stderr=subprocess.STDOUT)
+        return CompileResult(r.returncode, r.stdout)
diff -aurN glibc-2.36/socket/Makefile glibc-20220830_c7509d49c4/socket/Makefile
--- glibc-2.36/socket/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/socket/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -34,6 +34,7 @@
 tests := \
   tst-accept4 \
   tst-sockopt \
+  tst-cmsghdr \
   # tests
 
 tests-internal := \
diff -aurN glibc-2.36/socket/tst-cmsghdr.c glibc-20220830_c7509d49c4/socket/tst-cmsghdr.c
--- glibc-2.36/socket/tst-cmsghdr.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/socket/tst-cmsghdr.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,56 @@
+/* Test ancillary data header creation.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/socket.h>
+#include <gnu/lib-names.h>
+#include <support/xdlfcn.h>
+#include <support/check.h>
+
+#define PAYLOAD "Hello, World!"
+
+/* CMSG_NXTHDR is a macro that calls an inline function defined in
+   bits/socket.h.  In case the function cannot be inlined, libc.so carries
+   a copy.  Both versions need to be tested.  */
+
+#define CMSG_NXTHDR_IMPL CMSG_NXTHDR
+#include "tst-cmsghdr-skeleton.c"
+#undef CMSG_NXTHDR_IMPL
+
+static struct cmsghdr * (* cmsg_nxthdr) (struct msghdr *, struct cmsghdr *);
+
+#define CMSG_NXTHDR_IMPL cmsg_nxthdr
+#include "tst-cmsghdr-skeleton.c"
+#undef CMSG_NXTHDR_IMPL
+
+static int
+do_test (void)
+{
+  static void *handle;
+
+  run_test_CMSG_NXTHDR ();
+
+  handle = xdlopen (LIBC_SO, RTLD_LAZY);
+  cmsg_nxthdr = (struct cmsghdr * (*) (struct msghdr *, struct cmsghdr *))
+                  xdlsym (handle, "__cmsg_nxthdr");
+
+  run_test_cmsg_nxthdr ();
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/socket/tst-cmsghdr-skeleton.c glibc-20220830_c7509d49c4/socket/tst-cmsghdr-skeleton.c
--- glibc-2.36/socket/tst-cmsghdr-skeleton.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/socket/tst-cmsghdr-skeleton.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,92 @@
+/* Test ancillary data header creation.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* We use the preprocessor to generate the function/macro tests instead of
+   using indirection because having all the macro expansions alongside
+   each other lets the compiler warn us about suspicious pointer
+   arithmetic across subsequent CMSG_{FIRST,NXT}HDR expansions.  */
+
+#include <stdint.h>
+
+#define RUN_TEST_CONCAT(suffix) run_test_##suffix
+#define RUN_TEST_FUNCNAME(suffix) RUN_TEST_CONCAT (suffix)
+
+static void
+RUN_TEST_FUNCNAME (CMSG_NXTHDR_IMPL) (void)
+{
+  struct msghdr m = {0};
+  struct cmsghdr *cmsg;
+  char cmsgbuf[3 * CMSG_SPACE (sizeof (PAYLOAD))] = {0};
+
+  m.msg_control = cmsgbuf;
+  m.msg_controllen = sizeof (cmsgbuf);
+
+  /* First header should point to the start of the buffer.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+
+  /* If the first header length consumes the entire buffer, there is no
+     space remaining for additional headers.  */
+  cmsg->cmsg_len = sizeof (cmsgbuf);
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg == NULL);
+
+  /* The first header length is so big, using it would cause an overflow.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+  cmsg->cmsg_len = SIZE_MAX;
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg == NULL);
+
+  /* The first header leaves just enough space to hold another header.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+  cmsg->cmsg_len = sizeof (cmsgbuf) - sizeof (struct cmsghdr);
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg != NULL);
+
+  /* The first header leaves space but not enough for another header.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+  cmsg->cmsg_len ++;
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg == NULL);
+
+  /* The second header leaves just enough space to hold another header.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+  cmsg->cmsg_len = CMSG_LEN (sizeof (PAYLOAD));
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg != NULL);
+  cmsg->cmsg_len = sizeof (cmsgbuf)
+                   - CMSG_SPACE (sizeof (PAYLOAD)) /* First header.  */
+                   - sizeof (struct cmsghdr);
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg != NULL);
+
+  /* The second header leaves space but not enough for another header.  */
+  cmsg = CMSG_FIRSTHDR (&m);
+  TEST_VERIFY_EXIT ((char *) cmsg == cmsgbuf);
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg != NULL);
+  cmsg->cmsg_len ++;
+  cmsg = CMSG_NXTHDR_IMPL (&m, cmsg);
+  TEST_VERIFY_EXIT (cmsg == NULL);
+
+  return;
+}
diff -aurN glibc-2.36/soft-fp/fixhfdi.c glibc-20220830_c7509d49c4/soft-fp/fixhfdi.c
--- glibc-2.36/soft-fp/fixhfdi.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/fixhfdi.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a IEEE half to 64bit signed integer
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+DItype
+__fixhfdi (HFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_H (A, a);
+  FP_TO_INT_H (r, A, DI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff -aurN glibc-2.36/soft-fp/fixhfsi.c glibc-20220830_c7509d49c4/soft-fp/fixhfsi.c
--- glibc-2.36/soft-fp/fixhfsi.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/fixhfsi.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a IEEE half to 32bit signed integer
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+SItype
+__fixhfsi (HFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_H (A, a);
+  FP_TO_INT_H (r, A, SI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff -aurN glibc-2.36/soft-fp/fixunshfdi.c glibc-20220830_c7509d49c4/soft-fp/fixunshfdi.c
--- glibc-2.36/soft-fp/fixunshfdi.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/fixunshfdi.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert IEEE half to 64bit unsigned integer
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+UDItype
+__fixunshfdi (HFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_H (A, a);
+  FP_TO_INT_H (r, A, DI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff -aurN glibc-2.36/soft-fp/fixunshfsi.c glibc-20220830_c7509d49c4/soft-fp/fixunshfsi.c
--- glibc-2.36/soft-fp/fixunshfsi.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/fixunshfsi.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert IEEE half to 32bit unsigned integer
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+USItype
+__fixunshfsi (HFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_H (A, a);
+  FP_TO_INT_H (r, A, SI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff -aurN glibc-2.36/soft-fp/floatdihf.c glibc-20220830_c7509d49c4/soft-fp/floatdihf.c
--- glibc-2.36/soft-fp/floatdihf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/floatdihf.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a 64bit signed integer to IEEE half
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+HFtype
+__floatdihf (DItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  HFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_H (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_H (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff -aurN glibc-2.36/soft-fp/floatsihf.c glibc-20220830_c7509d49c4/soft-fp/floatsihf.c
--- glibc-2.36/soft-fp/floatsihf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/floatsihf.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a 32bit signed integer to IEEE half
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+HFtype
+__floatsihf (SItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  HFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_H (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_H (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff -aurN glibc-2.36/soft-fp/floatundihf.c glibc-20220830_c7509d49c4/soft-fp/floatundihf.c
--- glibc-2.36/soft-fp/floatundihf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/floatundihf.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a 64bit unsigned integer to IEEE half.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+HFtype
+__floatundihf (UDItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  HFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_H (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_H (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff -aurN glibc-2.36/soft-fp/floatunsihf.c glibc-20220830_c7509d49c4/soft-fp/floatunsihf.c
--- glibc-2.36/soft-fp/floatunsihf.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/soft-fp/floatunsihf.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a 32bit unsigned integer to IEEE half.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "half.h"
+
+HFtype
+__floatunsihf (USItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_H (A);
+  HFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_H (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_H (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff -aurN glibc-2.36/stdio-common/Makefile glibc-20220830_c7509d49c4/stdio-common/Makefile
--- glibc-2.36/stdio-common/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/stdio-common/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -174,6 +174,7 @@
   tst-fwrite \
   tst-gets \
   tst-grouping \
+  tst-grouping2 \
   tst-long-dbl-fphex \
   tst-memstream-string \
   tst-obprintf \
@@ -295,6 +296,7 @@
 $(objpfx)scanf13.out: $(gen-locales)
 $(objpfx)test-vfprintf.out: $(gen-locales)
 $(objpfx)tst-grouping.out: $(gen-locales)
+$(objpfx)tst-grouping2.out: $(gen-locales)
 $(objpfx)tst-sprintf.out: $(gen-locales)
 $(objpfx)tst-sscanf.out: $(gen-locales)
 $(objpfx)tst-swprintf.out: $(gen-locales)
diff -aurN glibc-2.36/stdio-common/tst-grouping2.c glibc-20220830_c7509d49c4/stdio-common/tst-grouping2.c
--- glibc-2.36/stdio-common/tst-grouping2.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/stdio-common/tst-grouping2.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,39 @@
+/* Test printf with grouping and large width (bug 29530)
+   Copyright (C) 2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <locale.h>
+#include <stdio.h>
+#include <support/check.h>
+#include <support/support.h>
+
+static int
+do_test (void)
+{
+  const int field_width = 1000;
+  char buf[field_width + 1];
+
+  xsetlocale (LC_NUMERIC, "de_DE.UTF-8");
+
+  /* This used to crash in group_number.  */
+  TEST_COMPARE (sprintf (buf, "%'*d", field_width, 1000), field_width);
+  TEST_COMPARE_STRING (buf + field_width - 6, " 1.000");
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff -aurN glibc-2.36/stdlib/arc4random_uniform.c glibc-20220830_c7509d49c4/stdlib/arc4random_uniform.c
--- glibc-2.36/stdlib/arc4random_uniform.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/stdlib/arc4random_uniform.c	2022-08-31 07:16:42.000000000 +0200
@@ -17,38 +17,19 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <endian.h>
-#include <libc-lock.h>
 #include <stdlib.h>
 #include <sys/param.h>
 
-/* Return the number of bytes which cover values up to the limit.  */
-__attribute__ ((const))
-static uint32_t
-byte_count (uint32_t n)
-{
-  if (n < (1U << 8))
-    return 1;
-  else if (n < (1U << 16))
-    return 2;
-  else if (n < (1U << 24))
-    return 3;
-  else
-    return 4;
-}
+/* Return a uniformly distributed random number less than N.  The algorithm
+   calculates a mask being the lowest power of two bounding the upper bound
+   N, successively queries new random values, and rejects values outside of
+   the request range.
 
-/* Fill the lower bits of the result with randomness, according to the
-   number of bytes requested.  */
-static void
-random_bytes (uint32_t *result, uint32_t byte_count)
-{
-  *result = 0;
-  unsigned char *ptr = (unsigned char *) result;
-  if (__BYTE_ORDER == __BIG_ENDIAN)
-    ptr += 4 - byte_count;
-  __arc4random_buf (ptr, byte_count);
-}
+   For reject values, it also tries if the remaining entropy could fit on
+   the asked range after range adjustment.
 
+   The algorithm avoids modulo and divide operations, which might be costly
+   depending on the architecture.  */
 uint32_t
 __arc4random_uniform (uint32_t n)
 {
@@ -57,83 +38,33 @@
        only possible result for limit 1.  */
     return 0;
 
-  /* The bits variable serves as a source for bits.  Prefetch the
-     minimum number of bytes needed.  */
-  uint32_t count = byte_count (n);
-  uint32_t bits_length = count * CHAR_BIT;
-  uint32_t bits;
-  random_bytes (&bits, count);
-
   /* Powers of two are easy.  */
   if (powerof2 (n))
-    return bits & (n - 1);
+    return __arc4random () & (n - 1);
+
+  /* mask is the smallest power of 2 minus 1 number larger than n.  */
+  int z = __builtin_clz (n);
+  uint32_t mask = ~UINT32_C(0) >> z;
+  int bits = CHAR_BIT * sizeof (uint32_t) - z;
 
-  /* The general case.  This algorithm follows Jérémie Lumbroso,
-     Optimal Discrete Uniform Generation from Coin Flips, and
-     Applications (2013), who credits Donald E. Knuth and Andrew
-     C. Yao, The complexity of nonuniform random number generation
-     (1976), for solving the general case.
-
-     The implementation below unrolls the initialization stage of the
-     loop, where v is less than n.  */
-
-  /* Use 64-bit variables even though the intermediate results are
-     never larger than 33 bits.  This ensures the code is easier to
-     compile on 64-bit architectures.  */
-  uint64_t v;
-  uint64_t c;
-
-  /* Initialize v and c.  v is the smallest power of 2 which is larger
-     than n.*/
-  {
-    uint32_t log2p1 = 32 - __builtin_clz (n);
-    v = 1ULL << log2p1;
-    c = bits & (v - 1);
-    bits >>= log2p1;
-    bits_length -= log2p1;
-  }
-
-  /* At the start of the loop, c is uniformly distributed within the
-     half-open interval [0, v), and v < 2n < 2**33.  */
-  while (true)
+  while (1)
     {
-      if (v >= n)
-        {
-          /* If the candidate is less than n, accept it.  */
-          if (c < n)
-            /* c is uniformly distributed on [0, n).  */
-            return c;
-          else
-            {
-              /* c is uniformly distributed on [n, v).  */
-              v -= n;
-              c -= n;
-              /* The distribution was shifted, so c is uniformly
-                 distributed on [0, v) again.  */
-            }
-        }
-      /* v < n here.  */
-
-      /* Replenish the bit source if necessary.  */
-      if (bits_length == 0)
-        {
-          /* Overwrite the least significant byte.  */
-	  random_bytes (&bits, 1);
-	  bits_length = CHAR_BIT;
-        }
-
-      /* Double the range.  No overflow because v < n < 2**32.  */
-      v *= 2;
-      /* v < 2n here.  */
-
-      /* Extract a bit and append it to c.  c remains less than v and
-         thus 2**33.  */
-      c = (c << 1) | (bits & 1);
-      bits >>= 1;
-      --bits_length;
+      uint32_t value = __arc4random ();
 
-      /* At this point, c is uniformly distributed on [0, v) again,
-         and v < 2n < 2**33.  */
+      /* Return if the lower power of 2 minus 1 satisfy the condition.  */
+      uint32_t r = value & mask;
+      if (r < n)
+	return r;
+
+      /* Otherwise check if remaining bits of entropy provides fits in the
+	 bound.  */
+      for (int bits_left = z; bits_left >= bits; bits_left -= bits)
+	{
+	  value >>= bits;
+	  r = value & mask;
+	  if (r < n)
+	    return r;
+	}
     }
 }
 libc_hidden_def (__arc4random_uniform)
diff -aurN glibc-2.36/stdlib/fpioconst.h glibc-20220830_c7509d49c4/stdlib/fpioconst.h
--- glibc-2.36/stdlib/fpioconst.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/stdlib/fpioconst.h	2022-08-31 07:16:42.000000000 +0200
@@ -52,9 +52,12 @@
    - LDBL_MIN_EXP + 2)).  When _Float128 is enabled in libm and it is
    ABI-distinct from long double (e.g. on powerpc64le), we also need powers
    of 10 up to floor (log_2 (FLT128_MANT_DIG - FLT128_MIN_EXP + 2)).  */
-#define FPIOCONST_HAVE_EXTENDED_RANGE \
-  ((!defined __NO_LONG_DOUBLE_MATH && __LDBL_MAX_EXP__ > 1024) \
-   || __HAVE_DISTINCT_FLOAT128)
+#if (!defined __NO_LONG_DOUBLE_MATH && __LDBL_MAX_EXP__ > 1024) \
+    || __HAVE_DISTINCT_FLOAT128
+# define FPIOCONST_HAVE_EXTENDED_RANGE 1
+#else
+# define FPIOCONST_HAVE_EXTENDED_RANGE 0
+#endif
 
 #if FPIOCONST_HAVE_EXTENDED_RANGE
 # define FPIOCONST_POW10_ARRAY_SIZE	15
diff -aurN glibc-2.36/stdlib/tst-bz20544.c glibc-20220830_c7509d49c4/stdlib/tst-bz20544.c
--- glibc-2.36/stdlib/tst-bz20544.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/stdlib/tst-bz20544.c	2022-08-31 07:16:42.000000000 +0200
@@ -78,7 +78,7 @@
 static void
 test_one_fn (void (*test_fn) (void *))
 {
-  const char expected_error[] = "Assertion `func != NULL' failed.\n";
+  const char expected_error[] = "assertion failed: func != NULL\n";
   struct support_capture_subprocess result;
   result = support_capture_subprocess (test_fn, NULL);
   support_capture_subprocess_check (&result, "bz20544", -SIGABRT,
diff -aurN glibc-2.36/stdlib/Versions glibc-20220830_c7509d49c4/stdlib/Versions
--- glibc-2.36/stdlib/Versions	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/stdlib/Versions	2022-08-31 07:16:42.000000000 +0200
@@ -141,6 +141,8 @@
     arc4random_buf;
     arc4random_uniform;
   }
+  GLIBC_2.37 {
+  }
   GLIBC_PRIVATE {
     # functions which have an additional interface since they are
     # are cancelable.
diff -aurN glibc-2.36/sysdeps/aarch64/configure glibc-20220830_c7509d49c4/sysdeps/aarch64/configure
--- glibc-2.36/sysdeps/aarch64/configure	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/aarch64/configure	2022-08-31 07:16:42.000000000 +0200
@@ -303,7 +303,7 @@
 # Check if asm support armv8.2-a+sve
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for SVE support in assembler" >&5
 $as_echo_n "checking for SVE support in assembler... " >&6; }
-if ${libc_cv_asm_sve+:} false; then :
+if ${libc_cv_aarch64_sve_asm+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat > conftest.s <<\EOF
@@ -321,8 +321,8 @@
 fi
 rm -f conftest*
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_asm_sve" >&5
-$as_echo "$libc_cv_asm_sve" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_aarch64_sve_asm" >&5
+$as_echo "$libc_cv_aarch64_sve_asm" >&6; }
 if test $libc_cv_aarch64_sve_asm = yes; then
   $as_echo "#define HAVE_AARCH64_SVE_ASM 1" >>confdefs.h
 
diff -aurN glibc-2.36/sysdeps/aarch64/configure.ac glibc-20220830_c7509d49c4/sysdeps/aarch64/configure.ac
--- glibc-2.36/sysdeps/aarch64/configure.ac	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/aarch64/configure.ac	2022-08-31 07:16:42.000000000 +0200
@@ -88,7 +88,7 @@
 LIBC_CONFIG_VAR([aarch64-variant-pcs], [$libc_cv_aarch64_variant_pcs])
 
 # Check if asm support armv8.2-a+sve
-AC_CACHE_CHECK(for SVE support in assembler, libc_cv_asm_sve, [dnl
+AC_CACHE_CHECK([for SVE support in assembler], [libc_cv_aarch64_sve_asm], [dnl
 cat > conftest.s <<\EOF
         ptrue p0.b
 EOF
diff -aurN glibc-2.36/sysdeps/aarch64/start.S glibc-20220830_c7509d49c4/sysdeps/aarch64/start.S
--- glibc-2.36/sysdeps/aarch64/start.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/aarch64/start.S	2022-08-31 07:16:42.000000000 +0200
@@ -3,9 +3,26 @@
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -13,7 +30,7 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
+   License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
 #include <sysdep.h>
diff -aurN glibc-2.36/sysdeps/arc/start.S glibc-20220830_c7509d49c4/sysdeps/arc/start.S
--- glibc-2.36/sysdeps/arc/start.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/arc/start.S	2022-08-31 07:16:42.000000000 +0200
@@ -7,13 +7,30 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
+   License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
 #define __ASSEMBLY__ 1
diff -aurN glibc-2.36/sysdeps/arm/dl-machine.h glibc-20220830_c7509d49c4/sysdeps/arm/dl-machine.h
--- glibc-2.36/sysdeps/arm/dl-machine.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/arm/dl-machine.h	2022-08-31 07:16:42.000000000 +0200
@@ -227,6 +227,16 @@
 #define ARCH_LA_PLTEXIT arm_gnu_pltexit
 
 #ifdef RESOLVE_MAP
+/* Set NEW_VALUE based on V, and return true iff it overflows 24 bits.  */
+static inline bool set_new_value (Elf32_Addr *new_value, Elf32_Addr v,
+				  Elf32_Addr *const reloc_addr,
+				  Elf32_Sword addend)
+{
+  *new_value = v + addend - (Elf32_Addr) reloc_addr;
+  Elf32_Addr topbits = *new_value & 0xfe000000;
+  return topbits != 0xfe000000 && topbits != 0x00000000;
+}
+
 /* Handle a PC24 reloc, including the out-of-range case.  */
 static void
 relocate_pc24 (struct link_map *map, Elf32_Addr value,
@@ -234,15 +244,7 @@
 {
   Elf32_Addr new_value;
 
-  /* Set NEW_VALUE based on V, and return true iff it overflows 24 bits.  */
-  inline bool set_new_value (Elf32_Addr v)
-  {
-    new_value = v + addend - (Elf32_Addr) reloc_addr;
-    Elf32_Addr topbits = new_value & 0xfe000000;
-    return topbits != 0xfe000000 && topbits != 0x00000000;
-  }
-
-  if (set_new_value (value))
+  if (set_new_value (&new_value, value, reloc_addr, addend))
     {
       /* The PC-relative address doesn't fit in 24 bits!  */
 
@@ -271,7 +273,8 @@
           fix_offset = 0;
         }
 
-      if (set_new_value ((Elf32_Addr) fix_address))
+      if (set_new_value (&new_value, (Elf32_Addr) fix_address, reloc_addr,
+			 addend))
         _dl_signal_error (0, map->l_name, NULL,
                           "R_ARM_PC24 relocation out of range");
     }
@@ -447,96 +450,6 @@
     }
 }
 
-# ifndef RTLD_BOOTSTRAP
-static inline void
-__attribute__ ((always_inline))
-elf_machine_rela (struct link_map *map, struct r_scope_elem *scope[],
-                  const Elf32_Rela *reloc, const Elf32_Sym *sym,
-                  const struct r_found_version *version,
-		  void *const reloc_addr_arg, int skip_ifunc)
-{
-  Elf32_Addr *const reloc_addr = reloc_addr_arg;
-  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
-
-  if (__builtin_expect (r_type == R_ARM_RELATIVE, 0))
-    *reloc_addr = map->l_addr + reloc->r_addend;
-  else if (__builtin_expect (r_type == R_ARM_NONE, 0))
-    return;
-  else
-    {
-      const Elf32_Sym *const refsym = sym;
-      struct link_map *sym_map = RESOLVE_MAP (map, scope, &sym, version, r_type);
-      Elf32_Addr value = SYMBOL_ADDRESS (sym_map, sym, true);
-
-      if (sym != NULL
-	  && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0)
-	  && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
-	  && __builtin_expect (!skip_ifunc, 1))
-	value = elf_ifunc_invoke (value);
-
-      switch (r_type)
-	{
-	  /* Not needed for dl-conflict.c.  */
-	case R_ARM_COPY:
-	  if (sym == NULL)
-	    /* This can happen in trace mode if an object could not be
-	       found.  */
-	    break;
-	  if (sym->st_size > refsym->st_size
-	      || (GLRO(dl_verbose) && sym->st_size < refsym->st_size))
-	    {
-	      const char *strtab;
-
-	      strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
-	      _dl_error_printf ("\
-%s: Symbol `%s' has different size in shared object, consider re-linking\n",
-				RTLD_PROGNAME, strtab + refsym->st_name);
-	    }
-	  memcpy (reloc_addr_arg, (void *) value,
-		  MIN (sym->st_size, refsym->st_size));
-	  break;
-	case R_ARM_GLOB_DAT:
-	case R_ARM_JUMP_SLOT:
-	case R_ARM_ABS32:
-	  *reloc_addr = value + reloc->r_addend;
-	  break;
-	case R_ARM_PC24:
-          relocate_pc24 (map, value, reloc_addr, reloc->r_addend);
-	  break;
-#if !defined RTLD_BOOTSTRAP
-	case R_ARM_TLS_DTPMOD32:
-	  /* Get the information from the link map returned by the
-	     resolv function.  */
-	  if (sym_map != NULL)
-	    *reloc_addr = sym_map->l_tls_modid;
-	  break;
-
-	case R_ARM_TLS_DTPOFF32:
-	  *reloc_addr = (sym == NULL ? 0 : sym->st_value) + reloc->r_addend;
-	  break;
-
-	case R_ARM_TLS_TPOFF32:
-	  if (sym != NULL)
-	    {
-	      CHECK_STATIC_TLS (map, sym_map);
-	      *reloc_addr = (sym->st_value + sym_map->l_tls_offset
-			     + reloc->r_addend);
-	    }
-	  break;
-	case R_ARM_IRELATIVE:
-	  value = map->l_addr + reloc->r_addend;
-	  if (__glibc_likely (!skip_ifunc))
-	    value = ((Elf32_Addr (*) (int)) value) (GLRO(dl_hwcap));
-	  *reloc_addr = value;
-	  break;
-#endif
-	default:
-	  _dl_reloc_bad_type (map, r_type, 0);
-	  break;
-	}
-    }
-}
-# endif
 
 static inline void
 __attribute__ ((always_inline))
@@ -547,16 +460,6 @@
   *reloc_addr += l_addr;
 }
 
-# ifndef RTLD_BOOTSTRAP
-static inline void
-__attribute__ ((always_inline))
-elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
-			   void *const reloc_addr_arg)
-{
-  Elf32_Addr *const reloc_addr = reloc_addr_arg;
-  *reloc_addr = l_addr + reloc->r_addend;
-}
-# endif
 
 static inline void
 __attribute__ ((always_inline))
diff -aurN glibc-2.36/sysdeps/arm/dl-machine-rel.h glibc-20220830_c7509d49c4/sysdeps/arm/dl-machine-rel.h
--- glibc-2.36/sysdeps/arm/dl-machine-rel.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/arm/dl-machine-rel.h	2022-08-31 07:16:42.000000000 +0200
@@ -19,13 +19,8 @@
 #ifndef _DL_MACHINE_REL_H
 #define _DL_MACHINE_REL_H
 
-/* ARM never uses Elf32_Rela relocations for the dynamic linker.
-   Prelinked libraries may use Elf32_Rela though.  */
-#define ELF_MACHINE_NO_RELA defined RTLD_BOOTSTRAP
+#define ELF_MACHINE_NO_RELA 1
 #define ELF_MACHINE_NO_REL 0
-
-/* ARM never uses Elf32_Rela relocations for the dynamic linker.
-   Prelinked libraries may use Elf32_Rela though.  */
 #define ELF_MACHINE_PLT_REL 1
 
 #define PLTREL ElfW(Rel)
diff -aurN glibc-2.36/sysdeps/htl/pt-cond-timedwait.c glibc-20220830_c7509d49c4/sysdeps/htl/pt-cond-timedwait.c
--- glibc-2.36/sysdeps/htl/pt-cond-timedwait.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/htl/pt-cond-timedwait.c	2022-08-31 07:16:42.000000000 +0200
@@ -142,13 +142,15 @@
 
   __pthread_mutex_unlock (&self->cancel_lock);
 
-  /* Release MUTEX before blocking.  */
-  __pthread_mutex_unlock (mutex);
-
   /* Increase the waiter reference count.  Relaxed MO is sufficient because
-     we only need to synchronize when decrementing the reference count.  */
+     we only need to synchronize when decrementing the reference count.
+     We however need to have the mutex held to prevent concurrency with
+     a pthread_cond_destroy.  */
   atomic_fetch_add_relaxed (&cond->__wrefs, 2);
 
+  /* Release MUTEX before blocking.  */
+  __pthread_mutex_unlock (mutex);
+
   /* Block the thread.  */
   if (abstime != NULL)
     err = __pthread_timedblock (self, abstime, clock_id);
diff -aurN glibc-2.36/sysdeps/i386/dl-machine.h glibc-20220830_c7509d49c4/sysdeps/i386/dl-machine.h
--- glibc-2.36/sysdeps/i386/dl-machine.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/dl-machine.h	2022-08-31 07:16:42.000000000 +0200
@@ -437,153 +437,6 @@
     }
 }
 
-# ifndef RTLD_BOOTSTRAP
-static inline void
-__attribute__ ((always_inline))
-elf_machine_rela (struct link_map *map, struct r_scope_elem *scope[],
-		  const Elf32_Rela *reloc, const Elf32_Sym *sym,
-		  const struct r_found_version *version,
-		  void *const reloc_addr_arg, int skip_ifunc)
-{
-  Elf32_Addr *const reloc_addr = reloc_addr_arg;
-  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
-
-  if (ELF32_R_TYPE (reloc->r_info) == R_386_RELATIVE)
-    *reloc_addr = map->l_addr + reloc->r_addend;
-  else if (r_type != R_386_NONE)
-    {
-      const Elf32_Sym *const refsym = sym;
-      struct link_map *sym_map = RESOLVE_MAP (map, scope, &sym, version,
-					      r_type);
-      Elf32_Addr value = SYMBOL_ADDRESS (sym_map, sym, true);
-
-      if (sym != NULL
-	  && __glibc_likely (sym->st_shndx != SHN_UNDEF)
-	  && __glibc_unlikely (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC)
-	  && __glibc_likely (!skip_ifunc))
-	value = ((Elf32_Addr (*) (void)) value) ();
-
-      switch (ELF32_R_TYPE (reloc->r_info))
-	{
-	case R_386_SIZE32:
-	  /* Set to symbol size plus addend.  */
-	  value = sym->st_size;
-	  /* Fall through.  */
-	case R_386_GLOB_DAT:
-	case R_386_JMP_SLOT:
-	case R_386_32:
-	  *reloc_addr = value + reloc->r_addend;
-	  break;
-	  /* Not needed for dl-conflict.c.  */
-	case R_386_PC32:
-	  *reloc_addr = (value + reloc->r_addend - (Elf32_Addr) reloc_addr);
-	  break;
-
-	case R_386_TLS_DTPMOD32:
-	  /* Get the information from the link map returned by the
-	     resolv function.  */
-	  if (sym_map != NULL)
-	    *reloc_addr = sym_map->l_tls_modid;
-	  break;
-	case R_386_TLS_DTPOFF32:
-	  /* During relocation all TLS symbols are defined and used.
-	     Therefore the offset is already correct.  */
-	  *reloc_addr = (sym == NULL ? 0 : sym->st_value) + reloc->r_addend;
-	  break;
-	case R_386_TLS_DESC:
-	  {
-	    struct tlsdesc volatile *td =
-	      (struct tlsdesc volatile *)reloc_addr;
-
-#  ifndef RTLD_BOOTSTRAP
-	    if (!sym)
-	      {
-		td->arg = (void*)reloc->r_addend;
-		td->entry = _dl_tlsdesc_undefweak;
-	      }
-	    else
-#  endif
-	      {
-#  ifndef RTLD_BOOTSTRAP
-#   ifndef SHARED
-		CHECK_STATIC_TLS (map, sym_map);
-#   else
-		if (!TRY_STATIC_TLS (map, sym_map))
-		  {
-		    td->arg = _dl_make_tlsdesc_dynamic
-		      (sym_map, sym->st_value + reloc->r_addend);
-		    td->entry = _dl_tlsdesc_dynamic;
-		  }
-		else
-#   endif
-#  endif
-		  {
-		    td->arg = (void*)(sym->st_value - sym_map->l_tls_offset
-				      + reloc->r_addend);
-		    td->entry = _dl_tlsdesc_return;
-		  }
-	      }
-	  }
-	  break;
-	case R_386_TLS_TPOFF32:
-	  /* The offset is positive, backward from the thread pointer.  */
-	  /* We know the offset of object the symbol is contained in.
-	     It is a positive value which will be subtracted from the
-	     thread pointer.  To get the variable position in the TLS
-	     block we subtract the offset from that of the TLS block.  */
-	  if (sym != NULL)
-	    {
-	      CHECK_STATIC_TLS (map, sym_map);
-	      *reloc_addr = sym_map->l_tls_offset - sym->st_value
-			    + reloc->r_addend;
-	    }
-	  break;
-	case R_386_TLS_TPOFF:
-	  /* The offset is negative, forward from the thread pointer.  */
-	  /* We know the offset of object the symbol is contained in.
-	     It is a negative value which will be added to the
-	     thread pointer.  */
-	  if (sym != NULL)
-	    {
-	      CHECK_STATIC_TLS (map, sym_map);
-	      *reloc_addr = sym->st_value - sym_map->l_tls_offset
-			    + reloc->r_addend;
-	    }
-	  break;
-	case R_386_COPY:
-	  if (sym == NULL)
-	    /* This can happen in trace mode if an object could not be
-	       found.  */
-	    break;
-	  if (__glibc_unlikely (sym->st_size > refsym->st_size)
-	      || (__glibc_unlikely (sym->st_size < refsym->st_size)
-		  && GLRO(dl_verbose)))
-	    {
-	      const char *strtab;
-
-	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
-	      _dl_error_printf ("\
-%s: Symbol `%s' has different size in shared object, consider re-linking\n",
-				RTLD_PROGNAME, strtab + refsym->st_name);
-	    }
-	  memcpy (reloc_addr_arg, (void *) value,
-		  MIN (sym->st_size, refsym->st_size));
-	  break;
-	case R_386_IRELATIVE:
-	  value = map->l_addr + reloc->r_addend;
-	  if (__glibc_likely (!skip_ifunc))
-	    value = ((Elf32_Addr (*) (void)) value) ();
-	  *reloc_addr = value;
-	  break;
-	default:
-	  /* We add these checks in the version to relocate ld.so only
-	     if we are still debugging.  */
-	  _dl_reloc_bad_type (map, r_type, 0);
-	  break;
-	}
-    }
-}
-# endif	/* !RTLD_BOOTSTRAP */
 
 static inline void
 __attribute ((always_inline))
@@ -664,48 +517,4 @@
     _dl_reloc_bad_type (map, r_type, 1);
 }
 
-# ifndef RTLD_BOOTSTRAP
-
-static inline void
-__attribute__ ((always_inline))
-elf_machine_lazy_rela (struct link_map *map, struct r_scope_elem *scope[],
-		       Elf32_Addr l_addr, const Elf32_Rela *reloc,
-		       int skip_ifunc)
-{
-  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
-  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
-  if (__glibc_likely (r_type == R_386_JMP_SLOT))
-    ;
-  else if (__glibc_likely (r_type == R_386_TLS_DESC))
-    {
-      const Elf_Symndx symndx = ELFW (R_SYM) (reloc->r_info);
-      const ElfW (Sym) *symtab = (const void *)D_PTR (map, l_info[DT_SYMTAB]);
-      const ElfW (Sym) *sym = &symtab[symndx];
-      const struct r_found_version *version = NULL;
-
-      if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
-	{
-	  const ElfW (Half) *vernum =
-	    (const void *)D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
-	  version = &map->l_versions[vernum[symndx] & 0x7fff];
-	}
-
-      /* Always initialize TLS descriptors completely at load time, in
-	 case static TLS is allocated for it that requires locking.  */
-      elf_machine_rela (map, scope, reloc, sym, version, reloc_addr,
-			skip_ifunc);
-    }
-  else if (__glibc_unlikely (r_type == R_386_IRELATIVE))
-    {
-      Elf32_Addr value = map->l_addr + reloc->r_addend;
-      if (__glibc_likely (!skip_ifunc))
-	value = ((Elf32_Addr (*) (void)) value) ();
-      *reloc_addr = value;
-    }
-  else
-    _dl_reloc_bad_type (map, r_type, 1);
-}
-
-# endif	/* !RTLD_BOOTSTRAP */
-
 #endif /* RESOLVE_MAP */
diff -aurN glibc-2.36/sysdeps/i386/dl-machine-rel.h glibc-20220830_c7509d49c4/sysdeps/i386/dl-machine-rel.h
--- glibc-2.36/sysdeps/i386/dl-machine-rel.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/dl-machine-rel.h	2022-08-31 07:16:42.000000000 +0200
@@ -19,13 +19,8 @@
 #ifndef _DL_MACHINE_REL_H
 #define _DL_MACHINE_REL_H
 
-/* The i386 never uses Elf32_Rela relocations for the dynamic linker.
-   Prelinked libraries may use Elf32_Rela though.  */
-#define ELF_MACHINE_NO_RELA defined RTLD_BOOTSTRAP
+#define ELF_MACHINE_NO_RELA 1
 #define ELF_MACHINE_NO_REL 0
-
-/* The i386 never uses Elf32_Rela relocations for the dynamic linker.
-   Prelinked libraries may use Elf32_Rela though.  */
 #define ELF_MACHINE_PLT_REL 1
 
 #define PLTREL ElfW(Rel)
diff -aurN glibc-2.36/sysdeps/i386/i686/fpu/e_logl.S glibc-20220830_c7509d49c4/sysdeps/i386/i686/fpu/e_logl.S
--- glibc-2.36/sysdeps/i386/i686/fpu/e_logl.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/i686/fpu/e_logl.S	2022-08-31 07:16:42.000000000 +0200
@@ -43,7 +43,7 @@
 	fsubl	MO(one)		// x-1 : x : log(2)
 5:	fld	%st		// x-1 : x-1 : x : log(2)
 	fabs			// |x-1| : x-1 : x : log(2)
-	fld	MO(limit)	// 0.29 : |x-1| : x-1 : x : log(2)
+	fldl	MO(limit)	// 0.29 : |x-1| : x-1 : x : log(2)
 	fcomip	%st(1)		// |x-1| : x-1 : x : log(2)
 	fstp	%st(0)		// x-1 : x : log(2)
 	jc	2f
@@ -76,7 +76,7 @@
 	fsubl	MO(one)		// x-1 : x : log(2)
 	fld	%st		// x-1 : x-1 : x : log(2)
 	fabs			// |x-1| : x-1 : x : log(2)
-	fld	MO(limit)	// 0.29 : |x-1| : x-1 : x : log(2)
+	fldl	MO(limit)	// 0.29 : |x-1| : x-1 : x : log(2)
 	fcomip	%st(1)		// |x-1| : x-1 : x : log(2)
 	fstp	%st(0)		// x-1 : x : log(2)
 	jc	2b
diff -aurN glibc-2.36/sysdeps/i386/i686/multiarch/strcmp-ssse3.S glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/strcmp-ssse3.S
--- glibc-2.36/sysdeps/i386/i686/multiarch/strcmp-ssse3.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/strcmp-ssse3.S	2022-08-31 07:16:42.000000000 +0200
@@ -2141,8 +2141,8 @@
 	jbe	L(eq)
 #endif
 
-	movzx	7(%eax), %ecx
-	movzx	7(%edx), %eax
+	movzbl	7(%eax), %ecx
+	movzbl	7(%edx), %eax
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
 	movl	_nl_C_LC_CTYPE_tolower@GOTOFF+128*4(%ebx,%ecx,4), %ecx
@@ -2161,8 +2161,8 @@
 	cmp	$0, REM
 	jbe	L(eq)
 #endif
-	movzx	(%eax), %ecx
-	movzx	(%edx), %eax
+	movzbl	(%eax), %ecx
+	movzbl	(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2182,8 +2182,8 @@
 	cmp	$1, REM
 	jbe	L(eq)
 #endif
-	movzx	1(%eax), %ecx
-	movzx	1(%edx), %eax
+	movzbl	1(%eax), %ecx
+	movzbl	1(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2203,8 +2203,8 @@
 	cmp	$2, REM
 	jbe	L(eq)
 #endif
-	movzx	2(%eax), %ecx
-	movzx	2(%edx), %eax
+	movzbl	2(%eax), %ecx
+	movzbl	2(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2224,8 +2224,8 @@
 	cmp	$3, REM
 	jbe	L(eq)
 #endif
-	movzx	3(%eax), %ecx
-	movzx	3(%edx), %eax
+	movzbl	3(%eax), %ecx
+	movzbl	3(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2245,8 +2245,8 @@
 	cmp	$4, REM
 	jbe	L(eq)
 #endif
-	movzx	4(%eax), %ecx
-	movzx	4(%edx), %eax
+	movzbl	4(%eax), %ecx
+	movzbl	4(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2266,8 +2266,8 @@
 	cmp	$5, REM
 	jbe	L(eq)
 #endif
-	movzx	5(%eax), %ecx
-	movzx	5(%edx), %eax
+	movzbl	5(%eax), %ecx
+	movzbl	5(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2287,8 +2287,8 @@
 	cmp	$6, REM
 	jbe	L(eq)
 #endif
-	movzx	6(%eax), %ecx
-	movzx	6(%edx), %eax
+	movzbl	6(%eax), %ecx
+	movzbl	6(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
@@ -2337,8 +2337,8 @@
 	cmp	$7, REM
 	jbe	L(eq)
 #endif
-	movzx	7(%eax), %ecx
-	movzx	7(%edx), %eax
+	movzbl	7(%eax), %ecx
+	movzbl	7(%edx), %eax
 
 #if defined USE_AS_STRCASECMP_L || defined USE_AS_STRNCASECMP_L
 # ifdef PIC
diff -aurN glibc-2.36/sysdeps/i386/i686/multiarch/wcscpy-ssse3.S glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/wcscpy-ssse3.S
--- glibc-2.36/sysdeps/i386/i686/multiarch/wcscpy-ssse3.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/wcscpy-ssse3.S	2022-08-31 07:16:42.000000000 +0200
@@ -41,13 +41,13 @@
 	mov	STR1(%esp), %edx
 	mov	STR2(%esp), %ecx
 
-	cmp	$0, (%ecx)
+	cmpl	$0, (%ecx)
 	jz	L(ExitTail4)
-	cmp	$0, 4(%ecx)
+	cmpl	$0, 4(%ecx)
 	jz	L(ExitTail8)
-	cmp	$0, 8(%ecx)
+	cmpl	$0, 8(%ecx)
 	jz	L(ExitTail12)
-	cmp	$0, 12(%ecx)
+	cmpl	$0, 12(%ecx)
 	jz	L(ExitTail16)
 
 	PUSH	(%edi)
diff -aurN glibc-2.36/sysdeps/i386/i686/multiarch/wcslen-sse2.S glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/wcslen-sse2.S
--- glibc-2.36/sysdeps/i386/i686/multiarch/wcslen-sse2.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/i386/i686/multiarch/wcslen-sse2.S	2022-08-31 07:16:42.000000000 +0200
@@ -24,21 +24,21 @@
 ENTRY (__wcslen_sse2)
 	mov	STR(%esp), %edx
 
-	cmp	$0, (%edx)
+	cmpl	$0, (%edx)
 	jz	L(exit_tail0)
-	cmp	$0, 4(%edx)
+	cmpl	$0, 4(%edx)
 	jz	L(exit_tail1)
-	cmp	$0, 8(%edx)
+	cmpl	$0, 8(%edx)
 	jz	L(exit_tail2)
-	cmp	$0, 12(%edx)
+	cmpl	$0, 12(%edx)
 	jz	L(exit_tail3)
-	cmp	$0, 16(%edx)
+	cmpl	$0, 16(%edx)
 	jz	L(exit_tail4)
-	cmp	$0, 20(%edx)
+	cmpl	$0, 20(%edx)
 	jz	L(exit_tail5)
-	cmp	$0, 24(%edx)
+	cmpl	$0, 24(%edx)
 	jz	L(exit_tail6)
-	cmp	$0, 28(%edx)
+	cmpl	$0, 28(%edx)
 	jz	L(exit_tail7)
 
 	pxor	%xmm0, %xmm0
diff -aurN glibc-2.36/sysdeps/ieee754/ldbl-128/e_j1l.c glibc-20220830_c7509d49c4/sysdeps/ieee754/ldbl-128/e_j1l.c
--- glibc-2.36/sysdeps/ieee754/ldbl-128/e_j1l.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/ieee754/ldbl-128/e_j1l.c	2022-08-31 07:16:42.000000000 +0200
@@ -869,10 +869,13 @@
     {
       /* 0 <= x <= 2 */
       SET_RESTORE_ROUNDL (FE_TONEAREST);
+      xx = math_opt_barrier (xx);
+      x = math_opt_barrier (x);
       z = xx * xx;
       p = xx * neval (z, Y0_2N, NY0_2N) / deval (z, Y0_2D, NY0_2D);
       p = -TWOOPI / xx + p;
       p = TWOOPI * __ieee754_logl (x) * __ieee754_j1l (x) + p;
+      math_force_eval (p);
       return p;
     }
 
diff -aurN glibc-2.36/sysdeps/loongarch/dl-machine.h glibc-20220830_c7509d49c4/sysdeps/loongarch/dl-machine.h
--- glibc-2.36/sysdeps/loongarch/dl-machine.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/dl-machine.h	2022-08-31 07:16:42.000000000 +0200
@@ -166,8 +166,7 @@
     {
 
     case R_LARCH_JUMP_SLOT:
-    case __WORDSIZE == 64 ? R_LARCH_64:
-    R_LARCH_32:
+    case __WORDSIZE == 64 ? R_LARCH_64 : R_LARCH_32:
       *addr_field = value;
       break;
 
@@ -175,18 +174,15 @@
       break;
 
 #ifndef RTLD_BOOTSTRAP
-    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPMOD64:
-    R_LARCH_TLS_DTPMOD32:
+    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPMOD64 : R_LARCH_TLS_DTPMOD32:
       *addr_field = sym_map->l_tls_modid;
       break;
 
-    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPREL64:
-    R_LARCH_TLS_DTPREL32:
+    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPREL64 : R_LARCH_TLS_DTPREL32:
       *addr_field = TLS_DTPREL_VALUE (sym) + reloc->r_addend;
       break;
 
-    case __WORDSIZE == 64 ? R_LARCH_TLS_TPREL64:
-    R_LARCH_TLS_TPREL32:
+    case __WORDSIZE == 64 ? R_LARCH_TLS_TPREL64 : R_LARCH_TLS_TPREL32:
       CHECK_STATIC_TLS (map, sym_map);
       *addr_field = TLS_TPREL_VALUE (sym_map, sym) + reloc->r_addend;
       break;
diff -aurN glibc-2.36/sysdeps/loongarch/fpu/math-use-builtins-fmax.h glibc-20220830_c7509d49c4/sysdeps/loongarch/fpu/math-use-builtins-fmax.h
--- glibc-2.36/sysdeps/loongarch/fpu/math-use-builtins-fmax.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/fpu/math-use-builtins-fmax.h	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,10 @@
+#if __GNUC_PREREQ (13, 0)
+# define USE_FMAX_BUILTIN 1
+# define USE_FMAXF_BUILTIN 1
+#else
+# define USE_FMAX_BUILTIN 0
+# define USE_FMAXF_BUILTIN 0
+#endif
+
+#define USE_FMAXL_BUILTIN 0
+#define USE_FMAXF128_BUILTIN 0
diff -aurN glibc-2.36/sysdeps/loongarch/fpu/math-use-builtins-fmin.h glibc-20220830_c7509d49c4/sysdeps/loongarch/fpu/math-use-builtins-fmin.h
--- glibc-2.36/sysdeps/loongarch/fpu/math-use-builtins-fmin.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/fpu/math-use-builtins-fmin.h	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,10 @@
+#if __GNUC_PREREQ (13, 0)
+# define USE_FMIN_BUILTIN 1
+# define USE_FMINF_BUILTIN 1
+#else
+# define USE_FMIN_BUILTIN 0
+# define USE_FMINF_BUILTIN 0
+#endif
+
+#define USE_FMINL_BUILTIN 0
+#define USE_FMINF128_BUILTIN 0
diff -aurN glibc-2.36/sysdeps/loongarch/__longjmp.S glibc-20220830_c7509d49c4/sysdeps/loongarch/__longjmp.S
--- glibc-2.36/sysdeps/loongarch/__longjmp.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/__longjmp.S	2022-08-31 07:16:42.000000000 +0200
@@ -20,8 +20,15 @@
 #include <sys/asm.h>
 
 ENTRY (__longjmp)
+#ifdef PTR_MANGLE
+	REG_L t0, a0, 0*SZREG
+	PTR_DEMANGLE (ra, t0, t1)
+	REG_L t0, a0, 1*SZREG
+	PTR_DEMANGLE2 (sp, t0, t1)
+#else
 	REG_L ra, a0, 0*SZREG
 	REG_L sp, a0, 1*SZREG
+#endif
 	REG_L x,  a0, 2*SZREG
 	REG_L fp, a0, 3*SZREG
 	REG_L s0, a0, 4*SZREG
diff -aurN glibc-2.36/sysdeps/loongarch/setjmp.S glibc-20220830_c7509d49c4/sysdeps/loongarch/setjmp.S
--- glibc-2.36/sysdeps/loongarch/setjmp.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/setjmp.S	2022-08-31 07:16:42.000000000 +0200
@@ -29,8 +29,15 @@
 END (setjmp)
 
 ENTRY (__sigsetjmp)
+#ifdef PTR_MANGLE
+	PTR_MANGLE (t0, ra, t1)
+	REG_S t0, a0, 0*SZREG
+	PTR_MANGLE2 (t0, sp, t1)
+	REG_S t0, a0, 1*SZREG
+#else
 	REG_S ra, a0, 0*SZREG
 	REG_S sp, a0, 1*SZREG
+#endif
 	REG_S x,  a0, 2*SZREG
 	REG_S fp, a0, 3*SZREG
 	REG_S s0, a0, 4*SZREG
diff -aurN glibc-2.36/sysdeps/loongarch/start.S glibc-20220830_c7509d49c4/sysdeps/loongarch/start.S
--- glibc-2.36/sysdeps/loongarch/start.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/loongarch/start.S	2022-08-31 07:16:42.000000000 +0200
@@ -2,19 +2,35 @@
    Copyright (C) 2022 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
-
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
+   License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
 #define __ASSEMBLY__ 1
diff -aurN glibc-2.36/sysdeps/mach/hurd/bits/socket.h glibc-20220830_c7509d49c4/sysdeps/mach/hurd/bits/socket.h
--- glibc-2.36/sysdeps/mach/hurd/bits/socket.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/bits/socket.h	2022-08-31 07:16:42.000000000 +0200
@@ -249,6 +249,12 @@
 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
 #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
 
+/* Given a length, return the additional padding necessary such that
+   len + __CMSG_PADDING(len) == CMSG_ALIGN (len).  */
+#define __CMSG_PADDING(len) ((sizeof (size_t) \
+                              - ((len) & (sizeof (size_t) - 1))) \
+                             & (sizeof (size_t) - 1))
+
 extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
 				      struct cmsghdr *__cmsg) __THROW;
 #ifdef __USE_EXTERN_INLINES
@@ -258,18 +264,38 @@
 _EXTERN_INLINE struct cmsghdr *
 __NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
+  /* We may safely assume that __cmsg lies between __mhdr->msg_control and
+     __mhdr->msg_controllen because the user is required to obtain the first
+     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs
+     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet
+     trust the value of __cmsg->cmsg_len and therefore do not use it in any
+     pointer arithmetic until we check its value.  */
+
+  unsigned char * __msg_control_ptr = (unsigned char *) __mhdr->msg_control;
+  unsigned char * __cmsg_ptr = (unsigned char *) __cmsg;
+
+  size_t __size_needed = sizeof (struct cmsghdr)
+                         + __CMSG_PADDING (__cmsg->cmsg_len);
+
+  /* The current header is malformed, too small to be a full header.  */
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
     return (struct cmsghdr *) 0;
 
+  /* There isn't enough space between __cmsg and the end of the buffer to
+  hold the current cmsg *and* the next one.  */
+  if (((size_t)
+         (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr)
+       < __size_needed)
+      || ((size_t)
+            (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr
+             - __size_needed)
+          < __cmsg->cmsg_len))
+
+    return (struct cmsghdr *) 0;
+
+  /* Now, we trust cmsg_len and can use it to find the next header.  */
   __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
 			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
-					+ __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return (struct cmsghdr *) 0;
   return __cmsg;
 }
 #endif	/* Use `extern inline'.  */
diff -aurN glibc-2.36/sysdeps/mach/hurd/dl-sysdep.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/dl-sysdep.c
--- glibc-2.36/sysdeps/mach/hurd/dl-sysdep.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/dl-sysdep.c	2022-08-31 07:16:42.000000000 +0200
@@ -382,7 +382,7 @@
 __write (int fd, const void *buf, size_t nbytes)
 {
   error_t err;
-  mach_msg_type_number_t nwrote;
+  vm_size_t nwrote;
 
   assert (fd < _hurd_init_dtablesize);
 
@@ -415,7 +415,7 @@
     {
       char buf[total], *bufp = buf;
       error_t err;
-      mach_msg_type_number_t nwrote;
+      vm_size_t nwrote;
 
       for (i = 0; i < niov; ++i)
 	bufp = (memcpy (bufp, iov[i].iov_base, iov[i].iov_len)
diff -aurN glibc-2.36/sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c
--- glibc-2.36/sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c	2022-08-31 07:16:42.000000000 +0200
@@ -73,6 +73,10 @@
   if (abstime != NULL && ! valid_nanoseconds (abstime->tv_nsec))
     return EINVAL;
 
+  err = __pthread_mutex_checklocked (mutex);
+  if (err)
+    return err;
+
   /* Atomically enqueue our thread on the condition variable's queue of
      waiters, and mark our sigstate to indicate that `cancel_me' must be
      called to wake us up.  We must hold the sigstate lock while acquiring
@@ -99,6 +103,12 @@
   __pthread_spin_unlock (&cond->__lock);
   __spin_unlock (&ss->lock);
 
+  /* Increase the waiter reference count.  Relaxed MO is sufficient because
+     we only need to synchronize when decrementing the reference count.
+     We however need to have the mutex held to prevent concurrency with
+     a pthread_cond_destroy.  */
+  atomic_fetch_add_relaxed (&cond->__wrefs, 2);
+
   if (cancel)
     {
       /* Cancelled on entry.  Just leave the mutex locked.  */
@@ -111,10 +121,6 @@
       /* Release MUTEX before blocking.  */
       __pthread_mutex_unlock (mutex);
 
-  /* Increase the waiter reference count.  Relaxed MO is sufficient because
-     we only need to synchronize when decrementing the reference count.  */
-  atomic_fetch_add_relaxed (&cond->__wrefs, 2);
-
       /* Block the thread.  */
       if (abstime != NULL)
 	err = __pthread_timedblock (self, abstime, clock_id);
diff -aurN glibc-2.36/sysdeps/mach/hurd/i386/init-first.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/i386/init-first.c
--- glibc-2.36/sysdeps/mach/hurd/i386/init-first.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/i386/init-first.c	2022-08-31 07:16:42.000000000 +0200
@@ -42,6 +42,11 @@
 extern char **__libc_argv attribute_hidden;
 extern char **_dl_argv;
 
+#ifndef SHARED
+unsigned short __init1_desc;
+static tcbhead_t __init1_tcbhead;
+#endif
+
 /* Things that want to be run before _hurd_init or much anything else.
    Importantly, these are called before anything tries to use malloc.  */
 DEFINE_HOOK (_hurd_preinit_hook, (void));
@@ -95,8 +100,13 @@
   d = (void *) ++envp;
 
   if ((void *) d == argv[0])
-    /* No Hurd data block to process.  */
-    return;
+    {
+      /* No Hurd data block to process.  */
+#ifndef SHARED
+      __libc_enable_secure = 0;
+#endif
+      return;
+    }
 
 #ifndef SHARED
   __libc_enable_secure = d->flags & EXEC_SECURE;
@@ -238,6 +248,13 @@
   /* Initialize data structures so we can do RPCs.  */
   __mach_init ();
 
+#ifndef SHARED
+  /* In the static case, we need to set up TLS early so that the stack
+     protection guard can be read at gs:0x14 by the gcc-generated snippets.  */
+  _hurd_tls_init(&__init1_tcbhead);
+  asm ("movw %%gs,%w0" : "=m" (__init1_desc));
+#endif
+
   RUN_RELHOOK (_hurd_preinit_hook, ());
 }
 
@@ -280,6 +297,7 @@
    This poorly-named function is called by static-start.S,
    which should not exist at all.  */
 void
+inhibit_stack_protector
 _hurd_stack_setup (void)
 {
   intptr_t caller = (intptr_t) __builtin_return_address (0);
diff -aurN glibc-2.36/sysdeps/mach/hurd/i386/tls.h glibc-20220830_c7509d49c4/sysdeps/mach/hurd/i386/tls.h
--- glibc-2.36/sysdeps/mach/hurd/i386/tls.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/i386/tls.h	2022-08-31 07:16:42.000000000 +0200
@@ -49,7 +49,6 @@
   mach_port_t reply_port;      /* This thread's reply port.  */
   struct hurd_sigstate *_hurd_sigstate;
 } tcbhead_t;
-#endif
 
 /* Return tcbhead_t from a TLS segment descriptor.  */
 # define HURD_DESC_TLS(desc)						      \
@@ -60,10 +59,18 @@
   })
 
 /* Return 1 if TLS is not initialized yet.  */
+#ifndef SHARED
+extern unsigned short __init1_desc;
+#define __HURD_DESC_INITIAL(gs, ds) ((gs) == (ds) || (gs) == __init1_desc)
+#else
+#define __HURD_DESC_INITIAL(gs, ds) ((gs) == (ds))
+#endif
+
 #define __LIBC_NO_TLS()							      \
   ({ unsigned short ds, gs;						      \
      asm ("movw %%ds,%w0; movw %%gs,%w1" : "=q" (ds), "=q" (gs));	      \
-     __builtin_expect (ds == gs, 0); })
+     __builtin_expect(__HURD_DESC_INITIAL(gs, ds), 0); })
+#endif
 
 /* The TCB can have any size and the memory following the address the
    thread pointer points to is unspecified.  Allocate the TCB there.  */
diff -aurN glibc-2.36/sysdeps/mach/hurd/ptrace.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/ptrace.c
--- glibc-2.36/sysdeps/mach/hurd/ptrace.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/ptrace.c	2022-08-31 07:16:42.000000000 +0200
@@ -47,8 +47,11 @@
     {
       /* Read the pages containing the addressed range.  */
       error_t err;
+      mach_msg_type_number_t nread;
       *size = round_page (addr + data) - trunc_page (addr);
-      err = __vm_read (task, trunc_page (addr), *size, ourpage, size);
+      err = __vm_read (task, trunc_page (addr), *size, ourpage, &nread);
+      if (!err)
+	*size = nread;
       return err;
     }
 
diff -aurN glibc-2.36/sysdeps/mach/hurd/send.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/send.c
--- glibc-2.36/sysdeps/mach/hurd/send.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/send.c	2022-08-31 07:16:42.000000000 +0200
@@ -27,7 +27,7 @@
 __send (int fd, const void *buf, size_t n, int flags)
 {
   error_t err;
-  size_t wrote;
+  vm_size_t wrote;
   int cancel_oldtype;
 
   cancel_oldtype = LIBC_CANCEL_ASYNC();
diff -aurN glibc-2.36/sysdeps/mach/hurd/sendfile64.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendfile64.c
--- glibc-2.36/sysdeps/mach/hurd/sendfile64.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendfile64.c	2022-08-31 07:16:42.000000000 +0200
@@ -42,7 +42,7 @@
 					   count));
   if (err == 0)
     {
-      size_t nwrote;
+      vm_size_t nwrote;
       if (datalen == 0)
 	return 0;
       err = HURD_DPORT_USE (out_fd, __io_write (port, data, datalen,
diff -aurN glibc-2.36/sysdeps/mach/hurd/sendmsg.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendmsg.c
--- glibc-2.36/sysdeps/mach/hurd/sendmsg.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendmsg.c	2022-08-31 07:16:42.000000000 +0200
@@ -47,7 +47,7 @@
   } data = { .ptr = NULL };
   char data_buf[2048];
   mach_msg_type_number_t len;
-  mach_msg_type_number_t amount;
+  vm_size_t amount;
   int dealloc = 0;
   int socketrpc = 0;
   int i;
diff -aurN glibc-2.36/sysdeps/mach/hurd/sendto.c glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendto.c
--- glibc-2.36/sysdeps/mach/hurd/sendto.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/hurd/sendto.c	2022-08-31 07:16:42.000000000 +0200
@@ -37,7 +37,7 @@
 {
   addr_port_t aport = MACH_PORT_NULL;
   error_t err;
-  size_t wrote;
+  vm_size_t wrote;
 
   /* Get an address port for the desired destination address.  */
   error_t create_address_port (io_t port,
diff -aurN glibc-2.36/sysdeps/mach/_strerror.c glibc-20220830_c7509d49c4/sysdeps/mach/_strerror.c
--- glibc-2.36/sysdeps/mach/_strerror.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/_strerror.c	2022-08-31 07:16:42.000000000 +0200
@@ -40,7 +40,7 @@
 
   if (system > err_max_system || ! __mach_error_systems[system].bad_sub)
     {
-      __snprintf (buf, buflen, "%s: %d", _("Error in unknown error system: "),
+      __snprintf (buf, buflen, "%s%X", _("Error in unknown error system: "),
 		  errnum);
       return buf;
     }
diff -aurN glibc-2.36/sysdeps/mach/xpg-strerror.c glibc-20220830_c7509d49c4/sysdeps/mach/xpg-strerror.c
--- glibc-2.36/sysdeps/mach/xpg-strerror.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/mach/xpg-strerror.c	2022-08-31 07:16:42.000000000 +0200
@@ -51,7 +51,11 @@
   code = err_get_code (errnum);
 
   if (system > err_max_system || ! __mach_error_systems[system].bad_sub)
-    return EINVAL;
+    {
+      __snprintf (buf, buflen, "%s%X", _("Error in unknown error system: "),
+		  errnum);
+      return EINVAL;
+    }
 
   es = &__mach_error_systems[system];
 
@@ -62,11 +66,11 @@
   else
     estr = (const char *) _(es->subsystem[sub].codes[code]);
 
-  size_t estrlen = strlen (estr) + 1;
+  size_t estrlen = strlen (estr);
 
-  if (buflen < estrlen)
-    return ERANGE;
+  /* Terminate the string in any case.  */
+  if (buflen > 0)
+    *((char *) __mempcpy (buf, estr, MIN (buflen - 1, estrlen))) = '\0';
 
-  memcpy (buf, estr, estrlen);
-  return 0;
+  return buflen <= estrlen ? ERANGE : 0;
 }
diff -aurN glibc-2.36/sysdeps/nptl/gai_misc.h glibc-20220830_c7509d49c4/sysdeps/nptl/gai_misc.h
--- glibc-2.36/sysdeps/nptl/gai_misc.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/nptl/gai_misc.h	2022-08-31 07:16:42.000000000 +0200
@@ -81,9 +81,7 @@
 {
   sigset_t ss;
   sigemptyset (&ss);
-  int sigerr __attribute__ ((unused));
-  sigerr = __pthread_sigmask (SIG_SETMASK, &ss, NULL);
-  assert_perror (sigerr);
+  (void) __pthread_sigmask (SIG_SETMASK, &ss, NULL);
 }
 
 extern inline int
@@ -106,15 +104,12 @@
   sigset_t ss;
   sigset_t oss;
   sigfillset (&ss);
-  int sigerr __attribute__ ((unused));
-  sigerr = __pthread_sigmask (SIG_SETMASK, &ss, &oss);
-  assert_perror (sigerr);
+  (void) __pthread_sigmask (SIG_SETMASK, &ss, &oss);
 
   int ret = __pthread_create (threadp, &attr, tf, arg);
 
   /* Restore the signal mask.  */
-  sigerr = __pthread_sigmask (SIG_SETMASK, &oss, NULL);
-  assert_perror (sigerr);
+  (void) __pthread_sigmask (SIG_SETMASK, &oss, NULL);
 
   (void) __pthread_attr_destroy (&attr);
   return ret;
diff -aurN glibc-2.36/sysdeps/nptl/stdio-lock.h glibc-20220830_c7509d49c4/sysdeps/nptl/stdio-lock.h
--- glibc-2.36/sysdeps/nptl/stdio-lock.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/nptl/stdio-lock.h	2022-08-31 07:16:42.000000000 +0200
@@ -37,12 +37,18 @@
 #define _IO_lock_lock(_name) \
   do {									      \
     void *__self = THREAD_SELF;						      \
-    if ((_name).owner != __self)					      \
+    if (SINGLE_THREAD_P && (_name).owner == NULL)			      \
+      {									      \
+	(_name).lock = LLL_LOCK_INITIALIZER_LOCKED;			      \
+	(_name).owner = __self;						      \
+      }									      \
+    else if ((_name).owner != __self)					      \
       {									      \
 	lll_lock ((_name).lock, LLL_PRIVATE);				      \
-        (_name).owner = __self;						      \
+	(_name).owner = __self;						      \
       }									      \
-    ++(_name).cnt;							      \
+    else								      \
+      ++(_name).cnt;							      \
   } while (0)
 
 #define _IO_lock_trylock(_name) \
@@ -52,10 +58,7 @@
     if ((_name).owner != __self)					      \
       {									      \
         if (lll_trylock ((_name).lock) == 0)				      \
-          {								      \
-            (_name).owner = __self;					      \
-            (_name).cnt = 1;						      \
-          }								      \
+	  (_name).owner = __self;					      \
         else								      \
           __result = EBUSY;						      \
       }									      \
@@ -66,11 +69,18 @@
 
 #define _IO_lock_unlock(_name) \
   do {									      \
-    if (--(_name).cnt == 0)						      \
+    if (SINGLE_THREAD_P && (_name).cnt == 0)				      \
+      {									      \
+	(_name).owner = NULL;						      \
+	(_name).lock = 0;						      \
+      }									      \
+    else if ((_name).cnt == 0)						      \
       {									      \
-        (_name).owner = NULL;						      \
+	(_name).owner = NULL;						      \
 	lll_unlock ((_name).lock, LLL_PRIVATE);				      \
       }									      \
+    else								      \
+      --(_name).cnt;							      \
   } while (0)
 
 
diff -aurN glibc-2.36/sysdeps/or1k/start.S glibc-20220830_c7509d49c4/sysdeps/or1k/start.S
--- glibc-2.36/sysdeps/or1k/start.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/or1k/start.S	2022-08-31 07:16:42.000000000 +0200
@@ -7,15 +7,31 @@
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
 
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
 
 /* This is the canonical entry point, usually the first thing in the text
    segment.
diff -aurN glibc-2.36/sysdeps/posix/libc_fatal.c glibc-20220830_c7509d49c4/sysdeps/posix/libc_fatal.c
--- glibc-2.36/sysdeps/posix/libc_fatal.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/posix/libc_fatal.c	2022-08-31 07:16:42.000000000 +0200
@@ -54,7 +54,7 @@
 
 /* Abort with an error message.  */
 void
-__libc_message (enum __libc_message_action action, const char *fmt, ...)
+__libc_message (const char *fmt, ...)
 {
   va_list ap;
   int fd = -1;
@@ -123,36 +123,31 @@
 
       WRITEV_FOR_FATAL (fd, iov, nlist, total);
 
-      if ((action & do_abort))
+      total = (total + 1 + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      struct abort_msg_s *buf = __mmap (NULL, total,
+					PROT_READ | PROT_WRITE,
+					MAP_ANON | MAP_PRIVATE, -1, 0);
+      if (__glibc_likely (buf != MAP_FAILED))
 	{
-	  total = ((total + 1 + GLRO(dl_pagesize) - 1)
-		   & ~(GLRO(dl_pagesize) - 1));
-	  struct abort_msg_s *buf = __mmap (NULL, total,
-					    PROT_READ | PROT_WRITE,
-					    MAP_ANON | MAP_PRIVATE, -1, 0);
-	  if (__glibc_likely (buf != MAP_FAILED))
-	    {
-	      buf->size = total;
-	      char *wp = buf->msg;
-	      for (int cnt = 0; cnt < nlist; ++cnt)
-		wp = mempcpy (wp, iov[cnt].iov_base, iov[cnt].iov_len);
-	      *wp = '\0';
-
-	      /* We have to free the old buffer since the application might
-		 catch the SIGABRT signal.  */
-	      struct abort_msg_s *old = atomic_exchange_acq (&__abort_msg,
-							     buf);
-	      if (old != NULL)
-		__munmap (old, old->size);
-	    }
+	  buf->size = total;
+	  char *wp = buf->msg;
+	  for (int cnt = 0; cnt < nlist; ++cnt)
+	    wp = mempcpy (wp, iov[cnt].iov_base, iov[cnt].iov_len);
+	  *wp = '\0';
+
+	  /* We have to free the old buffer since the application might
+	     catch the SIGABRT signal.  */
+	  struct abort_msg_s *old = atomic_exchange_acq (&__abort_msg,
+							 buf);
+	  if (old != NULL)
+	    __munmap (old, old->size);
 	}
     }
 
   va_end (ap);
 
-  if ((action & do_abort))
-    /* Kill the application.  */
-    abort ();
+  /* Kill the application.  */
+  abort ();
 }
 
 
@@ -161,6 +156,6 @@
 {
   /* The loop is added only to keep gcc happy.  */
   while (1)
-    __libc_message (do_abort, "%s", message);
+    __libc_message ("%s", message);
 }
 libc_hidden_def (__libc_fatal)
diff -aurN glibc-2.36/sysdeps/posix/sysconf.c glibc-20220830_c7509d49c4/sysdeps/posix/sysconf.c
--- glibc-2.36/sysdeps/posix/sysconf.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/posix/sysconf.c	2022-08-31 07:16:42.000000000 +0200
@@ -37,13 +37,17 @@
 #define NEED_SPEC_ARRAY 0
 #include <posix-conf-vars.h>
 
-#define NEED_CHECK_SPEC \
-  (!defined _XBS5_ILP32_OFF32 || !defined _XBS5_ILP32_OFFBIG \
+#if !defined _XBS5_ILP32_OFF32 || !defined _XBS5_ILP32_OFFBIG \
    || !defined _XBS5_LP64_OFF64 || !defined _XBS5_LPBIG_OFFBIG \
    || !defined _POSIX_V6_ILP32_OFF32 || !defined _POSIX_V6_ILP32_OFFBIG \
    || !defined _POSIX_V6_LP64_OFF64 || !defined _POSIX_V6_LPBIG_OFFBIG \
    || !defined _POSIX_V7_ILP32_OFF32 || !defined _POSIX_V7_ILP32_OFFBIG \
-   || !defined _POSIX_V7_LP64_OFF64 || !defined _POSIX_V7_LPBIG_OFFBIG)
+   || !defined _POSIX_V7_LP64_OFF64 || !defined _POSIX_V7_LPBIG_OFFBIG
+# define NEED_CHECK_SPEC 1
+#else
+# define NEED_CHECK_SPEC 0
+#endif
+
 #if NEED_CHECK_SPEC
 static long int __sysconf_check_spec (const char *spec);
 #endif
diff -aurN glibc-2.36/sysdeps/posix/tempname.c glibc-20220830_c7509d49c4/sysdeps/posix/tempname.c
--- glibc-2.36/sysdeps/posix/tempname.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/posix/tempname.c	2022-08-31 07:16:42.000000000 +0200
@@ -181,13 +181,13 @@
 }
 
 static int
-try_dir (char *tmpl, void *flags _GL_UNUSED)
+try_dir (char *tmpl, _GL_UNUSED void *flags)
 {
   return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);
 }
 
 static int
-try_nocreate (char *tmpl, void *flags _GL_UNUSED)
+try_nocreate (char *tmpl, _GL_UNUSED void *flags)
 {
   struct_stat64 st;
 
diff -aurN glibc-2.36/sysdeps/s390/dl-procinfo.c glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo.c
--- glibc-2.36/sysdeps/s390/dl-procinfo.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo.c	2022-08-31 07:16:42.000000000 +0200
@@ -16,66 +16,10 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-/* This information must be kept in sync with the _DL_HWCAP_COUNT and
-   _DL_PLATFORM_COUNT definitions in procinfo.h.
-
-   If anything should be added here check whether the size of each string
-   is still ok with the given array size.
-
-   All the #ifdefs in the definitions are quite irritating but
-   necessary if we want to avoid duplicating the information.  There
-   are three different modes:
-
-   - PROCINFO_DECL is defined.  This means we are only interested in
-     declarations.
-
-   - PROCINFO_DECL is not defined:
-
-     + if SHARED is defined the file is included in an array
-       initializer.  The .element = { ... } syntax is needed.
-
-     + if SHARED is not defined a normal array initialization is
-       needed.
-  */
-
-#ifndef PROCINFO_CLASS
-# define PROCINFO_CLASS
-#endif
-
-#if !defined PROCINFO_DECL && defined SHARED
-  ._dl_s390_cap_flags
-#else
-PROCINFO_CLASS const char _dl_s390_cap_flags[23][9]
-#endif
-#ifndef PROCINFO_DECL
-= {
-     "esan3", "zarch", "stfle", "msa", "ldisp", "eimm", "dfp", "edat", "etf3eh",
-     "highgprs", "te", "vx", "vxd", "vxe", "gs", "vxe2", "vxp", "sort", "dflt",
-     "vxp2", "nnpa", "pcimio", "sie"
-  }
-#endif
-#if !defined SHARED || defined PROCINFO_DECL
-;
-#else
-,
-#endif
-
-#if !defined PROCINFO_DECL && defined SHARED
-  ._dl_s390_platforms
-#else
-PROCINFO_CLASS const char _dl_s390_platforms[11][7]
-#endif
-#ifndef PROCINFO_DECL
-= {
-    "g5", "z900", "z990", "z9-109", "z10", "z196", "zEC12", "z13", "z14", "z15",
-    "z16"
-  }
-#endif
-#if !defined SHARED || defined PROCINFO_DECL
-;
-#else
-,
-#endif
+/* The hwcap and platform strings are now in
+   sysdeps/s390/dl-procinfo-s390.c.  */
 
+/* Needed by sysdeps/unix/sysv/linux/dl-vdso-setup.c (as included from
+   sysdeps/generic/ldsodefs.h).  */
 #undef PROCINFO_DECL
 #undef PROCINFO_CLASS
diff -aurN glibc-2.36/sysdeps/s390/dl-procinfo.h glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo.h
--- glibc-2.36/sysdeps/s390/dl-procinfo.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo.h	2022-08-31 07:16:42.000000000 +0200
@@ -21,8 +21,10 @@
 #include <ldsodefs.h>
 
 #define _DL_HWCAP_COUNT 23
+extern const char _dl_s390_cap_flags[_DL_HWCAP_COUNT][9] attribute_hidden;
 
 #define _DL_PLATFORMS_COUNT	11
+extern const char _dl_s390_platforms[_DL_PLATFORMS_COUNT][7] attribute_hidden;
 
 /* The kernel provides up to 32 capability bits with elf_hwcap.  */
 #define _DL_FIRST_PLATFORM	32
@@ -78,7 +80,7 @@
 __attribute__ ((unused))
 _dl_hwcap_string (int idx)
 {
-  return GLRO(dl_s390_cap_flags)[idx];
+  return _dl_s390_cap_flags[idx];
 };
 
 static inline int
@@ -89,7 +91,7 @@
 
   for (i = 0; i < _DL_HWCAP_COUNT; i++)
     {
-      if (strcmp (str, GLRO(dl_s390_cap_flags)[i]) == 0)
+      if (strcmp (str, _dl_s390_cap_flags[i]) == 0)
 	return i;
     }
   return -1;
@@ -104,7 +106,7 @@
   if (str != NULL)
     for (i = 0; i < _DL_PLATFORMS_COUNT; ++i)
       {
-	if (strcmp (str, GLRO(dl_s390_platforms)[i]) == 0)
+	if (strcmp (str, _dl_s390_platforms[i]) == 0)
 	  return _DL_FIRST_PLATFORM + i;
       }
   return -1;
diff -aurN glibc-2.36/sysdeps/s390/dl-procinfo-s390.c glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo-s390.c
--- glibc-2.36/sysdeps/s390/dl-procinfo-s390.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/sysdeps/s390/dl-procinfo-s390.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,32 @@
+/* Data for s390 version of processor capability information.
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dl-procinfo.h>
+
+const char _dl_s390_cap_flags[_DL_HWCAP_COUNT][9] =
+  {
+    "esan3", "zarch", "stfle", "msa", "ldisp", "eimm", "dfp", "edat", "etf3eh",
+    "highgprs", "te", "vx", "vxd", "vxe", "gs", "vxe2", "vxp", "sort", "dflt",
+    "vxp2", "nnpa", "pcimio", "sie"
+  };
+
+const char _dl_s390_platforms[_DL_PLATFORMS_COUNT][7] =
+  {
+    "g5", "z900", "z990", "z9-109", "z10", "z196", "zEC12", "z13", "z14", "z15",
+    "z16"
+  };
diff -aurN glibc-2.36/sysdeps/s390/Makefile glibc-20220830_c7509d49c4/sysdeps/s390/Makefile
--- glibc-2.36/sysdeps/s390/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/s390/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -43,6 +43,8 @@
 endif
 
 ifeq ($(subdir),elf)
+sysdep-dl-routines += dl-procinfo-s390
+
 ifeq ($(build-shared),yes)
 tests += tst-dl-runtime-resolve-noaudit tst-dl-runtime-resolve-audit \
 	tst-dl-runtime-profile-noaudit
diff -aurN glibc-2.36/sysdeps/s390/multiarch/ifunc-impl-list.c glibc-20220830_c7509d49c4/sysdeps/s390/multiarch/ifunc-impl-list.c
--- glibc-2.36/sysdeps/s390/multiarch/ifunc-impl-list.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/s390/multiarch/ifunc-impl-list.c	2022-08-31 07:16:42.000000000 +0200
@@ -73,7 +73,9 @@
 __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
 			size_t max)
 {
-  size_t i = max;
+  /* If the architecture level set is high enough, no IFUNCs are used at all
+     and the variable i would be unused.  */
+  size_t i __attribute__ ((unused)) = max;
 
   /* Get hardware information.  */
   unsigned long int dl_hwcap = GLRO (dl_hwcap);
diff -aurN glibc-2.36/sysdeps/sparc/Makefile glibc-20220830_c7509d49c4/sysdeps/sparc/Makefile
--- glibc-2.36/sysdeps/sparc/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/sparc/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -1,9 +1,6 @@
 # The Sparc `long double' is a distinct type we support.
 long-double-fcts = yes
 
-pie-ccflag = -fPIE
-no-pie-ccflag = -fno-PIE
-
 ifeq ($(subdir),gmon)
 sysdep_routines += sparc-mcount
 endif
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/aarch64/bits/hwcap.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/aarch64/bits/hwcap.h
--- glibc-2.36/sysdeps/unix/sysv/linux/aarch64/bits/hwcap.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/aarch64/bits/hwcap.h	2022-08-31 07:16:42.000000000 +0200
@@ -78,3 +78,12 @@
 #define HWCAP2_AFP		(1 << 20)
 #define HWCAP2_RPRES		(1 << 21)
 #define HWCAP2_MTE3		(1 << 22)
+#define HWCAP2_SME		(1 << 23)
+#define HWCAP2_SME_I16I64	(1 << 24)
+#define HWCAP2_SME_F64F64	(1 << 25)
+#define HWCAP2_SME_I8I32	(1 << 26)
+#define HWCAP2_SME_F16F32	(1 << 27)
+#define HWCAP2_SME_B16F32	(1 << 28)
+#define HWCAP2_SME_F32F32	(1 << 29)
+#define HWCAP2_SME_FA64		(1 << 30)
+#define HWCAP2_WFXT		(1UL << 31)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/aarch64/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/aarch64/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/aarch64/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/aarch64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* Copyright (C) 2009-2022 Free Software Foundation, Inc.
-
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux-aarch64.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux-aarch64_be.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux-aarch64_ilp32.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux-aarch64_be_ilp32.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux.so.3", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux-armhf.so.3", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/alpha/brk_call.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/alpha/brk_call.h
--- glibc-2.36/sysdeps/unix/sysv/linux/alpha/brk_call.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/alpha/brk_call.h	2022-08-31 07:16:42.000000000 +0200
@@ -21,8 +21,7 @@
 {
   unsigned long int result = INTERNAL_SYSCALL_CALL (brk, addr);
   if (result == -ENOMEM)
-    /* Mimic the default error reporting behavior.  */
-    return addr;
-  else
-    return (void *) result;
+    /* Mimic the generic error reporting behavior.  */
+    result = INTERNAL_SYSCALL_CALL (brk, 0);
+  return (void *) result;
 }
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/alpha/sys/acct.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/alpha/sys/acct.h
--- glibc-2.36/sysdeps/unix/sysv/linux/alpha/sys/acct.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/alpha/sys/acct.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/* Copyright (C) 1996-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifndef _SYS_ACCT_H
-
-#define _SYS_ACCT_H	1
-#include <features.h>
-
-#include <bits/types/time_t.h>
-
-__BEGIN_DECLS
-
-#define ACCT_COMM 16
-
-struct acct
-  {
-    char ac_comm[ACCT_COMM];		/* Accounting command name.  */
-    time_t ac_utime;			/* Accounting user time.  */
-    time_t ac_stime;			/* Accounting system time.  */
-    time_t ac_etime;			/* Accounting elapsed time.  */
-    time_t ac_btime;			/* Beginning time.  */
-    unsigned int ac_uid;		/* Accounting user ID.  */
-    unsigned int ac_gid;		/* Accounting group ID.  */
-    unsigned int ac_tty;		/* Controlling tty.  */
-    /* Please note that the value of the `ac_tty' field, a device number,
-       is encoded differently in the kernel and for the libc dev_t type.  */
-    char ac_flag;			/* Accounting flag.  */
-    long int ac_minflt;			/* Accounting minor pagefaults.  */
-    long int ac_majflt;			/* Accounting major pagefaults.  */
-    long int ac_exitcode;		/* Accounting process exitcode.  */
-  };
-
-enum
-  {
-    AFORK = 0001,		/* Has executed fork, but no exec.  */
-    ASU = 0002,			/* Used super-user privileges.  */
-    ACORE = 0004,		/* Dumped core.  */
-    AXSIG = 0010		/* Killed by a signal.  */
-  };
-
-#define AHZ     100
-
-
-/* Switch process accounting on and off.  */
-extern int acct (const char *__filename) __THROW;
-
-__END_DECLS
-
-#endif	/* sys/acct.h */
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/arc/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/arc/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/arc/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/arc/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* ldconfig default paths and libraries.  Linux/RISC-V version.
-   Copyright (C) 2020-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES 		\
-  { "/lib/ld-linux-arc.so.2", FLAG_ELF_LIBC6 },	\
-  { "/lib/ld-linux-arceb.so.2", FLAG_ELF_LIBC6 },
-
-#define SYSDEP_KNOWN_LIBRARY_NAMES 	\
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/arm/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/arm/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/arm/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/arm/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* Copyright (C) 2001-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux.so.3", FLAG_ELF_LIBC6 }, \
-  { "/lib/ld-linux-armhf.so.3", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/bits/in.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/bits/in.h
--- glibc-2.36/sysdeps/unix/sysv/linux/bits/in.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/bits/in.h	2022-08-31 07:16:42.000000000 +0200
@@ -146,14 +146,6 @@
     char ip_opts[40];		/* Actually variable in size.  */
   };
 
-/* Like `struct ip_mreq' but including interface specification by index.  */
-struct ip_mreqn
-  {
-    struct in_addr imr_multiaddr;	/* IP multicast address of group */
-    struct in_addr imr_address;		/* local IP address of interface */
-    int	imr_ifindex;			/* Interface index */
-  };
-
 /* Structure used for IP_PKTINFO.  */
 struct in_pktinfo
   {
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/bits/socket.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/bits/socket.h
--- glibc-2.36/sysdeps/unix/sysv/linux/bits/socket.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/bits/socket.h	2022-08-31 07:16:42.000000000 +0200
@@ -307,6 +307,12 @@
 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
 #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
 
+/* Given a length, return the additional padding necessary such that
+   len + __CMSG_PADDING(len) == CMSG_ALIGN (len).  */
+#define __CMSG_PADDING(len) ((sizeof (size_t) \
+                              - ((len) & (sizeof (size_t) - 1))) \
+                             & (sizeof (size_t) - 1))
+
 extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
 				      struct cmsghdr *__cmsg) __THROW;
 #ifdef __USE_EXTERN_INLINES
@@ -316,18 +322,38 @@
 _EXTERN_INLINE struct cmsghdr *
 __NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
 {
+  /* We may safely assume that __cmsg lies between __mhdr->msg_control and
+     __mhdr->msg_controllen because the user is required to obtain the first
+     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs
+     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet
+     trust the value of __cmsg->cmsg_len and therefore do not use it in any
+     pointer arithmetic until we check its value.  */
+
+  unsigned char * __msg_control_ptr = (unsigned char *) __mhdr->msg_control;
+  unsigned char * __cmsg_ptr = (unsigned char *) __cmsg;
+
+  size_t __size_needed = sizeof (struct cmsghdr)
+                         + __CMSG_PADDING (__cmsg->cmsg_len);
+
+  /* The current header is malformed, too small to be a full header.  */
   if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
     return (struct cmsghdr *) 0;
 
+  /* There isn't enough space between __cmsg and the end of the buffer to
+  hold the current cmsg *and* the next one.  */
+  if (((size_t)
+         (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr)
+       < __size_needed)
+      || ((size_t)
+            (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr
+             - __size_needed)
+          < __cmsg->cmsg_len))
+
+    return (struct cmsghdr *) 0;
+
+  /* Now, we trust cmsg_len and can use it to find the next header.  */
   __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
 			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
-					+ __mhdr->msg_controllen)
-      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
-	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
-    /* No more entries.  */
-    return (struct cmsghdr *) 0;
   return __cmsg;
 }
 #endif	/* Use `extern inline'.  */
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/cmsg_nxthdr.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/cmsg_nxthdr.c
--- glibc-2.36/sysdeps/unix/sysv/linux/cmsg_nxthdr.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/cmsg_nxthdr.c	2022-08-31 07:16:42.000000000 +0200
@@ -23,18 +23,38 @@
 struct cmsghdr *
 __cmsg_nxthdr (struct msghdr *mhdr, struct cmsghdr *cmsg)
 {
+  /* We may safely assume that cmsg lies between mhdr->msg_control and
+     mhdr->msg_controllen because the user is required to obtain the first
+     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs
+     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet
+     trust the value of cmsg->cmsg_len and therefore do not use it in any
+     pointer arithmetic until we check its value.  */
+
+  unsigned char * msg_control_ptr = (unsigned char *) mhdr->msg_control;
+  unsigned char * cmsg_ptr = (unsigned char *) cmsg;
+
+  size_t size_needed = sizeof (struct cmsghdr)
+                       + __CMSG_PADDING (cmsg->cmsg_len);
+
+  /* The current header is malformed, too small to be a full header.  */
   if ((size_t) cmsg->cmsg_len < sizeof (struct cmsghdr))
-    /* The kernel header does this so there may be a reason.  */
-    return NULL;
+    return (struct cmsghdr *) 0;
+
+  /* There isn't enough space between cmsg and the end of the buffer to
+  hold the current cmsg *and* the next one.  */
+  if (((size_t)
+         (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr)
+       < size_needed)
+      || ((size_t)
+            (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr
+             - size_needed)
+          < cmsg->cmsg_len))
+
+    return (struct cmsghdr *) 0;
 
+  /* Now, we trust cmsg_len and can use it to find the next header.  */
   cmsg = (struct cmsghdr *) ((unsigned char *) cmsg
 			     + CMSG_ALIGN (cmsg->cmsg_len));
-  if ((unsigned char *) (cmsg + 1) > ((unsigned char *) mhdr->msg_control
-				      + mhdr->msg_controllen)
-      || ((unsigned char *) cmsg + CMSG_ALIGN (cmsg->cmsg_len)
-	  > ((unsigned char *) mhdr->msg_control + mhdr->msg_controllen)))
-    /* No more entries.  */
-    return NULL;
   return cmsg;
 }
 libc_hidden_def (__cmsg_nxthdr)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/csky/configure glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/configure
--- glibc-2.36/sysdeps/unix/sysv/linux/csky/configure	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/configure	2022-08-31 07:16:42.000000000 +0200
@@ -2,4 +2,3 @@
  # Local configure fragment for sysdeps/unix/sysv/linux/csky
 
 arch_minimum_kernel=4.20.0
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/csky/configure.ac glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/configure.ac
--- glibc-2.36/sysdeps/unix/sysv/linux/csky/configure.ac	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/configure.ac	2022-08-31 07:16:42.000000000 +0200
@@ -2,4 +2,3 @@
 # Local configure fragment for sysdeps/unix/sysv/linux/csky
 
 arch_minimum_kernel=4.20.0
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/csky/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/csky/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/csky/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/* ldconfig default paths and libraries.  Linux/C-SKY version.
-   Copyright (C) 2018-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define LD_SO_PREFIX "/lib/ld-linux-"
-#define LD_SO_SUFFIX ".so.1"
-
-#ifdef __CSKY_HARD_FLOAT__
-# define LD_SO_ABI "cskyv2-hf"
-#else
-# define LD_SO_ABI "cskyv2"
-#endif
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES	\
-  { LD_SO_PREFIX LD_SO_ABI LD_SO_SUFFIX, FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES	\
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/_exit.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/_exit.c
--- glibc-2.36/sysdeps/unix/sysv/linux/_exit.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/_exit.c	2022-08-31 07:16:42.000000000 +0200
@@ -28,7 +28,6 @@
   while (1)
     {
       INLINE_SYSCALL (exit_group, 1, status);
-      INLINE_SYSCALL (exit, 1, status);
 
 #ifdef ABORT_INSTRUCTION
       ABORT_INSTRUCTION;
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/i386/configure glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/configure
--- glibc-2.36/sysdeps/unix/sysv/linux/i386/configure	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/configure	2022-08-31 07:16:42.000000000 +0200
@@ -2,4 +2,3 @@
  # Local configure fragment for sysdeps/unix/sysv/linux/i386.
 
 libc_cv_gcc_unwind_find_fde=yes
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/i386/configure.ac glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/configure.ac
--- glibc-2.36/sysdeps/unix/sysv/linux/i386/configure.ac	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/configure.ac	2022-08-31 07:16:42.000000000 +0200
@@ -2,4 +2,3 @@
 # Local configure fragment for sysdeps/unix/sysv/linux/i386.
 
 libc_cv_gcc_unwind_find_fde=yes
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/i386/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/i386/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/ldconfig.h	2022-08-31 07:16:42.000000000 +0200
@@ -16,9 +16,3 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux.so.1", FLAG_ELF_LIBC5 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.5", FLAG_ELF_LIBC5 },	\
-  { "libm.so.5", FLAG_ELF_LIBC5 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/i386/Makefile glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/Makefile
--- glibc-2.36/sysdeps/unix/sysv/linux/i386/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/i386/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -7,11 +7,6 @@
 tests += tst-bz21269
 endif
 
-ifeq ($(subdir),elf)
-sysdep-others += lddlibc4
-install-bin += lddlibc4
-endif
-
 ifeq ($(subdir),io)
 sysdep_routines += libc-do-syscall libc-do-syscall-int80
 endif
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/ia64/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/ia64/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/ia64/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/ia64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-/* Copyright (C) 2001-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux.so.2", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/lddlibc4.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/lddlibc4.c
--- glibc-2.36/sysdeps/unix/sysv/linux/lddlibc4.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/lddlibc4.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-/* Stub for ldd script to print Linux libc4 dependencies.
-   Copyright (C) 1998-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* This code is based on the `ldd' program code from the Linux ld.so
-   package.  */
-
-#include <a.out.h>
-#include <errno.h>
-#include <error.h>
-#include <libintl.h>
-#include <locale.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-/* Get libc version number.  */
-#include "../version.h"
-
-#define PACKAGE _libc_intl_domainname
-
-
-int
-main (int argc, char *argv[])
-{
-  const char *filename;
-  size_t filename_len;
-  struct exec exec;
-  char *buf;
-  FILE *fp;
-
-  /* Set locale via LC_ALL.  */
-  setlocale (LC_ALL, "");
-
-  /* Set the text message domain.  */
-  textdomain (PACKAGE);
-
-  /* We expect exactly one argument.  */
-  if (argc != 2)
-    return 1;
-
-  if (strcmp (argv[1], "--help") == 0)
-    {
-      printf (gettext ("Usage: lddlibc4 FILE\n\n"));
-      printf (gettext ("For bug reporting instructions, please see:\n\
-%s.\n"), REPORT_BUGS_TO);
-      return 0;
-    }
-  else if (strcmp (argv[1], "--version") == 0)
-    {
-      printf ("lddlibc4 %s%s\n", PKGVERSION, VERSION);
-      printf (gettext ("\
-Copyright (C) %s Free Software Foundation, Inc.\n\
-This is free software; see the source for copying conditions.  There is NO\n\
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
-"), "2022");
-      return 0;
-    }
-
-  filename = argv[1];
-
-  /* First see whether this is really an a.out binary.  */
-  fp = fopen (filename, "rb");
-  if (fp == NULL)
-    error (2, errno, gettext ("cannot open `%s'"), filename);
-
-  /* Read the program header.  */
-  if (fread (&exec, sizeof exec, 1, fp) < 1)
-    error (2, errno, gettext ("cannot read header from `%s'"), filename);
-
-  /* Test for the magic numbers.  */
-  if (N_MAGIC (exec) != ZMAGIC && N_MAGIC (exec) != QMAGIC
-      && N_MAGIC (exec) != OMAGIC)
-    exit (3);
-
-  /* We don't need the file open anymore.  */
-  fclose (fp);
-
-  /* We must put `__LDD_ARGV0=<program-name>' in the environment.  */
-  filename_len = strlen (filename);
-  buf = (char *) alloca (sizeof "__LDD_ARGV0=" + filename_len);
-  mempcpy (mempcpy (buf, "__LDD_ARGV0=", sizeof "__LDD_ARGV0=" - 1),
-	   filename, filename_len + 1);
-  /* ...and put the value in the environment.  */
-  putenv (buf);
-
-  /* Now we can execute the binary.  */
-  return execv (filename, &argv[argc]) ? 4 : 0;
-}
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/ldd-rewrite.sed glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/ldd-rewrite.sed
--- glibc-2.36/sysdeps/unix/sysv/linux/ldd-rewrite.sed	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/ldd-rewrite.sed	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-/Maybe extra code for non-ELF binaries/a\
-  file=$1\
-  # Run the ldd stub.\
-  lddlibc4 "$file"\
-  # Test the result.\
-  if test $? -lt 3; then\
-    return 0;\
-  fi\
-  # In case of an error punt.
-/LD_TRACE_LOADED_OBJECTS=1/a\
-add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/loongarch/gettimeofday.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/loongarch/gettimeofday.c
--- glibc-2.36/sysdeps/unix/sysv/linux/loongarch/gettimeofday.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/loongarch/gettimeofday.c	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,22 @@
+/* gettimeofday -- Get the current time of day.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+
+#define USE_IFUNC_GETTIMEOFDAY
+#include <sysdeps/unix/sysv/linux/gettimeofday.c>
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/loongarch/sysdep.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/loongarch/sysdep.h
--- glibc-2.36/sysdeps/unix/sysv/linux/loongarch/sysdep.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/loongarch/sysdep.h	2022-08-31 07:16:42.000000000 +0200
@@ -116,6 +116,7 @@
 /* List of system calls which are supported as vsyscalls.  */
 #define HAVE_CLOCK_GETRES64_VSYSCALL "__vdso_clock_getres"
 #define HAVE_CLOCK_GETTIME64_VSYSCALL "__vdso_clock_gettime"
+#define HAVE_GETTIMEOFDAY_VSYSCALL "__vdso_gettimeofday"
 #define HAVE_GETCPU_VSYSCALL "__vdso_getcpu"
 
 #define HAVE_CLONE3_WRAPPER 1
@@ -313,8 +314,64 @@
 
 #endif /* ! __ASSEMBLER__ */
 
-/* Pointer mangling is not supported.  */
-#define PTR_MANGLE(var) (void) (var)
-#define PTR_DEMANGLE(var) (void) (var)
+/* Pointer mangling is supported for LoongArch.  */
+
+/* Load a got-relative EXPR into G, using T.
+   Note G and T are register names.  */
+#define LD_GLOBAL(G, EXPR) \
+  la.global G,	EXPR; \
+  REG_L	    G,	G,  0;
+
+/* Load a pc-relative EXPR into G, using T.
+   Note G and T are register names.  */
+#define LD_PCREL(G, EXPR) \
+  la.pcrel  G,	EXPR; \
+  REG_L	    G,	G,  0;
+
+#if (IS_IN (rtld) \
+     || (!defined SHARED && (IS_IN (libc) \
+     || IS_IN (libpthread))))
+
+#ifdef __ASSEMBLER__
+#define PTR_MANGLE(dst, src, guard) \
+  LD_PCREL (guard, __pointer_chk_guard_local); \
+  PTR_MANGLE2 (dst, src, guard);
+#define PTR_DEMANGLE(dst, src, guard) \
+  LD_PCREL (guard, __pointer_chk_guard_local); \
+  PTR_DEMANGLE2 (dst, src, guard);
+/* Use PTR_MANGLE2 for efficiency if guard is already loaded.  */
+#define PTR_MANGLE2(dst, src, guard) \
+  xor  dst, src, guard;
+#define PTR_DEMANGLE2(dst, src, guard) \
+  PTR_MANGLE2 (dst, src, guard);
+#else
+extern uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
+#define PTR_MANGLE(var) \
+  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)
+#define PTR_DEMANGLE(var) PTR_MANGLE (var)
+#endif
+
+#else
+
+#ifdef __ASSEMBLER__
+#define PTR_MANGLE(dst, src, guard) \
+  LD_GLOBAL (guard, __pointer_chk_guard); \
+  PTR_MANGLE2 (dst, src, guard);
+#define PTR_DEMANGLE(dst, src, guard) \
+  LD_GLOBAL (guard, __pointer_chk_guard); \
+  PTR_DEMANGLE2 (dst, src, guard);
+/* Use PTR_MANGLE2 for efficiency if guard is already loaded.  */
+#define PTR_MANGLE2(dst, src, guard) \
+  xor dst, src, guard;
+#define PTR_DEMANGLE2(dst, src, guard) \
+  PTR_MANGLE2 (dst, src, guard);
+#else
+extern uintptr_t __pointer_chk_guard attribute_relro;
+#define PTR_MANGLE(var) \
+  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)
+#define PTR_DEMANGLE(var) PTR_MANGLE (var)
+#endif
+
+#endif
 
 #endif /* linux/loongarch/sysdep.h */
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/m68k/configure glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/configure
--- glibc-2.36/sysdeps/unix/sysv/linux/m68k/configure	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/configure	2022-08-31 07:16:42.000000000 +0200
@@ -6,4 +6,3 @@
   libc_cv_gcc_unwind_find_fde=yes
   ;;
 esac
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/m68k/configure.ac glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/configure.ac
--- glibc-2.36/sysdeps/unix/sysv/linux/m68k/configure.ac	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/configure.ac	2022-08-31 07:16:42.000000000 +0200
@@ -7,4 +7,3 @@
   libc_cv_gcc_unwind_find_fde=yes
   ;;
 esac
-ldd_rewrite_script=sysdeps/unix/sysv/linux/ldd-rewrite.sed
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/m68k/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/m68k/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#include <sysdeps/unix/sysv/linux/i386/ldconfig.h>
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/m68k/Makefile glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/Makefile
--- glibc-2.36/sysdeps/unix/sysv/linux/m68k/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/m68k/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -15,8 +15,3 @@
 sysdep_routines += mremap
 sysdep_headers += sys/reg.h
 endif
-
-ifeq ($(subdir),elf)
-sysdep-others += lddlibc4
-install-bin += lddlibc4
-endif
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/Makefile glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/Makefile
--- glibc-2.36/sysdeps/unix/sysv/linux/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -265,6 +265,14 @@
 	  < /dev/null > $@ 2>&1; $(evaluate-test)
 $(objpfx)tst-mount-consts.out: $(sysdeps-linux-python-deps)
 
+tests-special += $(objpfx)tst-mount-compile.out
+$(objpfx)tst-mount-compile.out: ../sysdeps/unix/sysv/linux/tst-mount-compile.py
+	$(sysdeps-linux-python) \
+	  ../sysdeps/unix/sysv/linux/tst-mount-compile.py \
+	    $(sysdeps-linux-python-cc) \
+	  < /dev/null > $@ 2>&1; $(evaluate-test)
+$(objpfx)tst-mount-compile.out: $(sysdeps-linux-python-deps)
+
 tst-rseq-disable-ENV = GLIBC_TUNABLES=glibc.pthread.rseq=0
 
 endif # $(subdir) == misc
@@ -393,8 +401,6 @@
 ifeq ($(subdir),elf)
 sysdep-rtld-routines += dl-brk dl-sbrk dl-getcwd dl-openat64 dl-opendir
 
-libof-lddlibc4 = lddlibc4
-
 others += pldd
 install-bin += pldd
 $(objpfx)pldd: $(objpfx)xmalloc.o
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/mips/mips64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* Copyright (C) 2001-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib64/ld.so.1", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/powerpc/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/powerpc/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/powerpc/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/powerpc/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* ldconfig default paths and libraries.  Linux/PowerPC version.
-   Copyright (C) 2002-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },	\
-  { "/lib64/ld64.so.1", FLAG_ELF_LIBC6 }, \
-  { "/lib64/ld64.so.2", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/powerpc/ldd-rewrite.sed glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/powerpc/ldd-rewrite.sed
--- glibc-2.36/sysdeps/unix/sysv/linux/powerpc/ldd-rewrite.sed	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/powerpc/ldd-rewrite.sed	2022-08-31 07:16:42.000000000 +0200
@@ -1,6 +1,3 @@
-/LD_TRACE_LOADED_OBJECTS=1/a\
-add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
-
 # ldd is generated from elf/ldd.bash.in with the name
 # of ld.so as generated in Makeconfig
 
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/riscv/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/riscv/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/* ldconfig default paths and libraries.  Linux/RISC-V version.
-   Copyright (C) 2001-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library.  If not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define LD_SO_PREFIX "/lib/ld-linux-"
-#define LD_SO_SUFFIX ".so.1"
-
-#if __riscv_xlen == 64
-# define LD_SO_ABI "riscv64-lp64"
-#else
-# define LD_SO_ABI "riscv32-ilp32"
-#endif
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES				\
-  { LD_SO_PREFIX LD_SO_ABI "d" LD_SO_SUFFIX, FLAG_ELF_LIBC6 },	\
-  { LD_SO_PREFIX LD_SO_ABI     LD_SO_SUFFIX, FLAG_ELF_LIBC6 },
-
-#define SYSDEP_KNOWN_LIBRARY_NAMES	\
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/riscv/rv32/arch-syscall.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/rv32/arch-syscall.h
--- glibc-2.36/sysdeps/unix/sysv/linux/riscv/rv32/arch-syscall.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/rv32/arch-syscall.h	2022-08-31 07:16:42.000000000 +0200
@@ -122,6 +122,7 @@
 #define __NR_mbind 235
 #define __NR_membarrier 283
 #define __NR_memfd_create 279
+#define __NR_memfd_secret 447
 #define __NR_migrate_pages 238
 #define __NR_mincore 232
 #define __NR_mkdirat 34
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/riscv/rv64/arch-syscall.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/rv64/arch-syscall.h
--- glibc-2.36/sysdeps/unix/sysv/linux/riscv/rv64/arch-syscall.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/riscv/rv64/arch-syscall.h	2022-08-31 07:16:42.000000000 +0200
@@ -127,6 +127,7 @@
 #define __NR_mbind 235
 #define __NR_membarrier 283
 #define __NR_memfd_create 279
+#define __NR_memfd_secret 447
 #define __NR_migrate_pages 238
 #define __NR_mincore 232
 #define __NR_mkdirat 34
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/dl-procinfo.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/dl-procinfo.h
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/dl-procinfo.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/dl-procinfo.h	2022-08-31 07:16:42.000000000 +0200
@@ -39,7 +39,7 @@
 
   for (i = 0; i < _DL_HWCAP_COUNT; ++i)
     if (word & (1UL << i))
-      _dl_printf (" %s", GLRO(dl_s390_cap_flags)[i]);
+      _dl_printf (" %s", _dl_s390_cap_flags[i]);
 
   _dl_printf ("\n");
 
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/ldconfig.h	2022-08-31 07:16:42.000000000 +0200
@@ -16,10 +16,3 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },	\
-  { "/lib/ld64.so.1", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/ldd-rewrite.sed	2022-08-31 07:16:42.000000000 +0200
@@ -1,6 +1,3 @@
-/LD_TRACE_LOADED_OBJECTS=1/a\
-add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
-
 # ldd is generated from elf/ldd.bash.in with the name
 # of ld.so as generated in Makeconfig
 
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/clone.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/clone.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/clone.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/clone.S	2022-08-31 07:16:42.000000000 +0200
@@ -30,9 +30,10 @@
 
 	.text
 ENTRY(__clone)
-	st	%r6,24(%r15)		/* store %r6 to save area */
+	stm     %r6,%r7,24(%r15)	/* Save registers.  */
+	cfi_offset (%r7, -68)
 	cfi_offset (%r6, -72)
-	ltr     %r1,%r2			/* check fn and move to %r1 */
+	ltr     %r7,%r2			/* check fn and move to %r7 */
 	jz      error			/* no NULL function pointers */
 	lhi     %r0,-8			/* Align the child_stack to a ...  */
 	nr      %r3,%r0			/* double word boundary and ...  */
@@ -43,10 +44,11 @@
 	lr	%r4,%r6			/* move parent_tid to %r4 */
 	l	%r5,100(%r15)		/* load child_tid from stack */
 	l	%r6,96(%r15)		/* load tls from stack */
-	svc	SYS_ify(clone)
+	lhi	%r1,SYS_ify(clone)
+	svc	0
 	ltr	%r2,%r2			/* check return code */
 	jz	thread_start
-	l	%r6,24(%r15)		/* restore %r6 */
+	lm	%r6,%r7,24(%r15)	/* Load registers.  */
 	jm	SYSCALL_ERROR_LABEL
 	br	%r14
 error:
@@ -58,11 +60,11 @@
 	cfi_startproc
 	/* Mark r14 as undefined in order to stop unwinding here!  */
 	cfi_undefined (r14)
-	/* fn is in gpr 1, arg in gpr 0 */
+	/* fn is in gpr 7, arg in gpr 0 */
 	lr      %r2,%r0         /* set first parameter to void *arg */
 	ahi     %r15,-96        /* make room on the stack for the save area */
 	xc	0(4,%r15),0(%r15)
-	basr    %r14,%r1        /* jump to fn */
+	basr    %r14,%r7        /* jump to fn */
 	DO_CALL (exit, 1)
 	cfi_endproc
 
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/getcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/getcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/getcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/getcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -32,16 +32,18 @@
   other than the PRESERVED state.  */
 
 ENTRY(__getcontext)
-	lr      %r1,%r2
+	lr	%r0,%r2
 
 	/* rt_sigprocmask (SIG_BLOCK, NULL, &sc->sc_mask, sigsetsize).  */
+	la	%r4,SC_MASK(%r2)
 	la      %r2,SIG_BLOCK
 	slr	%r3,%r3
-	la	%r4,SC_MASK(%r1)
 	lhi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lhi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Store fpu context.  */
+	lr	%r1,%r0
 	stfpc   SC_FPC(%r1)
 	std     %f0,SC_FPRS(%r1)
 	std     %f1,SC_FPRS+8(%r1)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/setcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/setcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/setcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/setcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -30,16 +30,18 @@
   other than the PRESERVED state.  */
 
 ENTRY(__setcontext)
-	lr	%r1,%r2
+	lr	%r0,%r2
 
 	/* rt_sigprocmask (SIG_SETMASK, &sc->sc_mask, NULL, sigsetsize).  */
+	la	%r3,SC_MASK(%r2)
 	la      %r2,SIG_SETMASK
-	la	%r3,SC_MASK(%r1)
 	slr	%r4,%r4
 	lhi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lhi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Load fpu context.  */
+	lr	%r1,%r0
 	lfpc	SC_FPC(%r1)
 	ld	%f0,SC_FPRS(%r1)
 	ld      %f1,SC_FPRS+8(%r1)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/swapcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/swapcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/swapcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/swapcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -73,7 +73,8 @@
 	la	%r3,SC_MASK(%r5)
 	la	%r4,SC_MASK(%r1)
 	lhi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lhi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Load fpu context.  */
 	lr	%r5,%r0
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/sysdep.h	2022-08-31 07:16:42.000000000 +0200
@@ -155,12 +155,8 @@
     lr %r0,%r7;								      \
     l %r7,96(%r15);							      \
   .endif;								      \
-  .if SYS_ify (syscall) < 256;						      \
-    svc SYS_ify (syscall);						      \
-  .else;								      \
     lhi %r1,SYS_ify (syscall);						      \
     svc 0;								      \
-  .endif;								      \
   .if args > 5;								      \
     lr %r7,%r0;								      \
   .endif
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/vfork.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/vfork.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-32/vfork.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-32/vfork.S	2022-08-31 07:16:42.000000000 +0200
@@ -28,7 +28,8 @@
 
 ENTRY (__libc_vfork)
 	/* Do vfork system call.  */
-	svc	SYS_ify (vfork)
+	lhi	%r1,SYS_ify (vfork)
+	svc	0
 
 	/* Check for error.  */
 	lhi	%r4,-4095
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/clone.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/clone.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/clone.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/clone.S	2022-08-31 07:16:42.000000000 +0200
@@ -31,9 +31,10 @@
 
 	.text
 ENTRY(__clone)
-	stg	%r6,48(%r15)		/* store %r6 to save area */
+	stmg	%r6,%r7,48(%r15)	/* Save registers.  */
+	cfi_offset (%r7,-104)
 	cfi_offset (%r6,-112)
-	ltgr    %r1,%r2			/* check fn and move to %r1 */
+	ltgr    %r7,%r2			/* check fn and move to %r7 */
 	jz      error			/* no NULL function pointers */
 	lghi	%r0,-16			/* Align the child_stack to a ...  */
 	ngr	%r3,%r0			/* double word boundary and ...  */
@@ -44,10 +45,11 @@
 	lgr	%r4,%r6			/* move parent_tid to %r4 */
 	lg	%r5,168(%r15)		/* load child_tid from stack */
 	lg	%r6,160(%r15)		/* load tls from stack */
-	svc	SYS_ify(clone)
+	lghi	%r1,SYS_ify (clone)
+	svc	0
 	ltgr	%r2,%r2			/* check return code */
 	jz	thread_start
-	lg	%r6,48(%r15)		/* restore %r6 */
+	lmg	%r6,%r7,48(%r15)	/* Restore registers.  */
 	jgm	SYSCALL_ERROR_LABEL
 	br	%r14
 error:
@@ -59,11 +61,11 @@
 	cfi_startproc
 	/* Mark r14 as undefined in order to stop unwinding here!  */
 	cfi_undefined (r14)
-	/* fn is in gpr 1, arg in gpr 0 */
+	/* fn is in gpr 7, arg in gpr 0 */
 	lgr	%r2,%r0		/* set first parameter to void *arg */
 	aghi	%r15,-160	/* make room on the stack for the save area */
 	xc	0(8,%r15),0(%r15)
-	basr	%r14,%r1	/* jump to fn */
+	basr	%r14,%r7	/* jump to fn */
 	DO_CALL	(exit, 1)
 	cfi_endproc
 
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/getcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/getcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/getcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/getcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -32,16 +32,18 @@
   other than the PRESERVED state.  */
 
 ENTRY(__getcontext)
-	lgr     %r1,%r2
+	lgr	%r0,%r2
 
 	/* rt_sigprocmask (SIG_BLOCK, NULL, &sc->sc_mask, sigsetsize).  */
+	la	%r4,SC_MASK(%r2)
 	la      %r2,SIG_BLOCK
 	slgr	%r3,%r3
-	la	%r4,SC_MASK(%r1)
 	lghi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lghi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Store fpu context.  */
+	lgr	%r1,%r0
 	stfpc   SC_FPC(%r1)
 	std     %f0,SC_FPRS(%r1)
 	std     %f1,SC_FPRS+8(%r1)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/setcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/setcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/setcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/setcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -30,16 +30,18 @@
   other than the PRESERVED state.  */
 
 ENTRY(__setcontext)
-	lgr	%r1,%r2
+	lgr	%r0,%r2
 
 	/* sigprocmask (SIG_SETMASK, &sc->sc_mask, NULL).  */
+	la	%r3,SC_MASK(%r2)
 	la      %r2,SIG_SETMASK
-	la	%r3,SC_MASK(%r1)
 	slgr	%r4,%r4
 	lghi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lghi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Load fpu context.  */
+	lgr	%r1,%r0
 	lfpc	SC_FPC(%r1)
 	ld	%f0,SC_FPRS(%r1)
 	ld      %f1,SC_FPRS+8(%r1)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/swapcontext.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/swapcontext.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/swapcontext.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/swapcontext.S	2022-08-31 07:16:42.000000000 +0200
@@ -73,7 +73,8 @@
 	la	%r3,SC_MASK(%r5)
 	la	%r4,SC_MASK(%r1)
 	lghi	%r5,_NSIG8
-	svc	SYS_ify(rt_sigprocmask)
+	lghi	%r1,SYS_ify(rt_sigprocmask)
+	svc	0
 
 	/* Load fpu context.  */
 	lgr	%r5,%r0
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/sysdep.h	2022-08-31 07:16:42.000000000 +0200
@@ -153,12 +153,8 @@
     lgr %r0,%r7;							      \
     lg %r7,160(%r15);							      \
   .endif;								      \
-  .if SYS_ify (syscall) < 256;						      \
-    svc SYS_ify (syscall);						      \
-  .else;								      \
     lghi %r1,SYS_ify (syscall);						      \
     svc 0;								      \
-  .endif;								      \
   .if args > 5;								      \
     lgr %r7,%r0;							      \
   .endif
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/vfork.S glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/vfork.S
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/s390-64/vfork.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/s390-64/vfork.S	2022-08-31 07:16:42.000000000 +0200
@@ -28,7 +28,8 @@
 
 ENTRY (__libc_vfork)
 	/* Do vfork system call.  */
-	svc	SYS_ify (vfork)
+	lghi	%r1,SYS_ify (vfork)
+	svc	0
 
 	/* Check for error.  */
 	lghi	%r4,-4095
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/s390/sysdep.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/sysdep.h
--- glibc-2.36/sysdeps/unix/sysv/linux/s390/sysdep.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/s390/sysdep.h	2022-08-31 07:16:42.000000000 +0200
@@ -21,32 +21,6 @@
 #undef SYS_ify
 #define SYS_ify(syscall_name)	__NR_##syscall_name
 
-#undef INTERNAL_SYSCALL_DIRECT
-#define INTERNAL_SYSCALL_DIRECT(name, nr, args...)			      \
-  ({									      \
-    DECLARGS_##nr(args)							      \
-    register long int _ret __asm__("2");				      \
-    __asm__ __volatile__ (						      \
-			  "svc    %b1\n\t"				      \
-			  : "=d" (_ret)					      \
-			  : "i" (__NR_##name) ASMFMT_##nr		      \
-			  : "memory" );					      \
-    _ret; })
-
-#undef INTERNAL_SYSCALL_SVC0
-#define INTERNAL_SYSCALL_SVC0(name, nr, args...)			      \
-  ({									      \
-    DECLARGS_##nr(args)							      \
-    register unsigned long int _nr __asm__("1") =			      \
-      (unsigned long int)(__NR_##name);					      \
-    register long int _ret __asm__("2");				      \
-    __asm__ __volatile__ (						      \
-			  "svc    0\n\t"				      \
-			  : "=d" (_ret)					      \
-			  : "d" (_nr) ASMFMT_##nr			      \
-			  : "memory" );					      \
-    _ret; })
-
 #undef INTERNAL_SYSCALL_NCS
 #define INTERNAL_SYSCALL_NCS(no, nr, args...)				      \
   ({									      \
@@ -61,10 +35,8 @@
     _ret; })
 
 #undef INTERNAL_SYSCALL
-#define INTERNAL_SYSCALL(name, nr, args...)				      \
-  (((__NR_##name) < 256)						      \
-   ? INTERNAL_SYSCALL_DIRECT(name, nr, args)				      \
-   : INTERNAL_SYSCALL_SVC0(name, nr, args))
+#define INTERNAL_SYSCALL(name, nr, args...)				\
+  INTERNAL_SYSCALL_NCS(__NR_##name, nr, args)
 
 #define DECLARGS_0()
 #define DECLARGS_1(arg1) \
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/sparc/ldd-rewrite.sed glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sparc/ldd-rewrite.sed
--- glibc-2.36/sysdeps/unix/sysv/linux/sparc/ldd-rewrite.sed	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sparc/ldd-rewrite.sed	2022-08-31 07:16:42.000000000 +0200
@@ -1,3 +1 @@
-/LD_TRACE_LOADED_OBJECTS=1/a\
-add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
 s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\2\4 \264\4"_
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile
--- glibc-2.36/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sparc/sparc32/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -13,8 +13,6 @@
 ifeq ($(subdir),elf)
 CFLAGS-rtld.c += -mcpu=v8
 #rtld-routines += dl-sysdepsparc
-sysdep-others += lddlibc4
-install-bin += lddlibc4
 endif   # elf
 
 ifeq ($(subdir),math)
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/sys/acct.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sys/acct.h
--- glibc-2.36/sysdeps/unix/sysv/linux/sys/acct.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sys/acct.h	2022-08-31 07:16:42.000000000 +0200
@@ -86,7 +86,9 @@
     AFORK = 0x01,		/* Has executed fork, but no exec.  */
     ASU = 0x02,			/* Used super-user privileges.  */
     ACORE = 0x08,		/* Dumped core.  */
-    AXSIG = 0x10		/* Killed by a signal.  */
+    AXSIG = 0x10,		/* Killed by a signal.  */
+    AGROUP = 0x20		/* Was the last task of the process
+				   (task group).  */
   };
 
 #if __BYTE_ORDER == __BIG_ENDIAN
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/sys/mount.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sys/mount.h
--- glibc-2.36/sysdeps/unix/sysv/linux/sys/mount.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/sys/mount.h	2022-08-31 07:16:42.000000000 +0200
@@ -27,77 +27,113 @@
 #include <stddef.h>
 #include <sys/ioctl.h>
 
-#define BLOCK_SIZE	1024
+#ifdef __has_include
+# if __has_include ("linux/mount.h")
+#  include "linux/mount.h"
+# endif
+#endif
+
+
 #define BLOCK_SIZE_BITS	10
+#define BLOCK_SIZE	(1<<BLOCK_SIZE_BITS)
 
 
 /* These are the fs-independent mount-flags: up to 16 flags are
    supported  */
 enum
 {
+#undef MS_RDONLY
   MS_RDONLY = 1,		/* Mount read-only.  */
 #define MS_RDONLY	MS_RDONLY
+#undef MS_NOSUID
   MS_NOSUID = 2,		/* Ignore suid and sgid bits.  */
 #define MS_NOSUID	MS_NOSUID
+#undef MS_NODEV
   MS_NODEV = 4,			/* Disallow access to device special files.  */
 #define MS_NODEV	MS_NODEV
+#undef MS_NOEXEC
   MS_NOEXEC = 8,		/* Disallow program execution.  */
 #define MS_NOEXEC	MS_NOEXEC
+#undef MS_SYNCHRONOUS
   MS_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
 #define MS_SYNCHRONOUS	MS_SYNCHRONOUS
+#undef MS_REMOUNT
   MS_REMOUNT = 32,		/* Alter flags of a mounted FS.  */
 #define MS_REMOUNT	MS_REMOUNT
+#undef MS_MANDLOCK
   MS_MANDLOCK = 64,		/* Allow mandatory locks on an FS.  */
 #define MS_MANDLOCK	MS_MANDLOCK
+#undef MS_DIRSYNC
   MS_DIRSYNC = 128,		/* Directory modifications are synchronous.  */
 #define MS_DIRSYNC	MS_DIRSYNC
+#undef MS_NOSYMFOLLOW
   MS_NOSYMFOLLOW = 256,		/* Do not follow symlinks.  */
 #define MS_NOSYMFOLLOW	MS_NOSYMFOLLOW
+#undef MS_NOATIME
   MS_NOATIME = 1024,		/* Do not update access times.  */
 #define MS_NOATIME	MS_NOATIME
+#undef MS_NODIRATIME
   MS_NODIRATIME = 2048,		/* Do not update directory access times.  */
 #define MS_NODIRATIME	MS_NODIRATIME
+#undef MS_BIND
   MS_BIND = 4096,		/* Bind directory at different place.  */
 #define MS_BIND		MS_BIND
+#undef MS_MOVE
   MS_MOVE = 8192,
 #define MS_MOVE		MS_MOVE
+#undef MS_REC
   MS_REC = 16384,
 #define MS_REC		MS_REC
+#undef MS_SILENT
   MS_SILENT = 32768,
 #define MS_SILENT	MS_SILENT
+#undef MS_POSIXACL
   MS_POSIXACL = 1 << 16,	/* VFS does not apply the umask.  */
 #define MS_POSIXACL	MS_POSIXACL
+#undef MS_UNBINDABLE
   MS_UNBINDABLE = 1 << 17,	/* Change to unbindable.  */
 #define MS_UNBINDABLE	MS_UNBINDABLE
+#undef MS_PRIVATE
   MS_PRIVATE = 1 << 18,		/* Change to private.  */
 #define MS_PRIVATE	MS_PRIVATE
+#undef MS_SLAVE
   MS_SLAVE = 1 << 19,		/* Change to slave.  */
 #define MS_SLAVE	MS_SLAVE
+#undef MS_SHARED
   MS_SHARED = 1 << 20,		/* Change to shared.  */
 #define MS_SHARED	MS_SHARED
+#undef MS_RELATIME
   MS_RELATIME = 1 << 21,	/* Update atime relative to mtime/ctime.  */
 #define MS_RELATIME	MS_RELATIME
+#undef MS_KERNMOUNT
   MS_KERNMOUNT = 1 << 22,	/* This is a kern_mount call.  */
 #define MS_KERNMOUNT	MS_KERNMOUNT
+#undef MS_I_VERSION
   MS_I_VERSION =  1 << 23,	/* Update inode I_version field.  */
 #define MS_I_VERSION	MS_I_VERSION
+#undef MS_STRICTATIME
   MS_STRICTATIME = 1 << 24,	/* Always perform atime updates.  */
 #define MS_STRICTATIME	MS_STRICTATIME
+#undef MS_LAZYTIME
   MS_LAZYTIME = 1 << 25,	/* Update the on-disk [acm]times lazily.  */
 #define MS_LAZYTIME	MS_LAZYTIME
+#undef MS_ACTIVE
   MS_ACTIVE = 1 << 30,
 #define MS_ACTIVE	MS_ACTIVE
+#undef MS_NOUSER
   MS_NOUSER = 1 << 31
 #define MS_NOUSER	MS_NOUSER
 };
 
 /* Flags that can be altered by MS_REMOUNT  */
+#undef MS_RMT_MASK
 #define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION \
 		     |MS_LAZYTIME)
 
 
 /* Magic mount flag number. Has to be or-ed to the flag values.  */
 
+#undef MS_MGC_VAL
 #define MS_MGC_VAL 0xc0ed0000	/* Magic flag number to indicate "new" flags */
 #define MS_MGC_MSK 0xffff0000	/* Magic flag number mask */
 
@@ -106,20 +142,35 @@
    is probably as bad and I don't want to create yet another include
    file.  */
 
+#undef BLKROSET
 #define BLKROSET   _IO(0x12, 93) /* Set device read-only (0 = read-write).  */
+#undef BLKROGET
 #define BLKROGET   _IO(0x12, 94) /* Get read-only status (0 = read_write).  */
+#undef BLKRRPART
 #define BLKRRPART  _IO(0x12, 95) /* Re-read partition table.  */
+#undef BLKGETSIZE
 #define BLKGETSIZE _IO(0x12, 96) /* Return device size.  */
+#undef BLKFLSBUF
 #define BLKFLSBUF  _IO(0x12, 97) /* Flush buffer cache.  */
+#undef BLKRASET
 #define BLKRASET   _IO(0x12, 98) /* Set read ahead for block device.  */
+#undef BLKRAGET
 #define BLKRAGET   _IO(0x12, 99) /* Get current read ahead setting.  */
+#undef BLKFRASET
 #define BLKFRASET  _IO(0x12,100) /* Set filesystem read-ahead.  */
+#undef BLKFRAGET
 #define BLKFRAGET  _IO(0x12,101) /* Get filesystem read-ahead.  */
+#undef BLKSECTSET
 #define BLKSECTSET _IO(0x12,102) /* Set max sectors per request.  */
+#undef BLKSECTGET
 #define BLKSECTGET _IO(0x12,103) /* Get max sectors per request.  */
+#undef BLKSSZGET
 #define BLKSSZGET  _IO(0x12,104) /* Get block device sector size.  */
+#undef BLKBSZGET
 #define BLKBSZGET  _IOR(0x12,112,size_t)
+#undef BLKBSZSET
 #define BLKBSZSET  _IOW(0x12,113,size_t)
+#undef BLKGETSIZE64
 #define BLKGETSIZE64 _IOR(0x12,114,size_t) /* return device size.  */
 
 
@@ -137,9 +188,6 @@
 };
 
 
-/* fsopen flags.  */
-#define FSOPEN_CLOEXEC          0x00000001
-
 /* fsmount flags.  */
 #define FSMOUNT_CLOEXEC         0x00000001
 
@@ -157,6 +205,7 @@
 #define MOUNT_ATTR_NOSYMFOLLOW  0x00200000 /* Do not follow symlinks.  */
 
 
+#ifndef MOUNT_ATTR_SIZE_VER0
 /* For mount_setattr.  */
 struct mount_attr
 {
@@ -165,6 +214,7 @@
   uint64_t propagation;
   uint64_t userns_fd;
 };
+#endif
 
 #define MOUNT_ATTR_SIZE_VER0    32 /* sizeof first published struct */
 
@@ -185,26 +235,31 @@
 #define FSPICK_EMPTY_PATH       0x00000008
 
 
+#ifndef FSOPEN_CLOEXEC
 /* The type of fsconfig call made.   */
 enum fsconfig_command
 {
   FSCONFIG_SET_FLAG       = 0,    /* Set parameter, supplying no value */
-#define FSCONFIG_SET_FLAG FSCONFIG_SET_FLAG
+# define FSCONFIG_SET_FLAG FSCONFIG_SET_FLAG
   FSCONFIG_SET_STRING     = 1,    /* Set parameter, supplying a string value */
-#define FSCONFIG_SET_STRING FSCONFIG_SET_STRING
+# define FSCONFIG_SET_STRING FSCONFIG_SET_STRING
   FSCONFIG_SET_BINARY     = 2,    /* Set parameter, supplying a binary blob value */
-#define FSCONFIG_SET_BINARY FSCONFIG_SET_BINARY
+# define FSCONFIG_SET_BINARY FSCONFIG_SET_BINARY
   FSCONFIG_SET_PATH       = 3,    /* Set parameter, supplying an object by path */
-#define FSCONFIG_SET_PATH FSCONFIG_SET_PATH
+# define FSCONFIG_SET_PATH FSCONFIG_SET_PATH
   FSCONFIG_SET_PATH_EMPTY = 4,    /* Set parameter, supplying an object by (empty) path */
-#define FSCONFIG_SET_PATH_EMPTY FSCONFIG_SET_PATH_EMPTY
+# define FSCONFIG_SET_PATH_EMPTY FSCONFIG_SET_PATH_EMPTY
   FSCONFIG_SET_FD         = 5,    /* Set parameter, supplying an object by fd */
-#define FSCONFIG_SET_FD FSCONFIG_SET_FD
+# define FSCONFIG_SET_FD FSCONFIG_SET_FD
   FSCONFIG_CMD_CREATE     = 6,    /* Invoke superblock creation */
-#define FSCONFIG_CMD_CREATE FSCONFIG_CMD_CREATE
+# define FSCONFIG_CMD_CREATE FSCONFIG_CMD_CREATE
   FSCONFIG_CMD_RECONFIGURE = 7,   /* Invoke superblock reconfiguration */
-#define FSCONFIG_CMD_RECONFIGURE FSCONFIG_CMD_RECONFIGURE
+# define FSCONFIG_CMD_RECONFIGURE FSCONFIG_CMD_RECONFIGURE
 };
+#endif
+
+/* fsopen flags.  */
+#define FSOPEN_CLOEXEC          0x00000001
 
 /* open_tree flags.  */
 #define OPEN_TREE_CLONE    1         /* Clone the target tree and attach the clone */
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/syscall-names.list glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/syscall-names.list
--- glibc-2.36/sysdeps/unix/sysv/linux/syscall-names.list	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/syscall-names.list	2022-08-31 07:16:42.000000000 +0200
@@ -21,8 +21,8 @@
 # This file can list all potential system calls.  The names are only
 # used if the installed kernel headers also provide them.
 
-# The list of system calls is current as of Linux 5.18.
-kernel 5.18
+# The list of system calls is current as of Linux 5.19.
+kernel 5.19
 
 FAST_atomic_update
 FAST_cmpxchg
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-mman-consts.py glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mman-consts.py
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-mman-consts.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mman-consts.py	2022-08-31 07:16:42.000000000 +0200
@@ -33,7 +33,7 @@
                         help='C compiler (including options) to use')
     args = parser.parse_args()
     linux_version_headers = glibcsyscalls.linux_kernel_version(args.cc)
-    linux_version_glibc = (5, 18)
+    linux_version_glibc = (5, 19)
     sys.exit(glibcextract.compare_macro_consts(
         '#define _GNU_SOURCE 1\n'
         '#include <sys/mman.h>\n',
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-mount-compile.py glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mount-compile.py
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-mount-compile.py	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mount-compile.py	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,66 @@
+#!/usr/bin/python3
+# Check if glibc provided sys/mount.h can be used along related kernel
+# headers.
+# Copyright (C) 2022 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <https://www.gnu.org/licenses/>.
+
+import argparse
+import sys
+
+import glibcextract
+
+
+def main():
+    """The main entry point."""
+    parser = argparse.ArgumentParser(
+        description='Check if glibc provided sys/mount.h can be '
+                    ' used along related kernel headers.')
+    parser.add_argument('--cc', metavar='CC',
+                        help='C compiler (including options) to use')
+    args = parser.parse_args()
+
+    if glibcextract.compile_c_snippet(
+            '#include <linux/mount.h>',
+            args.cc).returncode != 0:
+        sys.exit (77)
+
+    def check(testname, snippet):
+        # Add -Werror to catch macro redefinitions and _ISOMAC to avoid
+        # internal glibc definitions.
+        r = glibcextract.compile_c_snippet(snippet, args.cc,
+                '-Werror -D_ISOMAC')
+        if r.returncode != 0:
+            print('error: test {}:\n{}'.format(testname, r.output.decode()))
+        return r.returncode
+
+    status = max(
+        check("sys/mount.h + linux/mount.h",
+              "#include <sys/mount.h>\n"
+              "#include <linux/mount.h>"),
+        check("sys/mount.h + linux/fs.h",
+              "#include <sys/mount.h>\n"
+              "#include <linux/fs.h>"),
+        check("linux/mount.h + sys/mount.h",
+              "#include <linux/mount.h>\n"
+              "#include <sys/mount.h>"),
+        check("linux/fs.h + sys/mount.h",
+              "#include <linux/fs.h>\n"
+              "#include <sys/mount.h>"))
+    sys.exit(status)
+
+if __name__ == '__main__':
+    main()
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-mount-consts.py glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mount-consts.py
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-mount-consts.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-mount-consts.py	2022-08-31 07:16:42.000000000 +0200
@@ -33,11 +33,16 @@
                         help='C compiler (including options) to use')
     args = parser.parse_args()
 
+    if glibcextract.compile_c_snippet(
+            '#include <linux/mount.h>',
+            args.cc).returncode != 0:
+        sys.exit (77)
+
     linux_version_headers = glibcsyscalls.linux_kernel_version(args.cc)
-    # Constants in glibc were updated to match Linux v5.16.  When glibc
+    # Constants in glibc were updated to match Linux v5.19.  When glibc
     # constants are updated this value should be updated to match the
     # released kernel version from which the constants were taken.
-    linux_version_glibc = (5, 16)
+    linux_version_glibc = (5, 19)
     def check(cte, exclude=None):
         return glibcextract.compare_macro_consts(
                 '#include <sys/mount.h>\n',
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-pidfd.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-pidfd.c
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-pidfd.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-pidfd.c	2022-08-31 07:16:42.000000000 +0200
@@ -147,8 +147,11 @@
        may be denied if the process doesn't have CAP_SYS_PTRACE or
        if a LSM security_ptrace_access_check denies access.  */
     if (fd == -1 && errno == EPERM)
-      FAIL_UNSUPPORTED ("don't have permission to use pidfd_getfd on pidfd, "
-			"skipping test");
+      {
+	TEST_COMPARE (pidfd_send_signal (pidfd, SIGKILL, NULL, 0), 0);
+	FAIL_UNSUPPORTED ("don't have permission to use pidfd_getfd on pidfd, "
+			  "skipping test");
+      }
     TEST_VERIFY (fd > 0);
 
     char *path = xasprintf ("/proc/%d/fd/%d", pid, remote_fd);
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-pidfd-consts.py glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-pidfd-consts.py
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-pidfd-consts.py	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-pidfd-consts.py	2022-08-31 07:16:42.000000000 +0200
@@ -33,11 +33,13 @@
                         help='C compiler (including options) to use')
     args = parser.parse_args()
 
-    linux_version_headers = glibcsyscalls.linux_kernel_version(args.cc)
-    # Linux started to provide pidfd.h with 5.10.
-    if linux_version_headers < (5, 10):
+    if glibcextract.compile_c_snippet(
+            '#include <linux/pidfd.h>',
+            args.cc).returncode != 0:
         sys.exit (77)
-    linux_version_glibc = (5, 18)
+
+    linux_version_headers = glibcsyscalls.linux_kernel_version(args.cc)
+    linux_version_glibc = (5, 19)
     sys.exit(glibcextract.compare_macro_consts(
                 '#include <sys/pidfd.h>\n',
                 '#include <asm/fcntl.h>\n'
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/tst-process_madvise.c glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-process_madvise.c
--- glibc-2.36/sysdeps/unix/sysv/linux/tst-process_madvise.c	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/tst-process_madvise.c	2022-08-31 07:16:42.000000000 +0200
@@ -101,8 +101,11 @@
 
     /* We expect this to succeed in the target process because the mapping
        is valid.  */
-    TEST_COMPARE (process_madvise (pidfd, &iv, 1, MADV_COLD, 0),
-		  2 * page_size);
+    ssize_t ret = process_madvise (pidfd, &iv, 1, MADV_COLD, 0);
+    if (ret == -1 && errno == ENOSYS)
+      FAIL_UNSUPPORTED ("kernel does not support process_madvise, skipping"
+			"test");
+    TEST_COMPARE (ret, 2 * page_size);
   }
 
   {
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/x86_64/ldconfig.h glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
--- glibc-2.36/sysdeps/unix/sysv/linux/x86_64/ldconfig.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/x86_64/ldconfig.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-/* Copyright (C) 2001-2022 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdeps/generic/ldconfig.h>
-
-#define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux.so.2", FLAG_ELF_LIBC6 }, \
-  { "/libx32/ld-linux-x32.so.2", FLAG_ELF_LIBC6 }, \
-  { "/lib64/ld-linux-x86-64.so.2", FLAG_ELF_LIBC6 },
-#define SYSDEP_KNOWN_LIBRARY_NAMES \
-  { "libc.so.6", FLAG_ELF_LIBC6 },	\
-  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -aurN glibc-2.36/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
--- glibc-2.36/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed	2022-08-31 07:16:42.000000000 +0200
@@ -1,3 +1 @@
-/LD_TRACE_LOADED_OBJECTS=1/a\
-add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
 s_^\(RTLDLIST=\)\(.*lib\)\(\|64\|x32\)\(/[^/]*\)\(-x86-64\|-x32\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4-x86-64\6 \2x32\4-x32\6"_
diff -aurN glibc-2.36/sysdeps/x86_64/multiarch/strcpy-sse2.S glibc-20220830_c7509d49c4/sysdeps/x86_64/multiarch/strcpy-sse2.S
--- glibc-2.36/sysdeps/x86_64/multiarch/strcpy-sse2.S	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/sysdeps/x86_64/multiarch/strcpy-sse2.S	2022-08-31 07:16:42.000000000 +0200
@@ -22,7 +22,7 @@
 
 # include <sysdep.h>
 
-# ifndef STPCPY
+# ifndef STRCPY
 #  define STRCPY __strcpy_sse2
 # endif
 
diff -aurN glibc-2.36/version.h glibc-20220830_c7509d49c4/version.h
--- glibc-2.36/version.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/version.h	2022-08-31 07:16:42.000000000 +0200
@@ -1,4 +1,4 @@
 /* This file just defines the current version number of libc.  */
 
-#define RELEASE "stable"
-#define VERSION "2.36"
+#define RELEASE "development"
+#define VERSION "2.36.9000"
diff -aurN glibc-2.36/wcsmbs/bits/wchar2-decl.h glibc-20220830_c7509d49c4/wcsmbs/bits/wchar2-decl.h
--- glibc-2.36/wcsmbs/bits/wchar2-decl.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-20220830_c7509d49c4/wcsmbs/bits/wchar2-decl.h	2022-08-31 07:16:42.000000000 +0200
@@ -0,0 +1,124 @@
+/* Checking macros for wchar functions.  Declarations only.
+   Copyright (C) 2004-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_WCHAR2_DECL_H
+#define _BITS_WCHAR2_DECL_H 1
+
+#ifndef _WCHAR_H
+# error "Never include <bits/wchar2-decl.h> directly; use <wchar.h> instead."
+#endif
+
+
+extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
+			       const wchar_t *__restrict __s2, size_t __n,
+			       size_t __ns1) __THROW;
+extern wchar_t *__wmemmove_chk (wchar_t *__s1, const wchar_t *__s2,
+				size_t __n, size_t __ns1) __THROW;
+
+
+#ifdef __USE_GNU
+
+extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
+				const wchar_t *__restrict __s2, size_t __n,
+				size_t __ns1) __THROW;
+
+#endif
+
+
+extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
+			       size_t __ns) __THROW;
+extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __n) __THROW;
+extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __destlen) __THROW;
+extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src, size_t __n,
+			       size_t __destlen) __THROW;
+extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src, size_t __n,
+			       size_t __destlen) __THROW;
+extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
+			      const wchar_t *__restrict __src,
+			      size_t __destlen) __THROW;
+extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
+			       const wchar_t *__restrict __src,
+			       size_t __n, size_t __destlen) __THROW;
+extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
+			   int __flag, size_t __s_len,
+			   const wchar_t *__restrict __format, ...)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 6))) */;
+extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
+			    int __flag, size_t __s_len,
+			    const wchar_t *__restrict __format,
+			    __gnuc_va_list __arg)
+     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 0))) */;
+
+#if __USE_FORTIFY_LEVEL > 1
+
+extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
+			   const wchar_t *__restrict __format, ...);
+extern int __wprintf_chk (int __flag, const wchar_t *__restrict __format,
+			  ...);
+extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
+			    const wchar_t *__restrict __format,
+			    __gnuc_va_list __ap);
+extern int __vwprintf_chk (int __flag, const wchar_t *__restrict __format,
+			   __gnuc_va_list __ap);
+
+#endif
+
+extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
+			      __FILE *__restrict __stream) __wur;
+
+#ifdef __USE_GNU
+
+extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
+				       int __n, __FILE *__restrict __stream)
+       __wur;
+
+#endif
+
+extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
+			     mbstate_t *__restrict __p,
+			     size_t __buflen) __THROW __wur;
+extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
+			       const char **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen) __THROW;
+extern size_t __wcsrtombs_chk (char *__restrict __dst,
+			       const wchar_t **__restrict __src,
+			       size_t __len, mbstate_t *__restrict __ps,
+			       size_t __dstlen) __THROW;
+
+#ifdef	__USE_XOPEN2K8
+
+extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
+				const char **__restrict __src, size_t __nmc,
+				size_t __len, mbstate_t *__restrict __ps,
+				size_t __dstlen) __THROW;
+extern size_t __wcsnrtombs_chk (char *__restrict __dst,
+				const wchar_t **__restrict __src,
+				size_t __nwc, size_t __len,
+				mbstate_t *__restrict __ps, size_t __dstlen)
+       __THROW;
+
+#endif
+
+#endif /* bits/wchar2-decl.h.  */
diff -aurN glibc-2.36/wcsmbs/bits/wchar2.h glibc-20220830_c7509d49c4/wcsmbs/bits/wchar2.h
--- glibc-2.36/wcsmbs/bits/wchar2.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/wcsmbs/bits/wchar2.h	2022-08-31 07:16:42.000000000 +0200
@@ -21,9 +21,6 @@
 #endif
 
 
-extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
-			       const wchar_t *__restrict __s2, size_t __n,
-			       size_t __ns1) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wmemcpy_alias,
 				(wchar_t *__restrict __s1,
 				 const wchar_t *__restrict __s2, size_t __n),
@@ -45,8 +42,6 @@
 }
 
 
-extern wchar_t *__wmemmove_chk (wchar_t *__s1, const wchar_t *__s2,
-				size_t __n, size_t __ns1) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wmemmove_alias, (wchar_t *__s1,
 						   const wchar_t *__s2,
 						   size_t __n), wmemmove);
@@ -66,9 +61,6 @@
 
 
 #ifdef __USE_GNU
-extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
-				const wchar_t *__restrict __s2, size_t __n,
-				size_t __ns1) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wmempcpy_alias,
 				(wchar_t *__restrict __s1,
 				 const wchar_t *__restrict __s2,
@@ -91,8 +83,6 @@
 #endif
 
 
-extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
-			       size_t __ns) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wmemset_alias, (wchar_t *__s, wchar_t __c,
 						  size_t __n), wmemset);
 extern wchar_t *__REDIRECT_NTH (__wmemset_chk_warn,
@@ -110,9 +100,6 @@
 }
 
 
-extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
-			      const wchar_t *__restrict __src,
-			      size_t __n) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcscpy_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src), wcscpy);
@@ -127,9 +114,6 @@
 }
 
 
-extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
-			      const wchar_t *__restrict __src,
-			      size_t __destlen) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcpcpy_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src), wcpcpy);
@@ -144,9 +128,6 @@
 }
 
 
-extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
-			       const wchar_t *__restrict __src, size_t __n,
-			       size_t __destlen) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcsncpy_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src,
@@ -168,9 +149,6 @@
 }
 
 
-extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
-			       const wchar_t *__restrict __src, size_t __n,
-			       size_t __destlen) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcpncpy_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src,
@@ -192,9 +170,6 @@
 }
 
 
-extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
-			      const wchar_t *__restrict __src,
-			      size_t __destlen) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcscat_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src), wcscat);
@@ -209,9 +184,6 @@
 }
 
 
-extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
-			       const wchar_t *__restrict __src,
-			       size_t __n, size_t __destlen) __THROW;
 extern wchar_t *__REDIRECT_NTH (__wcsncat_alias,
 				(wchar_t *__restrict __dest,
 				 const wchar_t *__restrict __src,
@@ -228,10 +200,6 @@
 }
 
 
-extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
-			   int __flag, size_t __s_len,
-			   const wchar_t *__restrict __format, ...)
-     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 6))) */;
 
 extern int __REDIRECT_NTH_LDBL (__swprintf_alias,
 				(wchar_t *__restrict __s, size_t __n,
@@ -258,11 +226,6 @@
    : swprintf (s, n, __VA_ARGS__))
 #endif
 
-extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
-			    int __flag, size_t __s_len,
-			    const wchar_t *__restrict __format,
-			    __gnuc_va_list __arg)
-     __THROW /* __attribute__ ((__format__ (__wprintf__, 5, 0))) */;
 
 extern int __REDIRECT_NTH_LDBL (__vswprintf_alias,
 				(wchar_t *__restrict __s, size_t __n,
@@ -283,16 +246,6 @@
 
 #if __USE_FORTIFY_LEVEL > 1
 
-extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
-			   const wchar_t *__restrict __format, ...);
-extern int __wprintf_chk (int __flag, const wchar_t *__restrict __format,
-			  ...);
-extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
-			    const wchar_t *__restrict __format,
-			    __gnuc_va_list __ap);
-extern int __vwprintf_chk (int __flag, const wchar_t *__restrict __format,
-			   __gnuc_va_list __ap);
-
 # ifdef __va_arg_pack
 __fortify_function int
 wprintf (const wchar_t *__restrict __fmt, ...)
@@ -328,8 +281,6 @@
 
 #endif
 
-extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
-			      __FILE *__restrict __stream) __wur;
 extern wchar_t *__REDIRECT (__fgetws_alias,
 			    (wchar_t *__restrict __s, int __n,
 			     __FILE *__restrict __stream), fgetws) __wur;
@@ -351,9 +302,6 @@
 }
 
 #ifdef __USE_GNU
-extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
-				       int __n, __FILE *__restrict __stream)
-  __wur;
 extern wchar_t *__REDIRECT (__fgetws_unlocked_alias,
 			    (wchar_t *__restrict __s, int __n,
 			     __FILE *__restrict __stream), fgetws_unlocked)
@@ -379,9 +327,6 @@
 #endif
 
 
-extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
-			     mbstate_t *__restrict __p,
-			     size_t __buflen) __THROW __wur;
 extern size_t __REDIRECT_NTH (__wcrtomb_alias,
 			      (char *__restrict __s, wchar_t __wchar,
 			       mbstate_t *__restrict __ps), wcrtomb) __wur;
@@ -404,10 +349,6 @@
 }
 
 
-extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
-			       const char **__restrict __src,
-			       size_t __len, mbstate_t *__restrict __ps,
-			       size_t __dstlen) __THROW;
 extern size_t __REDIRECT_NTH (__mbsrtowcs_alias,
 			      (wchar_t *__restrict __dst,
 			       const char **__restrict __src,
@@ -431,10 +372,6 @@
 }
 
 
-extern size_t __wcsrtombs_chk (char *__restrict __dst,
-			       const wchar_t **__restrict __src,
-			       size_t __len, mbstate_t *__restrict __ps,
-			       size_t __dstlen) __THROW;
 extern size_t __REDIRECT_NTH (__wcsrtombs_alias,
 			      (char *__restrict __dst,
 			       const wchar_t **__restrict __src,
@@ -458,10 +395,6 @@
 
 
 #ifdef	__USE_XOPEN2K8
-extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
-				const char **__restrict __src, size_t __nmc,
-				size_t __len, mbstate_t *__restrict __ps,
-				size_t __dstlen) __THROW;
 extern size_t __REDIRECT_NTH (__mbsnrtowcs_alias,
 			      (wchar_t *__restrict __dst,
 			       const char **__restrict __src, size_t __nmc,
@@ -485,11 +418,6 @@
 }
 
 
-extern size_t __wcsnrtombs_chk (char *__restrict __dst,
-				const wchar_t **__restrict __src,
-				size_t __nwc, size_t __len,
-				mbstate_t *__restrict __ps, size_t __dstlen)
-     __THROW;
 extern size_t __REDIRECT_NTH (__wcsnrtombs_alias,
 			      (char *__restrict __dst,
 			       const wchar_t **__restrict __src,
diff -aurN glibc-2.36/wcsmbs/Makefile glibc-20220830_c7509d49c4/wcsmbs/Makefile
--- glibc-2.36/wcsmbs/Makefile	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/wcsmbs/Makefile	2022-08-31 07:16:42.000000000 +0200
@@ -22,8 +22,9 @@
 
 include ../Makeconfig
 
-headers	:= wchar.h bits/wchar.h bits/wchar2.h bits/wchar-ldbl.h uchar.h \
-	   bits/types/__mbstate_t.h bits/types/mbstate_t.h bits/types/wint_t.h
+headers	:= wchar.h bits/wchar.h bits/wchar2.h bits/wchar2-decl.h \
+	   bits/wchar-ldbl.h uchar.h bits/types/__mbstate_t.h \
+	   bits/types/mbstate_t.h bits/types/wint_t.h
 
 routines := wcscat wcschr wcscmp wcscpy wcscspn wcsdup wcslen wcsncat \
 	    wcsncmp wcsncpy wcspbrk wcsrchr wcsspn wcstok wcsstr wmemchr \
@@ -73,6 +74,8 @@
 $(objpfx)tst-wcstod-nan-locale.out: $(gen-locales)
 $(objpfx)tst-c16-surrogate.out: $(gen-locales)
 $(objpfx)tst-c32-state.out: $(gen-locales)
+$(objpfx)test-c8rtomb.out: $(gen-locales)
+$(objpfx)test-mbrtoc8.out: $(gen-locales)
 endif
 
 $(objpfx)tst-wcstod-round: $(libm)
diff -aurN glibc-2.36/wcsmbs/uchar.h glibc-20220830_c7509d49c4/wcsmbs/uchar.h
--- glibc-2.36/wcsmbs/uchar.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/wcsmbs/uchar.h	2022-08-31 07:16:42.000000000 +0200
@@ -34,8 +34,16 @@
 /* Declare the C2x char8_t typedef in C2x modes, but only if the C++
   __cpp_char8_t feature test macro is not defined.  */
 #if __GLIBC_USE (ISOC2X) && !defined __cpp_char8_t
+#if __GNUC_PREREQ (10, 0) && defined __cplusplus
+/* Suppress the diagnostic regarding char8_t being a keyword in C++20.  */
+# pragma GCC diagnostic push
+# pragma GCC diagnostic ignored "-Wc++20-compat"
+#endif
 /* Define the 8-bit character type.  */
 typedef unsigned char char8_t;
+#if __GNUC_PREREQ (10, 0) && defined __cplusplus
+# pragma GCC diagnostic pop
+#endif
 #endif
 
 #ifndef __USE_ISOCXX11
diff -aurN glibc-2.36/wcsmbs/wchar.h glibc-20220830_c7509d49c4/wcsmbs/wchar.h
--- glibc-2.36/wcsmbs/wchar.h	2022-07-30 00:03:09.000000000 +0200
+++ glibc-20220830_c7509d49c4/wcsmbs/wchar.h	2022-08-31 07:16:42.000000000 +0200
@@ -864,14 +864,21 @@
 
 /* Define some macros helping to catch buffer overflows.  */
 #if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
-# include <bits/wchar2.h>
+/* Declare all functions from bits/wchar2-decl.h first.  */
+# include <bits/wchar2-decl.h>
 #endif
 
-#include <bits/floatn.h>
+/* The following headers provide asm redirections.  These redirections must
+   appear before the first usage of these functions, e.g. in bits/wchar.h.  */
 #if defined __LDBL_COMPAT || __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1
 # include <bits/wchar-ldbl.h>
 #endif
 
+#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+/* Now include the function definitions and redirects too.  */
+# include <bits/wchar2.h>
+#endif
+
 __END_DECLS
 
 #endif /* wchar.h  */
