From e1d559f337de2c8ab68a6749dfe873477c883807 Mon Sep 17 00:00:00 2001
From: Florian Weimer <fweimer@redhat.com>
Date: Sat, 02 Nov 2019 20:04:02 +0100
Subject: [PATCH] Introduce link_map_audit_state accessor function

To improve GCC 10 compatibility, it is necessary to remove the l_audit
zero-length array from the end of struct link_map.  In preparation of
that, this commit introduces an accessor function for the audit state,
so that it is possible to change the representation of the audit state
without adjusting the code that accesses it.

Tested on x86_64-linux-gnu.  Built on i686-gnu.

Change-Id: Id815673c29950fc011ae5301d7cde12624f658df
---

diff --git a/csu/libc-start.c b/csu/libc-start.c
index 14e2b69..e9e8e44 100644
--- a/csu/libc-start.c
+++ b/csu/libc-start.c
@@ -272,7 +272,7 @@
       for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	{
 	  if (afct->preinit != NULL)
-	    afct->preinit (&head->l_audit[cnt].cookie);
+	    afct->preinit (&link_map_audit_state (head, cnt)->cookie);
 
 	  afct = afct->next;
 	}
diff --git a/elf/dl-close.c b/elf/dl-close.c
index de91c28..c32e647 100644
--- a/elf/dl-close.c
+++ b/elf/dl-close.c
@@ -302,8 +302,12 @@
 	      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 		{
 		  if (afct->objclose != NULL)
-		    /* Return value is ignored.  */
-		    (void) afct->objclose (&imap->l_audit[cnt].cookie);
+		    {
+		      struct auditstate *state
+			= link_map_audit_state (imap, cnt);
+		      /* Return value is ignored.  */
+		      (void) afct->objclose (&state->cookie);
+		    }
 
 		  afct = afct->next;
 		}
@@ -478,7 +482,10 @@
 	  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	    {
 	      if (afct->activity != NULL)
-		afct->activity (&head->l_audit[cnt].cookie, LA_ACT_DELETE);
+		{
+		  struct auditstate *state = link_map_audit_state (head, cnt);
+		  afct->activity (&state->cookie, LA_ACT_DELETE);
+		}
 
 	      afct = afct->next;
 	    }
@@ -774,7 +781,10 @@
 	  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	    {
 	      if (afct->activity != NULL)
-		afct->activity (&head->l_audit[cnt].cookie, LA_ACT_CONSISTENT);
+		{
+		  struct auditstate *state = link_map_audit_state (head, cnt);
+		  afct->activity (&state->cookie, LA_ACT_CONSISTENT);
+		}
 
 	      afct = afct->next;
 	    }
diff --git a/elf/dl-fini.c b/elf/dl-fini.c
index bed736d..70e7346 100644
--- a/elf/dl-fini.c
+++ b/elf/dl-fini.c
@@ -152,9 +152,12 @@
 		      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 			{
 			  if (afct->objclose != NULL)
-			    /* Return value is ignored.  */
-			    (void) afct->objclose (&l->l_audit[cnt].cookie);
-
+			    {
+			      struct auditstate *state
+				= link_map_audit_state (l, cnt);
+			      /* Return value is ignored.  */
+			      (void) afct->objclose (&state->cookie);
+			    }
 			  afct = afct->next;
 			}
 		    }
diff --git a/elf/dl-load.c b/elf/dl-load.c
index c1bc8c2..6cdd11e 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -973,7 +973,8 @@
 	      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 		{
 		  if (afct->activity != NULL)
-		    afct->activity (&head->l_audit[cnt].cookie, LA_ACT_ADD);
+		    afct->activity (&link_map_audit_state (head, cnt)->cookie,
+				    LA_ACT_ADD);
 
 		  afct = afct->next;
 		}
@@ -1402,10 +1403,9 @@
 	{
 	  if (afct->objopen != NULL)
 	    {
-	      l->l_audit[cnt].bindflags
-		= afct->objopen (l, nsid, &l->l_audit[cnt].cookie);
-
-	      l->l_audit_any_plt |= l->l_audit[cnt].bindflags != 0;
+	      struct auditstate *state = link_map_audit_state (l, cnt);
+	      state->bindflags = afct->objopen (l, nsid, &state->cookie);
+	      l->l_audit_any_plt |= state->bindflags != 0;
 	    }
 
 	  afct = afct->next;
@@ -1511,8 +1511,8 @@
 	{
 	  if (afct->objsearch != NULL)
 	    {
-	      name = afct->objsearch (name, &loader->l_audit[cnt].cookie,
-				      whatcode);
+	      struct auditstate *state = link_map_audit_state (loader, cnt);
+	      name = afct->objsearch (name, &state->cookie, whatcode);
 	      if (name == NULL)
 		/* Ignore the path.  */
 		return -1;
@@ -1970,8 +1970,8 @@
 	  if (afct->objsearch != NULL)
 	    {
 	      const char *before = name;
-	      name = afct->objsearch (name, &loader->l_audit[cnt].cookie,
-				      LA_SER_ORIG);
+	      struct auditstate *state = link_map_audit_state (loader, cnt);
+	      name = afct->objsearch (name, &state->cookie, LA_SER_ORIG);
 	      if (name == NULL)
 		{
 		  /* Do not try anything further.  */
diff --git a/elf/dl-object.c b/elf/dl-object.c
index 4dff99e..225e2cc 100644
--- a/elf/dl-object.c
+++ b/elf/dl-object.c
@@ -81,7 +81,7 @@
   struct link_map *new;
   struct libname_list *newname;
 #ifdef SHARED
-  size_t audit_space = naudit * sizeof (new->l_audit[0]);
+  size_t audit_space = naudit * sizeof (struct auditstate);
 #else
 # define audit_space 0
 #endif
@@ -134,10 +134,8 @@
 
 #ifdef SHARED
   for (unsigned int cnt = 0; cnt < naudit; ++cnt)
-    {
-      new->l_audit[cnt].cookie = (uintptr_t) new;
-      /* new->l_audit[cnt].bindflags = 0; */
-    }
+    /* No need to initialize bindflags due to calloc.  */
+    link_map_audit_state (new, cnt)->cookie = (uintptr_t) new;
 #endif
 
   /* new->l_global = 0;	We use calloc therefore not necessary.  */
diff --git a/elf/dl-open.c b/elf/dl-open.c
index a9fd4cb..8d699d3 100644
--- a/elf/dl-open.c
+++ b/elf/dl-open.c
@@ -278,7 +278,10 @@
 	  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	    {
 	      if (afct->activity != NULL)
-		afct->activity (&head->l_audit[cnt].cookie, LA_ACT_CONSISTENT);
+		{
+		  struct auditstate *state = link_map_audit_state (head, cnt);
+		  afct->activity (&state->cookie, LA_ACT_CONSISTENT);
+		}
 
 	      afct = afct->next;
 	    }
diff --git a/elf/dl-runtime.c b/elf/dl-runtime.c
index 342b794..8457862 100644
--- a/elf/dl-runtime.c
+++ b/elf/dl-runtime.c
@@ -325,15 +325,18 @@
 		{
 		  /* XXX Check whether both DSOs must request action or
 		     only one */
-		  if ((l->l_audit[cnt].bindflags & LA_FLG_BINDFROM) != 0
-		      && (result->l_audit[cnt].bindflags & LA_FLG_BINDTO) != 0)
+		  struct auditstate *l_state = link_map_audit_state (l, cnt);
+		  struct auditstate *result_state
+		    = link_map_audit_state (result, cnt);
+		  if ((l_state->bindflags & LA_FLG_BINDFROM) != 0
+		      && (result_state->bindflags & LA_FLG_BINDTO) != 0)
 		    {
 		      if (afct->symbind != NULL)
 			{
 			  uintptr_t new_value
 			    = afct->symbind (&sym, reloc_result->boundndx,
-					     &l->l_audit[cnt].cookie,
-					     &result->l_audit[cnt].cookie,
+					     &l_state->cookie,
+					     &result_state->cookie,
 					     &flags,
 					     strtab2 + defsym->st_name);
 			  if (new_value != (uintptr_t) sym.st_value)
@@ -421,10 +424,13 @@
 		  & (LA_SYMB_NOPLTENTER << (2 * (cnt + 1)))) == 0)
 	    {
 	      long int new_framesize = -1;
+	      struct auditstate *l_state = link_map_audit_state (l, cnt);
+	      struct auditstate *bound_state
+		= link_map_audit_state (reloc_result->bound, cnt);
 	      uintptr_t new_value
 		= afct->ARCH_LA_PLTENTER (&sym, reloc_result->boundndx,
-					  &l->l_audit[cnt].cookie,
-					  &reloc_result->bound->l_audit[cnt].cookie,
+					  &l_state->cookie,
+					  &bound_state->cookie,
 					  regs, &flags, symname,
 					  &new_framesize);
 	      if (new_value != (uintptr_t) sym.st_value)
@@ -504,9 +510,11 @@
 	  && (reloc_result->enterexit
 	      & (LA_SYMB_NOPLTEXIT >> (2 * cnt))) == 0)
 	{
+	  struct auditstate *l_state = link_map_audit_state (l, cnt);
+	  struct auditstate *bound_state
+	    = link_map_audit_state (reloc_result->bound, cnt);
 	  afct->ARCH_LA_PLTEXIT (&sym, reloc_result->boundndx,
-				 &l->l_audit[cnt].cookie,
-				 &reloc_result->bound->l_audit[cnt].cookie,
+				 &l_state->cookie, &bound_state->cookie,
 				 inregs, outregs, symname);
 	}
 
diff --git a/elf/dl-sym.c b/elf/dl-sym.c
index 8209342..21e025b 100644
--- a/elf/dl-sym.c
+++ b/elf/dl-sym.c
@@ -198,17 +198,20 @@
 
 	      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 		{
+		  struct auditstate *match_audit
+		    = link_map_audit_state (match, cnt);
+		  struct auditstate *result_audit
+		    = link_map_audit_state (result, cnt);
 		  if (afct->symbind != NULL
-		      && ((match->l_audit[cnt].bindflags & LA_FLG_BINDFROM)
-			  != 0
-			  || ((result->l_audit[cnt].bindflags & LA_FLG_BINDTO)
+		      && ((match_audit->bindflags & LA_FLG_BINDFROM) != 0
+			  || ((result_audit->bindflags & LA_FLG_BINDTO)
 			      != 0)))
 		    {
 		      unsigned int flags = altvalue | LA_SYMB_DLSYM;
 		      uintptr_t new_value
 			= afct->symbind (&sym, ndx,
-					 &match->l_audit[cnt].cookie,
-					 &result->l_audit[cnt].cookie,
+					 &match_audit->cookie,
+					 &result_audit->cookie,
 					 &flags, strtab + ref->st_name);
 		      if (new_value != (uintptr_t) sym.st_value)
 			{
diff --git a/elf/rtld.c b/elf/rtld.c
index d54a796..e22c756 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -1025,9 +1025,9 @@
   else
     *last_audit = (*last_audit)->next = &newp->ifaces;
 
-  /* The dynamic linker link map is statically allocated, initialize
-     the data now.  */
-  GL (dl_rtld_map).l_audit[GLRO (dl_naudit)].cookie
+  /* The dynamic linker link map is statically allocated, so the
+     cookie in _dl_new_object has not happened.  */
+  link_map_audit_state (&GL (dl_rtld_map), GLRO (dl_naudit))->cookie
     = (intptr_t) &GL (dl_rtld_map);
 
   ++GLRO(dl_naudit);
@@ -1046,9 +1046,9 @@
     {
       if (afct->objopen != NULL)
 	{
-	  map->l_audit[cnt].bindflags
-	    = afct->objopen (map, LM_ID_BASE, &map->l_audit[cnt].cookie);
-	  map->l_audit_any_plt |= map->l_audit[cnt].bindflags != 0;
+	  struct auditstate *state = link_map_audit_state (map, cnt);
+	  state->bindflags = afct->objopen (map, LM_ID_BASE, &state->cookie);
+	  map->l_audit_any_plt |= state->bindflags != 0;
 	}
 
       afct = afct->next;
@@ -1662,7 +1662,8 @@
       for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	{
 	  if (afct->activity != NULL)
-	    afct->activity (&main_map->l_audit[cnt].cookie, LA_ACT_ADD);
+	    afct->activity (&link_map_audit_state (main_map, cnt)->cookie,
+			    LA_ACT_ADD);
 
 	  afct = afct->next;
 	}
@@ -2333,7 +2334,8 @@
 	  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
 	    {
 	      if (afct->activity != NULL)
-		afct->activity (&head->l_audit[cnt].cookie, LA_ACT_CONSISTENT);
+		afct->activity (&link_map_audit_state (head, cnt)->cookie,
+				LA_ACT_CONSISTENT);
 
 	      afct = afct->next;
 	    }
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index a6991f3..923bd4c 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -1174,7 +1174,13 @@
      initialized and active ld.so copy.  */
   return GLRO(dl_init_all_dirs) != NULL;
 }
-#endif
+
+static inline struct auditstate *
+link_map_audit_state (struct link_map *l, size_t index)
+{
+  return &l->l_audit[index];
+}
+#endif /* SHARED */
 
 __END_DECLS
 
